<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>个人知识库</title>
    <meta name="description" content="个人知识库">
    <meta name="generator" content="VitePress v2.0.0-alpha.12">
    <link rel="preload stylesheet" href="/myKMS/assets/style.BNxtA7kc.css" as="style">
    <link rel="preload stylesheet" href="/myKMS/vp-icons.css" as="style">
    
    <script type="module" src="/myKMS/assets/app.CkxRFsqJ.js"></script>
    <link rel="preload" href="/myKMS/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/myKMS/assets/chunks/theme.fgKfk125.js">
    <link rel="modulepreload" href="/myKMS/assets/chunks/framework.fGi7qB65.js">
    <link rel="modulepreload" href="/myKMS/assets/knowledge_framework_vite.md.DnVbzkeU.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-304c8b69><!--[--><!--]--><!--[--><span tabindex="-1" data-v-fcbfc0e0></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-fcbfc0e0>Skip to content</a><!--]--><!----><header class="VPNav" data-v-304c8b69 data-v-d5bf7c8e><div class="VPNavBar" data-v-d5bf7c8e data-v-8eab0e6d><div class="wrapper" data-v-8eab0e6d><div class="container" data-v-8eab0e6d><div class="title" data-v-8eab0e6d><div class="VPNavBarTitle has-sidebar" data-v-8eab0e6d data-v-d4488dd0><a class="title" href="/myKMS/" data-v-d4488dd0><!--[--><!--]--><!----><span data-v-d4488dd0>个人知识库</span><!--[--><!--]--></a></div></div><div class="content" data-v-8eab0e6d><div class="content-body" data-v-8eab0e6d><!--[--><!--]--><div class="VPNavBarSearch search" data-v-8eab0e6d><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-8eab0e6d data-v-020be4db><span id="main-nav-aria-label" class="visually-hidden" data-v-020be4db> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/myKMS/" tabindex="0" data-v-020be4db data-v-815115f5><!--[--><span data-v-815115f5>Home</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/myKMS/interview/code.html" tabindex="0" data-v-020be4db data-v-815115f5><!--[--><span data-v-815115f5>面试</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/myKMS/knowledge/framework/react.html" tabindex="0" data-v-020be4db data-v-815115f5><!--[--><span data-v-815115f5>框架</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/myKMS/knowledge/browser/http.html" tabindex="0" data-v-020be4db data-v-815115f5><!--[--><span data-v-815115f5>浏览器</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-8eab0e6d data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-8eab0e6d data-v-ef6192dc data-v-a1a7286e><!--[--><a class="VPSocialLink no-icon" href="https://github.com/xingyuanlong/myKMS" aria-label="github" target="_blank" rel="me noopener" data-v-a1a7286e data-v-32d78712><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-8eab0e6d data-v-f953d92f data-v-d8fae6e2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-d8fae6e2><span class="vpi-more-horizontal icon" data-v-d8fae6e2></span></button><div class="menu" data-v-d8fae6e2><div class="VPMenu" data-v-d8fae6e2 data-v-fcd1d7a8><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>Appearance</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-a1a7286e><!--[--><a class="VPSocialLink no-icon" href="https://github.com/xingyuanlong/myKMS" aria-label="github" target="_blank" rel="me noopener" data-v-a1a7286e data-v-32d78712><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-8eab0e6d data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-8eab0e6d><div class="divider-line" data-v-8eab0e6d></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-304c8b69 data-v-5ae341c6><div class="container" data-v-5ae341c6><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-5ae341c6><span class="vpi-align-left menu-icon" data-v-5ae341c6></span><span class="menu-text" data-v-5ae341c6>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-5ae341c6 data-v-e28a51a6><button data-v-e28a51a6>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-304c8b69 data-v-e0eef791><div class="curtain" data-v-e0eef791></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-e0eef791><span class="visually-hidden" id="sidebar-aria-label" data-v-e0eef791> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0" data-v-a84b7c21 data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h2 class="text" data-v-6b36a2fd>基础知识</h2><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/base/js.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>js</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/base/nodejs.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>node</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/base/css.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>css</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0" data-v-a84b7c21 data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h2 class="text" data-v-6b36a2fd>interview</h2><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/interview/2025.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>2025</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/interview/code.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>code</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/interview/index.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>开放性问题</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0 has-active" data-v-a84b7c21 data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h2 class="text" data-v-6b36a2fd>框架</h2><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/framework/react.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>react</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/framework/vue.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>vue</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/framework/vite.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>工程化</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/framework/electron.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>electron</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0" data-v-a84b7c21 data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h2 class="text" data-v-6b36a2fd>浏览器</h2><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/browser/index.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>browser</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/browser/http.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>http</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/browser/webSecurity.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>web安全</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0" data-v-a84b7c21 data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h2 class="text" data-v-6b36a2fd>读书笔记</h2><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/book/vue_1.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>vue.js 设计与实践</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0" data-v-a84b7c21 data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h2 class="text" data-v-6b36a2fd>算法</h2><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/algorithm/index.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>总</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0" data-v-a84b7c21 data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h2 class="text" data-v-6b36a2fd>AI</h2><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/ai/index.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>ai</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-304c8b69 data-v-2652e39a><div class="VPDoc has-sidebar has-aside" data-v-2652e39a data-v-d668f7cc><!--[--><!--]--><div class="container" data-v-d668f7cc><div class="aside" data-v-d668f7cc><div class="aside-curtain" data-v-d668f7cc></div><div class="aside-container" data-v-d668f7cc><div class="aside-content" data-v-d668f7cc><div class="VPDocAside" data-v-d668f7cc data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-c8b19031><div class="content" data-v-c8b19031><div class="outline-marker" data-v-c8b19031></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-c8b19031>页面导航</div><ul class="VPDocOutlineItem root" data-v-c8b19031 data-v-b7d7ef80><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-d668f7cc><div class="content-container" data-v-d668f7cc><!--[--><!--]--><main class="main" data-v-d668f7cc><div style="position:relative;" class="vp-doc _myKMS_knowledge_framework_vite" data-v-d668f7cc><div><h2 id="webpack" tabindex="-1">webpack <a class="header-anchor" href="#webpack" aria-label="Permalink to “webpack”">​</a></h2><h3 id="_1-webpack-的工作流程" tabindex="-1">1.Webpack 的工作流程 <a class="header-anchor" href="#_1-webpack-的工作流程" aria-label="Permalink to “1.Webpack 的工作流程”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><p>Webpack 的工作流程</p><ul><li><ol><li>入口（Entry）：从指定文件（如 index.js）开始分析依赖。</li></ol></li><li><ol start="2"><li>依赖图（Dependency Graph）：递归构建模块间的依赖关系。</li></ol></li><li><ol start="3"><li>加载器（Loaders）：转换非 JS 资源（如编译 Sass、处理图片）。</li></ol></li><li><ol start="4"><li>插件（Plugins）：在构建生命周期中执行优化任务。</li></ol></li><li><ol start="5"><li>输出（Output）：生成优化后的静态文件（如 bundle.js）。</li></ol></li></ul><!--]--></div></div><h3 id="_2-webpack-中的-loaders-和-plugins-有什么区别" tabindex="-1">2.Webpack 中的 Loaders 和 Plugins 有什么区别 <a class="header-anchor" href="#_2-webpack-中的-loaders-和-plugins-有什么区别" aria-label="Permalink to “2.Webpack 中的 Loaders 和 Plugins 有什么区别”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><table tabindex="0"><thead><tr><th style="text-align:left;">对比项</th><th style="text-align:left;"><strong>Loader</strong></th><th style="text-align:left;"><strong>Plugin</strong></th></tr></thead><tbody><tr><td style="text-align:left;">作用阶段</td><td style="text-align:left;">文件加载、转换阶段（打包前）</td><td style="text-align:left;">编译、打包的整个生命周期</td></tr><tr><td style="text-align:left;">操作对象</td><td style="text-align:left;">单个模块文件（JS、CSS、图片等）</td><td style="text-align:left;">整个编译过程（模块、资源、chunk、输出）</td></tr><tr><td style="text-align:left;">类型</td><td style="text-align:left;">转换器（Transformer）</td><td style="text-align:left;">扩展器（Enhancer）</td></tr><tr><td style="text-align:left;">常见用途</td><td style="text-align:left;">把非 JS 资源转成 JS 模块</td><td style="text-align:left;">优化、注入、压缩、环境变量等</td></tr><tr><td style="text-align:left;">调用方式</td><td style="text-align:left;"><code>module.rules</code> 中配置 <code>use</code></td><td style="text-align:left;"><code>plugins</code> 数组中配置</td></tr><tr><td style="text-align:left;">工作机制</td><td style="text-align:left;">线性执行（从右到左）</td><td style="text-align:left;">基于 Tapable 的事件钩子机制</td></tr><tr><td style="text-align:left;">示例</td><td style="text-align:left;"><code>babel-loader</code>, <code>css-loader</code>, <code>url-loader</code></td><td style="text-align:left;"><code>HtmlWebpackPlugin</code>, <code>DefinePlugin</code>, <code>MiniCssExtractPlugin</code></td></tr></tbody></table><p>Loader 执行机制</p><ul><li>串行执行（从右到左）；</li><li>每个 loader 接收上一个 loader 的结果；</li><li>只能处理文件内容字符串；</li><li>是一个纯函数（无副作用）。</li></ul><p>Plugin 执行机制</p><ul><li>通过 Webpack 的 Tapable 钩子系统；</li><li>插入到 Webpack 的编译生命周期中；</li><li>可以访问 compiler、compilation 对象；</li><li>可读可写资源、依赖、输出、日志等。</li></ul><!--]--></div></div><h3 id="_3-tree-shaking" tabindex="-1">3.Tree Shaking <a class="header-anchor" href="#_3-tree-shaking" aria-label="Permalink to “3.Tree Shaking”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><p>Tree Shaking = 静态分析 + dead code elimination</p><ul><li>去除未使用代码的技术, ESM 的 import/export 是静态分析的. 本质目标：减少打包体积，把代码中 未引用的函数、变量、类 剔除掉。</li><li>支持条件: <ul><li>必须使用 ES Module;</li><li>导出必须是静态; 副作用(如果模块执行会有副作用（如修改全局变量），Tree Shaking 默认不会移除整个模块).</li><li>动态 import 可以按需加载，但静态分析更高效;</li><li>类库打包方式影响 Tree Shaking(lodash/es → 支持 Tree Shaking,lodash → CommonJS，不支持)</li></ul></li></ul><!--]--></div></div><h3 id="_4-tree-shaking-对-css-有效吗" tabindex="-1">4. Tree Shaking 对 css 有效吗 <a class="header-anchor" href="#_4-tree-shaking-对-css-有效吗" aria-label="Permalink to “4. Tree Shaking 对 css 有效吗”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><ul><li><p>纯 CSS 文件</p><ul><li>Tree Shaking 无法分析哪些 CSS 类使用或未使用</li><li>所以 未使用的 CSS 默认不会被移除</li></ul></li><li><p>CSS-in-JS / CSS Module</p><ul><li>CSS-in-JS（如 styled-components, emotion）生成的 JS 代码</li><li>对未使用的 styled 组件，Webpack/Rollup 的 Tree Shaking 可以删除对应 JS，从而间接删除样式</li><li>但这需要 样式写在 JS 里，纯 CSS 文件不适用</li></ul></li><li><p>tailwind / PostCSS / PurgeCSS</p><ul><li>对于类名型 CSS（如 Tailwind、Bootstrap）</li><li>可以使用工具 扫描项目源码，删除未使用类</li><li>原理类似 Tree Shaking，但实际上是 静态 CSS 去重，不依赖 JS Tree Shaking</li></ul></li></ul><!--]--></div></div><h3 id="_5-webpack-runtime-是啥" tabindex="-1">5. webpack runtime 是啥 <a class="header-anchor" href="#_5-webpack-runtime-是啥" aria-label="Permalink to “5. webpack runtime 是啥”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><p><strong>webpack runtime = 浏览器端的模块管理器 + 动态加载器 + 缓存器</strong></p><p>webpack 为了在浏览器执行模块打包后的代码而生成的一套加载、执行、管理模块的核心逻辑。</p><p>负责:</p><ul><li>加载模块 (<strong>webpack_require</strong>) <ul><li>核心加载器，用来执行模块函数并返回 exports</li><li>每个模块在打包后都变成一个函数 <code>(module, exports, **webpack_require**) =&gt; { … }</code></li></ul></li><li>缓存模块 <ul><li>webpack 会把每个模块的执行结果缓存，避免重复执行：</li></ul></li><li>支持动态 import / chunk 加载 <ul><li>JSONP 或 Module Federation 加载</li><li>chunk 加载状态表</li></ul></li><li>处理热更新（HMR） <ul><li>监听更新的 chunk；</li><li>动态替换模块内容，不刷新页面</li></ul></li></ul><!--]--></div></div><h3 id="_6-webpack-有哪些优化项目的手段" tabindex="-1">6. webpack 有哪些优化项目的手段？ <a class="header-anchor" href="#_6-webpack-有哪些优化项目的手段" aria-label="Permalink to “6. webpack  有哪些优化项目的手段？”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><p>围绕 webpack 做性能优化，分为两个方面： 构建时间优化 、 构建体积优化</p><ul><li><p>构建时间优化</p><ul><li>缩小范围</li><li>文件后缀</li><li>别名</li><li>缓存</li><li>并行构建(多核心)</li><li>定向查找第三方模块</li></ul></li><li><p>构建结果优化</p><ul><li>压缩 js</li><li>压缩 css</li><li>压缩 html</li><li>压缩图片</li><li>按需加载</li><li>prload、prefetch</li><li>代码分割</li><li>tree shaking</li><li>gzip</li><li>作用域提升</li></ul></li></ul><!--]--></div></div><h2 id="vite" tabindex="-1">vite <a class="header-anchor" href="#vite" aria-label="Permalink to “vite”">​</a></h2><h3 id="_1-简述vite的依赖预加载机制" tabindex="-1">1. 简述Vite的依赖预加载机制 <a class="header-anchor" href="#_1-简述vite的依赖预加载机制" aria-label="Permalink to “1. 简述Vite的依赖预加载机制”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><p><strong>Vite 的依赖预构建机制通过在开发模式下提前处理常用依赖（如 Vue、React 等），将这些依赖转换为浏览器可以直接执行的格式。这避免了每次启动时重新编译这些依赖，显著提升了启动速度。</strong> 预构建的依赖被缓存，并在后续启动时复用缓存，进一步加速了开发过程中的构建和启动时间。</p><p>具体来说，它的工作原理如下：</p><ol><li>依赖识别和路径补全： Vite 会首先识别项目中需要的依赖，并对非绝对路径或相对路径的引用进行路径补全。比如，Vue 的加载路径会变为 node_modules/.vite/deps/Vue.js?v=1484ebe8，这一路径显示了 Vite 在 node_modules/.vite/deps 文件夹下存放了经过预处理的依赖文件。</li><li>转换成 ES 模块： 一些第三方包（特别是遵循 CommonJS 规范的包）在浏览器中无法直接使用。为了应对这种情况，Vite 会使用 esbuild 工具将这些依赖转换为符合 ES 模块规范的代码。转换后的代码会被存放在 node_modules/.vite/deps 文件夹下，这样浏览器就能直接识别并加载这些依赖。</li><li>统一集成 ES 模块： Vite 会对每个包的不同模块进行统一集成，将各个分散的模块（如不同的 ES 函数或组件）合并成一个或几个文件。这不仅减少了浏览器发起多个请求的次数，还能够加快页面加载速度</li></ol><!--]--></div></div><h3 id="_2-vite-hmr-模块热更新-与webpack对比" tabindex="-1">2. vite HMR 模块热更新 (与webpack对比) <a class="header-anchor" href="#_2-vite-hmr-模块热更新-与webpack对比" aria-label="Permalink to “2. vite HMR 模块热更新 (与webpack对比)”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><p>修改代码 → 浏览器自动更新 → 状态不丢失</p><p>基本工作原理</p><ol><li>开发服务器启动时：Vite 会用 ES Module 的方式向浏览器提供源码。</li><li>文件变动：Vite 通过 chokidar 监听文件改动。</li><li>HMR 通知：Vite Dev Server 用 WebSocket 通知浏览器“某个模块变了”。type:&#39;update&#39;, updates 更新的文件内容</li><li>模块替换：浏览器端的 Vite HMR 客户端会：尝试只替换改动的模块（比如 .vue 组件、.css 文件）。如i18n.json 文件修改, 会刷新页面</li><li>import.meta.hot 可以手动控制 HMR 行为</li><li>Vite 内部维护一份 模块依赖图,向上传播，找接受更新的模块, 如果无法安全替换（比如入口文件改了），就会触发 整页刷新。</li></ol><p>Webpack HMR:基本原理一致, 开发时需要 打包，生成 bundle.js, 因为有打包过程，HMR 会比 Vite 慢</p><p>为什么 Vite 的 HMR 比 Webpack 快？</p><ol><li><strong>Vite 基于 原生 ESM，不用重新打整个 bundle。</strong></li><li><strong>改动时只编译改动文件（按需编译）。</strong></li><li><strong>Webpack 需要走完整的打包流程，依赖图越大更新越慢。</strong></li><li>所以在大项目里，Webpack 热更新可能要几秒，而 Vite 通常 &lt;100ms。</li></ol><p>Vite 如何实现 React/Vue 的状态保留热更新？</p><ol><li>React：通过 @vitejs/plugin-react 集成 react-refresh，在替换组件时保留 Hook 状态。</li><li>Vue：通过 @vitejs/plugin-vue，在替换 .vue 组件时保留组件实例的响应式状态。</li><li>本质：框架层插件拦截 HMR 更新过程，执行“局部替换 + 状态迁移”。</li></ol><p>Vite HMR 可能带来的问题？</p><ol><li>内存泄漏：模块替换时没清理事件监听 / 定时器。</li><li>调试复杂度：和实际生产行为不一致（生产中没有 HMR）。</li><li>兼容性问题：某些第三方库没有 HMR 支持，只能整页刷新</li></ol><!--]--></div></div><h3 id="_3-webpack-与-vite" tabindex="-1">3.Webpack 与 Vite <a class="header-anchor" href="#_3-webpack-与-vite" aria-label="Permalink to “3.Webpack 与 Vite”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><table tabindex="0"><thead><tr><th style="text-align:left;">对比项</th><th style="text-align:left;"><strong>Webpack</strong></th><th style="text-align:left;"><strong>Vite</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>核心思想</strong></td><td style="text-align:left;">一次性<strong>打包所有文件</strong>再启动开发服务器</td><td style="text-align:left;"><strong>按需编译（ESM 原生支持）</strong>，依赖与源码分离处理</td></tr><tr><td style="text-align:left;"><strong>启动阶段</strong></td><td style="text-align:left;">需先打包整个项目（构建依赖图 → 打包输出）</td><td style="text-align:left;">启动极快，仅分析依赖，不预打包源码</td></tr><tr><td style="text-align:left;"><strong>开发模式 (dev)</strong></td><td style="text-align:left;">使用 webpack-dev-server：<br>所有模块打包成 bundle 后再提供服务</td><td style="text-align:left;">使用原生 ESM：<br>直接通过浏览器请求模块，Vite 拦截并按需编译返回</td></tr><tr><td style="text-align:left;"><strong>热更新 (HMR)</strong></td><td style="text-align:left;">修改文件后需重新打包相关 chunk，代价较高</td><td style="text-align:left;">仅重新编译变动的模块源码（原生 ESM 热替换），非常快</td></tr><tr><td style="text-align:left;"><strong>构建阶段 (build)</strong></td><td style="text-align:left;">打包时用 loader + plugin 处理所有文件，输出 bundle</td><td style="text-align:left;">构建阶段由 <strong>Rollup</strong> 完成打包（利用 ESM 静态分析）</td></tr><tr><td style="text-align:left;"><strong>打包粒度</strong></td><td style="text-align:left;">依赖与源码一起打包成 bundle</td><td style="text-align:left;">依赖单独预构建（esbuild），源码按需处理</td></tr><tr><td style="text-align:left;"><strong>依赖处理</strong></td><td style="text-align:left;">JS、CSS、图片等都需 loader 解析</td><td style="text-align:left;">依赖模块（node_modules）由 <strong>esbuild</strong> 预构建，源码按请求动态编译</td></tr><tr><td style="text-align:left;"><strong>性能瓶颈</strong></td><td style="text-align:left;">打包体积大、编译速度慢（依赖 AST 分析）</td><td style="text-align:left;">使用 <strong>esbuild（Go 编写）</strong>，依赖构建快 10-100 倍</td></tr><tr><td style="text-align:left;"><strong>构建结果</strong></td><td style="text-align:left;">输出多个 bundle 文件</td><td style="text-align:left;">输出原生 ESM 模块（经 Rollup 优化）</td></tr><tr><td style="text-align:left;"><strong>适用场景</strong></td><td style="text-align:left;">大型复杂项目，生态成熟（如 React + Webpack5）</td><td style="text-align:left;">快速开发、现代浏览器环境（Vue3、React18）</td></tr><tr><td style="text-align:left;"><strong>插件机制</strong></td><td style="text-align:left;">Tapable 构建的复杂插件系统</td><td style="text-align:left;">Rollup + Vite Hook，轻量、直观</td></tr><tr><td style="text-align:left;"><strong>配置复杂度</strong></td><td style="text-align:left;">配置项繁多（entry、loader、plugin 等）</td><td style="text-align:left;">默认开箱即用，配置极简（vite.config.js）</td></tr><tr><td style="text-align:left;"><strong>首次启动速度</strong></td><td style="text-align:left;">慢：需先打完整包</td><td style="text-align:left;">快：直接启动服务器即可运行</td></tr><tr><td style="text-align:left;"><strong>生产打包速度</strong></td><td style="text-align:left;">中等（依赖 JS 解析打包）</td><td style="text-align:left;">快：esbuild + Rollup 组合优化</td></tr><tr><td style="text-align:left;"><strong>调试体验</strong></td><td style="text-align:left;">源码被打包，调试路径复杂</td><td style="text-align:left;">源码即模块，调试路径清晰</td></tr><tr><td style="text-align:left;"><strong>静态资源处理</strong></td><td style="text-align:left;">需配置 loader（file-loader/url-loader）</td><td style="text-align:left;">内置资源处理机制，直接 import 即可</td></tr><tr><td style="text-align:left;"><strong>依赖缓存</strong></td><td style="text-align:left;">可配置 cache-loader</td><td style="text-align:left;">自动缓存依赖（esbuild 缓存 + HTTP 缓存）</td></tr></tbody></table><ul><li><p>webpack 的打包流程: 读取配置 → 创建 Compiler → 从入口构建依赖图 → Loader 转换模块 → Plugin 优化 → 生成 Chunk → 输出文件。</p></li><li><p>vite 开发时走原生 ESM + 按需编译，而生产环境走 Rollup 打包。vite 打包流程: 配置解析 -&gt; 调用 Rollup 构建 -&gt; 优化处理 -&gt; 产物生成</p></li></ul><!--]--></div></div><h3 id="_4-ssr-是啥-对比csr的优势和适用场景" tabindex="-1">4.ssr 是啥, 对比csr的优势和适用场景 <a class="header-anchor" href="#_4-ssr-是啥-对比csr的优势和适用场景" aria-label="Permalink to “4.ssr 是啥, 对比csr的优势和适用场景”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><p>SSR（Server-Side Rendering） 是指在服务器端生成 HTML 内容，再发送到浏览器渲染，而不是浏览器端通过 JS 生成 DOM。</p><p>SSR 的核心实现原理: SSR 的核心在于“同构（Isomorphic）”或“通用（Universal）”应用——即一套代码（通常是 React, Vue, Svelte 等）既能在服务器上运行，也能在客户端上运行。</p><p>核心实现流程如下：</p><ol><li><p>请求到达服务器</p></li><li><p>服务器端路由与数据获取</p></li></ol><ul><li>路由匹配: 服务器根据请求的 URL 匹配到对应的页面组件</li><li>数据预取: 服务器在渲染组件之前，会执行该页面组件定义的“服务器端数据获取函数”（例如 Next.js 中的 getServerSideProps）。它会去调用数据库或 API，获取 ID 为 123 的产品数据。</li></ul><ol start="3"><li>服务器端渲染（Render to String）</li></ol><ul><li>服务器使用框架提供的服务器端渲染 API（例如 React 的 ReactDOMServer.renderToString()）来“执行”组件。</li><li>由于在第 2 步已经获取了数据，组件会被填充完整的数据（产品名称、价格、描述等）。</li><li>这个执行过程的产物不是一个虚拟 DOM，而是一个完整的 HTML 字符串。</li></ul><ol start="4"><li>响应与首次渲染</li></ol><ul><li>服务器将这个完整的 HTML 字符串打包成一个 HTTP 响应，发送给浏览器。</li><li>浏览器接收到 HTML 后，立即解析并渲染。用户此时立刻就能看到页面的完整内容（这就是首屏加载极快的原因）。</li><li>注意：此时的页面只是“静态的”，没有任何交互（点击按钮没反应），因为它对应的 JavaScript 还没执行。</li></ul><ol start="5"><li>Hydration（注水/激活） <ul><li>在浏览器渲染 HTML 的同时，它会开始下载 CSR 模式下也需要的 JavaScript 包（例如 app.js）。</li><li>JS 下载并执行后，框架（如 React/Vue）会在客户端再次运行。</li><li>但它不会粗暴地重新渲染并替换所有 DOM，而是执行一个称为 <strong>&quot;Hydration&quot;（注水）</strong>的过程。</li><li>Hydration 会<strong>“接管”</strong>服务器渲染的静态 DOM，遍历虚拟 DOM 和真实 DOM，将事件监听器（如 onClick）附加到现有的 HTML 元素上。</li><li>这个过程完成后，页面就从“静态 HTML”变成了“可交互的单页应用（SPA）”。</li></ul></li></ol><p>核心流程图： <strong>用户请求 → 服务器路由 → 服务器获取数据 → 服务器渲染 (生成HTML字符串) → 浏览器接收HTML并立即显示 → (并行)浏览器下载JS → JS执行 (Hydration) → 页面完全可交互</strong></p><p>SSR 相比 CSR 的不可替代优势:</p><p>CSR 最大的问题是“白屏时间长”和“SEO 灾难”。SSR 正是为解决这两个核心痛点而生，在以下场景具有不可替代的优势：</p><ul><li>搜索引擎优化 (SEO)</li><li>极致的“首屏加载速度”（FCP）</li></ul><!--]--></div></div><h3 id="_5-微前端-import-html-entry-场景下-子应用中存在路由懒加载-dynamic-import-的情况-import-html-entry-会如何处理或者需要注意什么" tabindex="-1">5.微前端 / import-html-entry 场景下，子应用中存在路由懒加载（dynamic import）的情况，import-html-entry 会如何处理或者需要注意什么 <a class="header-anchor" href="#_5-微前端-import-html-entry-场景下-子应用中存在路由懒加载-dynamic-import-的情况-import-html-entry-会如何处理或者需要注意什么" aria-label="Permalink to “5.微前端 / import-html-entry 场景下，子应用中存在路由懒加载（dynamic import）的情况，import-html-entry 会如何处理或者需要注意什么”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><p>import-html-entry 默认只处理 index.html 中的静态 script 和 link，所以懒加载模块不会被提前 fetch 或 exec。懒加载模块会在子应用自己的 webpack runtime 中正常 fetch（通过 publicPath 拼接 URL），然后动态加载。</p><ul><li><p>懒加载的模块执行时会使用子应用的 runtime（webpackJsonp / webpackChunk），所以如果你在 import-html-entry 里用 sandbox proxy window，需要把 webpackJsonp / webpack_require 等 runtime 挂到 proxy 上，确保 chunk 加载执行正常。</p></li><li><p>qiankun 会在 execScripts 中注入 sandbox proxy，保证动态 import 能访问 webpack runtime。</p></li></ul><!--]--></div></div><h3 id="_6-css-in-js-的优缺点" tabindex="-1">6. CSS-in-JS 的优缺点 <a class="header-anchor" href="#_6-css-in-js-的优缺点" aria-label="Permalink to “6. CSS-in-JS  的优缺点”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><table tabindex="0"><thead><tr><th>优点</th><th>说明</th><th>实际收益</th></tr></thead><tbody><tr><td><strong>1️⃣ 样式作用域自动隔离</strong></td><td>每个组件的样式自动作用于自身，不会影响全局或其他组件</td><td>避免 CSS 命名冲突、全局污染</td></tr><tr><td><strong>2️⃣ 动态样式支持（基于状态）</strong></td><td>可以直接使用 JS 变量、props、state 动态控制样式</td><td>让样式与逻辑无缝联动（例如根据主题、交互状态变化）</td></tr><tr><td><strong>3️⃣ 真正的组件化开发体验</strong></td><td>样式与组件逻辑紧密绑定在一起（co-located）</td><td>提高可维护性与可读性，代码结构更清晰</td></tr><tr><td><strong>4️⃣ 消除了全局命名问题</strong></td><td>自动生成唯一 className（hash）</td><td>无需再手动设计命名规范（如 BEM / SMACSS）</td></tr><tr><td><strong>5️⃣ 支持服务端渲染（SSR）与关键路径 CSS 提取</strong></td><td>框架（如 styled-components）可在 SSR 阶段注入 CSS</td><td>提高首屏性能、避免闪烁（FOUC）</td></tr><tr><td><strong>6️⃣ 更好的主题系统支持</strong></td><td>内置 ThemeProvider 概念，可动态切换主题</td><td>适合暗黑模式、品牌主题等需求</td></tr><tr><td><strong>7️⃣ 死代码消除（Tree Shaking 友好）</strong></td><td>未使用组件的样式不会被打包</td><td>打包体积更小、更干净</td></tr><tr><td><strong>8️⃣ 类型安全（TypeScript 集成）</strong></td><td>样式属性有类型提示与检查</td><td>减少拼写错误与无效样式</td></tr><tr><td><strong>9️⃣ 样式动态计算能力</strong></td><td>可以编写逻辑，如条件判断、循环、计算值</td><td>复杂 UI 响应更灵活（如动态 grid、尺寸）</td></tr><tr><td><strong>🔟 无需独立 CSS 构建管线</strong></td><td>不依赖 CSS Loader / PostCSS</td><td>前端构建配置更轻量（尤其在 Vite 等环境）</td></tr></tbody></table><table tabindex="0"><thead><tr><th>缺点</th><th>说明</th></tr></thead><tbody><tr><td><strong>运行时开销</strong></td><td>一些库（如 styled-components）会在运行时动态生成样式，性能略低</td></tr><tr><td><strong>构建体积稍大</strong></td><td>比纯 CSS 稍重，需要额外 runtime</td></tr><tr><td><strong>调试难度</strong></td><td>虽然 devtools 支持不错，但不如传统 CSS 文件直观</td></tr><tr><td><strong>学习成本</strong></td><td>对初学者来说，需要理解 styled-components 或 Emotion API</td></tr></tbody></table><table tabindex="0"><thead><tr><th>场景</th><th>是否推荐使用 CSS-in-JS</th></tr></thead><tbody><tr><td>设计系统 / UI 库（需要主题支持）</td><td>✅ 强烈推荐</td></tr><tr><td>React / Vue 组件化项目</td><td>✅ 推荐</td></tr><tr><td>静态网站（CSS 变化少）</td><td>⚙️ 可选</td></tr><tr><td>大型老项目（已用 SASS/BEM）</td><td>⚠️ 慎重迁移，成本较高</td></tr></tbody></table><!--]--></div></div><h3 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to “其他”">​</a></h3><ul><li>webpack 打包速度分析, speed-measure-webpack-plugin, 打包大小分析: webpack-bundle-analyze</li><li>安装相同的但不同版本的组件库, 取别名 npm i alias@npm:name@^verison</li><li>灰度发布 <ul><li>灰度发布:新版本不是一次性发布给所有用户，而是只让部分用户先体验，逐步扩大范围，最后全量替换旧版本。</li></ul></li></ul><table tabindex="0"><thead><tr><th>对比项</th><th>灰度发布</th><th>蓝绿部署</th></tr></thead><tbody><tr><td>核心思想</td><td>逐步放量验证</td><td>一次性切换</td></tr><tr><td>流量分配</td><td>部分用户</td><td>全量流量</td></tr><tr><td>风险控制</td><td>可逐步调整比例</td><td>立即切换，风险更大</td></tr><tr><td>适用场景</td><td>新版本验证、A/B 测试</td><td>无缝升级部署</td></tr></tbody></table><table tabindex="0"><thead><tr><th>场景</th><th>技术方案</th><th>说明</th></tr></thead><tbody><tr><td>静态站点</td><td>多版本构建 + CDN 分流</td><td>通过 cookie/header 控制加载版本</td></tr><tr><td>微前端</td><td>子应用级灰度</td><td>不同用户加载不同子应用版本</td></tr><tr><td>React/Vue 单页</td><td>Feature Flag（功能开关）</td><td>动态控制哪些功能显示</td></tr><tr><td>配合后端</td><td>接口层灰度</td><td>后端返回版本信息或新接口数据</td></tr></tbody></table></div></div></main><footer class="VPDocFooter" data-v-d668f7cc data-v-1bcd8184><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link prev" href="/myKMS/knowledge/framework/vue.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>Previous page</span><span class="title" data-v-1bcd8184>vue</span><!--]--></a></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/myKMS/knowledge/framework/electron.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>Next page</span><span class="title" data-v-1bcd8184>electron</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"ai_index.md\":\"DQfW4HRO\",\"algorithm_index.md\":\"DaoRZT4R\",\"api-examples.md\":\"COM88OYJ\",\"book_vue_1.md\":\"TUX_Qmzn\",\"index.md\":\"DzlC3Yeh\",\"interview_2025.md\":\"DdCUXctU\",\"interview_code.md\":\"Cxzw4P1l\",\"interview_index.md\":\"CDEOFYJy\",\"knowledge_base_css.md\":\"DgxWnDQ3\",\"knowledge_base_js.md\":\"B4na8DhB\",\"knowledge_base_nodejs.md\":\"Ba217klP\",\"knowledge_browser_http.md\":\"CfaBAt2E\",\"knowledge_browser_index.md\":\"BndzSVVy\",\"knowledge_browser_websecurity.md\":\"BbNw5VFZ\",\"knowledge_framework_angular.md\":\"BiMBUvi8\",\"knowledge_framework_electron.md\":\"HGyoFMrJ\",\"knowledge_framework_react.md\":\"C3iIru5f\",\"knowledge_framework_vite.md\":\"DnVbzkeU\",\"knowledge_framework_vue.md\":\"CleAL8fb\",\"readme.md\":\"BuMoeJj1\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"个人知识库\",\"description\":\"个人知识库\",\"base\":\"/myKMS/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"Home\",\"link\":\"/\"},{\"text\":\"面试\",\"link\":\"/interview/code\"},{\"text\":\"框架\",\"link\":\"/knowledge/framework/react\"},{\"text\":\"浏览器\",\"link\":\"/knowledge/browser/http\"}],\"sidebar\":[{\"text\":\"基础知识\",\"items\":[{\"text\":\"js\",\"link\":\"/knowledge/base/js\"},{\"text\":\"node\",\"link\":\"/knowledge/base/nodejs\"},{\"text\":\"css\",\"link\":\"/knowledge/base/css\"}]},{\"text\":\"interview\",\"items\":[{\"text\":\"2025\",\"link\":\"/interview/2025\"},{\"text\":\"code\",\"link\":\"/interview/code\"},{\"text\":\"开放性问题\",\"link\":\"/interview/index\"}]},{\"text\":\"框架\",\"items\":[{\"text\":\"react\",\"link\":\"/knowledge/framework/react\"},{\"text\":\"vue\",\"link\":\"/knowledge/framework/vue\"},{\"text\":\"工程化\",\"link\":\"/knowledge/framework/vite\"},{\"text\":\"electron\",\"link\":\"/knowledge/framework/electron\"}]},{\"text\":\"浏览器\",\"items\":[{\"text\":\"browser\",\"link\":\"/knowledge/browser/index\"},{\"text\":\"http\",\"link\":\"/knowledge/browser/http\"},{\"text\":\"web安全\",\"link\":\"/knowledge/browser/webSecurity\"}]},{\"text\":\"读书笔记\",\"items\":[{\"text\":\"vue.js 设计与实践\",\"link\":\"/book/vue_1\"}]},{\"text\":\"算法\",\"items\":[{\"text\":\"总\",\"link\":\"/algorithm/index\"}]},{\"text\":\"AI\",\"items\":[{\"text\":\"ai\",\"link\":\"/ai/index\"}]}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/xingyuanlong/myKMS\"}],\"outline\":{\"level\":[2,3],\"label\":\"页面导航\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false,\"additionalConfig\":{}}");</script>
    
  </body>
</html>