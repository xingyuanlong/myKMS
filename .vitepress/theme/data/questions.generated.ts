// This file is auto-generated by scripts/generate-questions.js. Do not edit manually.
import type { Question } from './questionTypes'

export const questions: Question[] = [
  {
    "id": 1,
    "question": "AI Agent  是啥?",
    "answer": [
      "AI Agent（智能代理） 是一个能够 **感知环境、做决策、执行动作** 的系统。是能够感知环境、做决策并执行动作的智能系统，其复杂度从简单规则反应型到学习型智能体不等。",
      "AI Agent 的代码生成、辅助编程工具和提示工程 (Prompt Engineering) 工具",
      "AI Agent 是能够感知环境、基于目标和策略做决策并执行动作的智能系统，现代应用多结合 LLM，实现自动化任务、多步推理和上下文增强。"
    ],
    "reference": "/myKMS/ai/index#_1-ai-agent-是啥",
    "source": "/myKMS/ai/index"
  },
  {
    "id": 2,
    "question": "MCP 是啥",
    "answer": [
      "ai mcp 是啥: 传统的大语言模型通常只能访问其训练时的数据，无法获取实时信息或与外部系统交互。MCP 的引入，解决了这一限制，使 AI 助手能够： 访问实时数据：如数据库查询、网页抓取、API 调用等。 执行操作：如文件管理、任务调度、系统控制等。 增强上下文理解：通过标准化的协议，提供更丰富的上下文信息，提高回答的准确性和相关性。"
    ],
    "reference": "/myKMS/ai/index#_2-mcp-是啥",
    "source": "/myKMS/ai/index"
  },
  {
    "id": 3,
    "question": "ai mcp 与 agent 区别和相同是啥",
    "answer": [
      "| 对比维度 | **AI MCP（Model Context Protocol）** | **Agent（智能体）** | | ------------ | ---------------------------------------- | ------------------------------------------------- | | **核心定义** | 一种开放协议，用于让 AI 模型与外部工具、数据源、安全系统进行交互的标准化接口 | 一个具备感知、决策、行动能力的 AI 实体，能自主执行任务 | | **目标** | 让 AI 模型具备“安全、受控地访问外部能力”的标准化方式 | 模拟人类行为与决策，实现自动化任务执行 | | **本质定位** | 通信协议 / 桥梁层（模型与外部世界之间的 API 桥） | 智能执行体 / 上层应用（基于协议或框架实现行为） | | **是否具备决策逻辑** | ❌ 无（仅负责传递与规范化上下文与调用） | ✅ 有（根据上下文、记忆、目标做出决策） | | **是否依赖模型** | ✅ 是，为模型服务的协议层 | ✅ 是，通常内嵌或依赖大模型 | | **数据交互方式** | 定义好的接口和上下文传递机制（如：tools、files、memory等） | 主动感知 + 调用外部 API 或协议（可使用 MCP） | | **典型实现者** | OpenAI MCP、Anthropic MCP 等 | AutoGPT、LangChain Agent、OpenDevin、ChatGPT Agent 等 | | **可扩展性** | 高，通过定义新的 MCP 服务器或工具接口扩展模型能力 | 高，可通过插件、工具链、MCP 等方式增强行为 | | **安全控制** | 强，强调“模型可见范围”与“安全沙箱” | 弱到中等，取决于实现（可能越权或误操作） | | **运行层级** | 模型与外部系统之间的“中间层” | 应用层（运行在用户逻辑上层） | | **示例场景** | 模型通过 MCP 协议安全访问数据库、文件系统、内部 API | Agent 使用 MCP 工具自动检索文档、编写代码、执行命令 | | **关系总结** | 提供 Agent 可用的“统一外部接口标准” | 利用 MCP 作为工具访问协议来实现自主任务执行 |",
      "简单总结：",
      "MCP 是“协议层” → 定义模型如何安全访问世界。 Agent 是“智能层” → 定义模型如何使用这些能力执行任务。",
      "换句话说： MCP ≈ 插座标准， Agent ≈ 插在插座上运行的设备。"
    ],
    "reference": "/myKMS/ai/index#_3-ai-mcp-与-agent-区别和相同是啥",
    "source": "/myKMS/ai/index"
  },
  {
    "id": 4,
    "question": "Prompt 工程",
    "answer": [
      "Prompt 工程就是精心设计、优化和管理输入给大语言模型的提示，以最大化输出质量和准确性的技术。 Prompt 工程 = 设计和优化输入给 LLM 的提示（Prompt）以获得最准确、最有效输出的技术和方法 Prompt 工程的目标是 **用最小代价让模型输出最期望的结果。**"
    ],
    "reference": "/myKMS/ai/index#_4-prompt-工程",
    "source": "/myKMS/ai/index"
  },
  {
    "id": 5,
    "question": "AI Coding 的个人最佳实践",
    "answer": [
      "选助手: chatgpt codex 和 github copilot 高质量提示词（Prompt）模板 把“上下文先行 + 验收先行”写死在提示里，减少反复。 定身份 + 限制 质量护栏（个人级“红线”） 一次只改一件事：让 AI 聚焦在 1–3 个文件，减少回滚成本。 看 diff 不看 demo：合并前逐行审阅关键点：状态共享、边界条件、异常路径、内存/性能热路径。 强制四件套：代码 + 测试 + 示例 + 说明，缺一不收。 调试与修复闭环 仓库最小“AI 上下文包” Chat/对话里加一句：规范见 /ai_context/STYLE.md, TECH_STACK.md, DO_NOTS.md，必须遵守 在仓库根放 /ai_context/ STYLE.md（命名/目录/commit 规范） TECH_STACK.md（框架版本、状态管理、UI/HTTP/路由选型） API_SPEC.md（关键接口契约与错误码） DO_NOTS.md（黑名单：禁用 API/反模式/易踩坑） 之后提示词直接引用这些文档，减少来回解释。",
      "把 AI 当“代码生成器 + 搜索引擎 + 重构器” 界定 → 生成 → 验证 → 固化"
    ],
    "reference": "/myKMS/ai/index#_5-ai-coding-的个人最佳实践",
    "source": "/myKMS/ai/index"
  },
  {
    "id": 6,
    "question": "对于 AI IDE 中 Agent 的理解",
    "answer": [
      "**AI IDE 中 Agent 它不只是聊天补全，而是能读—想—改—验的一套自动化执行体。**",
      "定义:**一个具备工具调用能力、可多轮执行的自动化体（planner + executor），在 IDE 里对代码仓库做计划→生成→编辑→验证→提交的闭环。** 本质差异（vs. 普通 Chat/补全） Chat：只给建议，改不动仓库；上下文短。 补全：跟光标走，单文件/局部。 Agent：可跨文件/多步骤，调用代码搜索、测试、构建、git、包管理、格式化/静态检查等工具，并返回可审阅的 patch。",
      "AI IDE 中的 Agent = 具备工具调用与多轮自校验的“自动化协作者”。它的价值不在“能写多少代码”，而在把规则化的、可验证的仓库级改动交给机器完成；你的工作是设置清晰边界与硬性的质量闸门，让它安全高效地跑完“计划→编辑→验证→提交”的闭环。"
    ],
    "reference": "/myKMS/ai/index#_6-对于-ai-ide-中-agent-的理解",
    "source": "/myKMS/ai/index"
  },
  {
    "id": 7,
    "question": "对于 AI IDE 中 MCP 的理解",
    "answer": [
      "它是把 IDE/Agent 和外部工具、数据源“标准化接驳”的一套开放协议——更像给 AI 装了一个 “USB-C 接口”：一处实现，处处连用。",
      "mcp:",
      "定义：由 Anthropic 发起的开源协议，用来把 AI 应用/代理（Agent）与“工具 + 数据 + 工作流”做双向、安全、可发现的连接。一次实现协议，便可复用整套生态的集成。",
      "生态位置：面向 IDE/桌面助手/云端代理等“客户端”（Client），以及暴露工具/数据能力的“服务器”（Server）。客户端发现可用工具，调用并拿回结构化结果。",
      "MCP = 给 AI IDE/Agent 的通用“工具与数据总线”。它把“发现—调用—返回”的语义标准化，让 Agent 能在 IDE 里安全、可复用地连接到文件系统、构建/测试、企业 API 等能力，进而把“计划→编辑→验证→提交”的工程闭环跑起来。"
    ],
    "reference": "/myKMS/ai/index#_7-对于-ai-ide-中-mcp-的理解",
    "source": "/myKMS/ai/index"
  },
  {
    "id": 8,
    "question": "AI IDE 中 Tab 补全模型及其原理",
    "answer": [
      "**是一条从上下文收集 → 语言模型推断 → 候选生成与重排 → 约束与安全 → 呈现与学习的工程流水线**",
      "```swift\n键入 → 触发条件命中\n   → 上下文构建（prefix+suffix+符号/RAG+工程规则）\n     → 模型解码（FIM/自回归，KV cache，限长/停用符）\n       → 生成多候选（不同温度/窗口）\n         → 重排（可编性/风格/相似度/历史采纳）\n           → 约束&安全过滤（语法/lint/secret）\n             → 呈现（渐进式，短→长）\n               → 反馈学习（接受/编辑/拒绝→排序器/提示适配）\n\n```"
    ],
    "reference": "/myKMS/ai/index#_8-ai-ide-中-tab-补全模型及其原理",
    "source": "/myKMS/ai/index"
  },
  {
    "id": 9,
    "question": "排序算法",
    "answer": [
      "排序算法分类:",
      "| 分类 | 特点 | 示例 | | ---------- | ---------------- | ------------------ | | **比较类排序** | 通过比较元素大小确定顺序 | 冒泡、选择、插入、归并、快速、堆排序 | | **非比较类排序** | 不通过比较，而是利用桶或计数思想 | 计数排序、桶排序、基数排序 |",
      "常见排序算法:",
      "冒泡排序: 相邻元素两两比较，较大的向后“冒泡”",
      "```\n\nfunction bubbleSort(arr) {\n  for (let i = 0; i < arr.length - 1; i++) {\n    for (let j = 0; j < arr.length - 1 - i; j++) {\n      if (arr[j] > arr[j + 1]) {\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n      }\n    }\n  }\n  return arr;\n}\n\n```",
      "时间复杂度：O(n²)",
      "空间复杂度：O(1)",
      "稳定：✅",
      "选择排序: 每轮选择最小（或最大）值放到前面",
      "```\nfunction selectionSort(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    let min = i;\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[j] < arr[min]) min = j;\n    }\n    [arr[i], arr[min]] = [arr[min], arr[i]];\n  }\n  return arr;\n}\n\n```",
      "时间复杂度：O(n²)",
      "空间复杂度：O(1)",
      "稳定：❌（因为交换可能打乱相等元素顺序）",
      "插入排序: 将未排序的元素插入到已排序部分的合适位置",
      "```\nfunction insertionSort(arr) {\n  for (let i = 1; i < arr.length; i++) {\n    let key = arr[i];\n    let j = i - 1;\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j--;\n    }\n    arr[j + 1] = key;\n  }\n  return arr;\n}\n\n\n```",
      "时间复杂度：O(n²)，但几乎有序时效率极高",
      "空间复杂度：O(1)",
      "稳定：✅",
      "快速排序: 分治思想，选一个“基准”pivot，小的放左，大的放右，然后递归。",
      "```\nfunction quickSort(arr) {\n  if (arr.length <= 1) return arr;\n  const pivot = arr[arr.length >> 1];\n  const left = arr.filter(x => x < pivot);\n  const mid = arr.filter(x => x === pivot);\n  const right = arr.filter(x => x > pivot);\n  return [...quickSort(left), ...mid, ...quickSort(right)];\n}\n\n```",
      "平均复杂度：O(n log n)",
      "最坏复杂度：O(n²)（当数组几乎有序时）",
      "稳定：❌",
      "归并排序: 分治思想，将数组不断二分排序后再合并",
      "```\n\nfunction mergeSort(arr) {\n  if (arr.length <= 1) return arr;\n  const mid = Math.floor(arr.length / 2);\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.slice(mid));\n  return merge(left, right);\n}\n\nfunction merge(left, right) {\n  const res = [];\n  while (left.length && right.length) {\n    res.push(left[0] <= right[0] ? left.shift() : right.shift());\n  }\n  return [...res, ...left, ...right];\n}\n\n\n```",
      "时间复杂度：O(n log n)",
      "空间复杂度：O(n)",
      "稳定：✅",
      "计数排序: 非比较类排序，统计每个元素出现次数",
      "```\nfunction countingSort(arr, maxValue) {\n  const count = new Array(maxValue + 1).fill(0);\n  arr.forEach(v => count[v]++);\n  const res = [];\n  count.forEach((v, i) => { while (v--) res.push(i); });\n  return res;\n}\n\n```",
      "时间复杂度：O(n + k)",
      "空间复杂度：O(k)",
      "稳定：✅",
      "缺点：仅适合整数或离散值范围小的场景",
      "| 场景 | 推荐算法 | 理由 | | ----------- | --------- | -------- | | 少量数据（<1000） | 插入 / 冒泡 | 简单实现 | | 一般排序（常规数组） | 快速排序 | 平均性能最好 | | 大量数据、稳定性要求 | 归并排序 | 稳定且复杂度稳定 | | 数据范围有限、整数 | 计数 / 基数排序 | 非比较类性能高 | | 实时排序、流式数据 | 插入排序 | 动态插入效率高 |"
    ],
    "reference": "/myKMS/algorithm/index#_2-排序算法",
    "source": "/myKMS/algorithm/index"
  },
  {
    "id": 10,
    "question": "洗牌算法",
    "answer": [
      "```\nfunction shuffle(array) {\n  let arr = array.slice(); // 拷贝一份，不修改原数组\n  for (let i = arr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1)); // 随机索引 [0, i]\n    [arr[i], arr[j]] = [arr[j], arr[i]]; // 交换\n  }\n  return arr;\n}\n\n```"
    ],
    "reference": "/myKMS/algorithm/index#_3-洗牌算法",
    "source": "/myKMS/algorithm/index"
  },
  {
    "id": 11,
    "question": "字符串出现的不重复最长长度",
    "answer": [
      "我们可以用 双指针（left、right）+ 哈希表（Set 或 Map） 实现：",
      "用一个窗口 [left, right) 表示当前不重复子串；",
      "向右移动 right 扩大窗口；",
      "若遇到重复字符，则移动 left 收缩窗口；",
      "过程中记录窗口最大长度。",
      "```js\nfunction lengthOfLongestSubstring(s) {\n  let set = new Set();\n  let left = 0, maxLen = 0;\n\n  for (let right = 0; right < s.length; right++) {\n    while (set.has(s[right])) {\n      set.delete(s[left]);\n      left++;\n    }\n    set.add(s[right]);\n    maxLen = Math.max(maxLen, right - left + 1);\n  }\n\n  return maxLen;\n}\n\n```"
    ],
    "reference": "/myKMS/algorithm/index#_4-字符串出现的不重复最长长度",
    "source": "/myKMS/algorithm/index"
  },
  {
    "id": 12,
    "question": "react vue 有什么区别和相似",
    "answer": [
      "对比:",
      "vue 编译+运行时框架, react 运行时, 所以vue 再编译时能够做很多优化(如静态标记和动态提升), react 更注重运行时, react 19 也有 React Compiler 编译优化. (svelte 纯编译 )",
      "React：UI 库（Library），专注于 视图层，其它路由/状态管理等靠社区生态（React Router、Redux）。 Vue：渐进式框架（Framework），提供了从视图到路由、状态管理（Vue Router、Pinia/Vuex）的完整解决方案。",
      "语法与编程范式: React：以 JavaScript/TypeScript 为核心，用 JSX 描述 UI。 更偏向函数式编程，鼓励用 Hooks 管理状态、副作用。 Vue：提供 单文件组件 (SFC)，分为 `<template> + <script> + <style>`。 更接近声明式和模板式编程，容易上手",
      "数据绑定 React：单向数据流，props → 子组件，更新需要 setState 或 useState。 Vue：双向数据绑定 (v-model)，适合表单场景，逻辑简洁。",
      "性能优化 React：依靠 shouldComponentUpdate / React.memo / useMemo / useCallback。 Vue：通过 响应式系统（Proxy + Effect 追踪依赖），自动追踪更新；还可以用 v-once、computed 优化",
      "状态管理 React：依赖外部库（Redux、MobX、Zustand、Recoil 等），灵活但碎片化。 Vue：官方提供 Vuex（Vue2）/ Pinia（Vue3），统一、集成度高",
      "底层区别:",
      "1.核心思想",
      "React 1. 核心是函数式 + 状态驱动 UI：UI = f(state)。 2. 关注数据不可变和纯函数更新。 3. React 本身是渲染库，路由/状态管理等能力由社区提供。 Vue 1. 核心是响应式系统 + 模板编译：通过响应式追踪 + 渲染函数驱动更新。 2. 偏向声明式与命令式相结合，易上手。 3. Vue 是一个完整的框架，提供更多开箱即用的能力。",
      "2. 响应式机制 React: 没有内置响应式，靠 useState/useReducer 触发组件更新。每次 setState 会触发组件重新渲染，然后通过虚拟 DOM diff 决定哪些节点需要更新。数据变化 → 全量渲染 → Diff → 最小化 DOM 更新。 Vue: Vue 2 使用 Object.defineProperty，Vue 3 使用 Proxy；通过精确的依赖追踪，只有用到字段的组件或计算属性会订阅该字段。数据变化 → 精确找到依赖它的组件/模板 → 只更新必要部分。",
      "3. 虚拟 DOM & 渲染 React: 使用 Fiber 架构（从 v16 开始）。每个组件对应一个 Fiber 节点，支持异步可中断渲染（time slicing、并发模式），强调调度与优先级，确保 UI 流畅。 Vue: Vue 3 借助编译期优化和 Block Tree（静态提升 + 动态节点追踪）。模板在编译时划分为“静态节点 + 动态节点”，更新时只 diff 动态部分。Vue 3.6 引入的 Vapor Mode 甚至尝试跳过虚拟 DOM，生成更精确的更新代码。",
      "4. 调度机制 React：有完整的 Scheduler，支持优先级队列（用户交互优先、网络渲染延后）和并发渲染（Concurrent Mode）。 Vue：内置异步队列 + nextTick，保证数据更新合并（批量刷新），调度相对简单，不区分复杂优先级。",
      "5. 渲染层抽象 React: ReactDOM 是一个渲染器，底层渲染器可替换（React Native、Ink、three-fiber），通过 Reconciler + Renderer 解耦。 Vue: Vue 3 同样有 Renderer 抽象（runtime-core + runtime-dom），官方维护 DOM 渲染器及其它平台的渲染器，但 React 在多端渲染生态上更成熟。",
      "6. 生态设计 React：小核 + 强社区，灵活且可扩展（例如 React Native、Next.js、Remix 等）。 Vue：整体框架理念，内置响应式和编译器，适合小团队和中台项目，使用体验更统一。",
      "相似性",
      "都是 UI 层框架，专注视图 都基于 数据驱动视图 都通过 虚拟 DOM 进行高效 DOM 更新 都是 组件化开发，支持递归组合 父 → 子（props）单向数据流 保证数据可预测性 都有 生命周期钩子 都支持 SSR / SSG / CSR 混合渲染 都在追求 更细粒度更新和并发渲染 都支持跨平台渲染"
    ],
    "reference": "/myKMS/interview/2025#_1-react-vue-有什么区别和相似",
    "source": "/myKMS/interview/2025"
  },
  {
    "id": 13,
    "question": "qiankun",
    "answer": [
      "js 隔离: 1.SnapshotSandbox（快照沙箱）: 在应用切换前，把 window 的状态做一份快照。子应用运行时，修改的全局变量只保存在自己的快照里。卸载子应用时，还原 window。缺点：只能同时激活一个子应用（适合单实例场景）。",
      "2.ProxySandbox（代理沙箱） 基于 ES6 Proxy 拦截子应用对全局对象的读写。每个子应用有一个独立的代理对象作为 window，实际访问 window.xxx 时，会优先读写子应用自己的代理上下文。多个子应用可并行运行，互不影响。",
      "qiankun 默认在支持 Proxy 的浏览器下使用这个方案",
      "```\nconst fakeWindow = {};\nconst proxy = new Proxy(window, {\n        get(target, key) {\n        return key in fakeWindow ? fakeWindow[key] : target[key];\n},\nset(target, key, value) {\n        fakeWindow[key] = value;\n        return true;\n      }\n});\n```",
      "样式隔离:",
      "1. 严格样式隔离: Shadow DOM 兼容性不好 2. 实验性样式隔离（样式前缀）:通过 ScopedCSS 插件，在运行时动态给子应用 CSS 加上前缀（比如 [data-qiankun=\"xxx\"]）。确保样式只影响当前子应用的 DOM。原理类似 Vue 的 scoped 样式，但是在运行时做。 3. css BEM, PostCSS 插件"
    ],
    "reference": "/myKMS/interview/2025#_2-qiankun",
    "source": "/myKMS/interview/2025"
  },
  {
    "id": 14,
    "question": "vite 插件",
    "answer": [
      "```\nimport type { Plugin } from 'vite';\n\nfunction myPlugin(options?): Plugin {\n  return {\n    name: 'my-plugin',  // **必须**有 name，方便调试\n    // enforce: 'pre' 或 'post'（可选），指定此插件执行顺序\n    config(config, { command }) {\n      // 修改 Vite / Rollup 配置（可选）\n    },\n    configResolved(resolvedConfig) {\n      // 当最终 config 确定后执行\n    },\n    resolveId(source, importer) {\n      // 自定义模块解析逻辑\n    },\n    load(id) {\n      // 如果你要“自己加载一个模块”，返回内容\n      // 否则返回 null 让后续钩子 /默认流程处理\n    },\n    transform(code, id) {\n      // 转换模块源代码，返回 { code, map } 或 string\n    },\n    handleHotUpdate(ctx) {\n      // 在开发服务下，处理 HMR 热更新逻辑\n    },\n    // 构建阶段钩子\n    buildStart() { },\n    generateBundle(options, bundle, isWrite) { },\n    writeBundle() { },\n    closeBundle() { },\n  };\n}\n```",
      "// 替换模板的一个字",
      "```\nexport default function replaceTextPlugin(options = { search: 'FOO', replace: 'BAR' }) {\n  return {\n    name: 'vite-plugin-replace-text',\n    enforce: 'pre',\n    transform(code, id) {\n      if (/\\.(js|ts|jsx|tsx)$/.test(id)) {\n        return code.replace(new RegExp(options.search, 'g'), options.replace);\n      }\n      return null;\n    }\n  };\n}\n```",
      "// 统计TODO",
      "```\nimport fs from 'fs';\nimport path from 'path';\n\nexport function vitePluginTodo() {\n  const todos = [];\n\n  function scanFile(filePath) {\n    const code = fs.readFileSync(filePath, 'utf-8');\n    const lines = code.split('\\n');\n\n    lines.forEach((line, index) => {\n      const todoMatch = line.match(/\\/\\/\\s*TODO\\s*:(.*)/i) \n                     || line.match(/\\/\\*\\s*TODO\\s*:(.*)\\*\\//i);\n\n      if (todoMatch) {\n        todos.push({\n          file: path.relative(process.cwd(), filePath),\n          line: index + 1,\n          content: todoMatch[1].trim(),\n        });\n      }\n    });\n  }\n\n  function scanDir(dir) {\n    const entries = fs.readdirSync(dir, { withFileTypes: true });\n    for (const entry of entries) {\n      const fullPath = path.join(dir, entry.name);\n\n      if (entry.isDirectory()) {\n        if (entry.name === 'node_modules' || entry.name.startsWith('.')) continue;\n        scanDir(fullPath);\n      } else if (/\\.(ts|js|tsx|jsx|vue)$/.test(entry.name)) {\n        scanFile(fullPath);\n      }\n    }\n  }\n\n  console.log('vite-plugin-todo');\n  return {\n    name: 'vite-plugin-todo',\n    apply: 'build',\n    buildStart() {\n      console.log('vite-plugin-todo buildStart');\n      todos.length = 0;\n      scanDir(process.cwd());\n    },\n    closeBundle() {\n      if (todos.length > 0) {\n        console.log('\\n💡 TODO List:');\n        todos.forEach(todo => {\n          console.log(`${todo.file}:${todo.line} - ${todo.content}`);\n        });\n      } else {\n        console.log('\\n✅ No TODO found.');\n      }\n    }\n  };\n}\n\n```"
    ],
    "reference": "/myKMS/interview/2025#_4-vite-插件",
    "source": "/myKMS/interview/2025"
  },
  {
    "id": 15,
    "question": "webpack 和 vite 的区别",
    "answer": [
      "1. Webpack：老牌的 打包器，把所有依赖打包成一个或多个 bundle。 2. Vite：新一代 前端构建工具，开发环境利用浏览器的 原生 ES 模块 (ESM)，生产环境用 Rollup 打包。",
      "1.开发模式 Webpack： 启动时必须 先打包整个项目，再启动 dev server。 启动速度和项目体积成正比。 Vite： 启动时 不打包业务代码，依赖用 esbuild 预构建，源码按需编译。 启动速度几乎和项目体积无关，大型项目也能秒开。",
      "👉 一句话：Webpack = 打包后再跑，Vite = 边跑边编译。",
      "2. 热更新（HMR） webpack：基于打包产物 diff，大型项目热更新会卡顿。 Vite：直接基于 ESM 精确替换模块，更新速度更快。",
      "3. 生产构建 Webpack：开发和生产都用自家打包逻辑。 Vite：开发用 esbuild + ESM，生产用 Rollup 打包（Tree-shaking 更强，但生态不如 Webpack 丰富）。",
      "4. 配置与生态 Webpack：配置复杂但灵活。loader + plugin 生态极其成熟。 Vite：开箱即用，配置简单。插件体系基于 Rollup，生态在快速增长。",
      "Webpack 是基于打包的老牌全能工具，功能强大但启动和热更新慢；Vite 利用 ESM 和 esbuild，开发体验好、速度快，生产打包用 Rollup。"
    ],
    "reference": "/myKMS/interview/2025#_5-webpack-和-vite-的区别",
    "source": "/myKMS/interview/2025"
  },
  {
    "id": 16,
    "question": "React Fiber 架构",
    "answer": [
      "Fiber 是 React 对 虚拟 DOM 渲染机制的重写，它的核心目标是：**支持可中断的渲染和任务优先级调度**，从而改善大型应用的渲染性能和用户体验。简单理解就是：把更新任务拆成可中断的小单元，按优先级调度执行。",
      "Fiber 的数据结构: Fiber 是一个链表/树形结构，每个 Fiber 节点对应一个 React 元素或组件。",
      "双阶段渲染（两阶段 Reconciliation）:Fiber 实现了 可中断渲染，把渲染分为两个阶段：",
      "Render 阶段（Reconciliation, 构建 Fiber 树，比较新旧 Fiber 树，生成 effect list（要更新的副作用列表）。可以中断、按优先级切分任务。不直接修改 DOM。 Commit 阶段:遍历 effect list，将副作用应用到真实 DOM。是同步执行的，一旦开始就不能中断。包括挂载、更新、删除 DOM.",
      "调度与优先级:Fiber 内置 任务调度器，任务分为不同优先级：同步任务（高优先级，如点击事件);动画任务异步任务（低优先级，如网络请求完成后的渲染）通过分片（time slicing）和 requestIdleCallback / messChannel / setTimeout，保证 UI 不被阻塞",
      "Fiber 为什么要出现？ 为了解决 React 15 的同步渲染阻塞问题，支持可中断渲染和任务优先级。",
      "Fiber 树 vs 虚拟 DOM 树区别？",
      "虚拟 DOM 树只表示 UI 元素结构。 Fiber 树表示元素 + 组件 + 更新状态 + 优先级 + 副作用列表，更复杂。",
      "Render 阶段和 Commit 阶段有什么区别？ Render 阶段：可中断、生成 effect list，不触碰 DOM。 Commit 阶段：同步执行、应用 effect，修改真实 DOM"
    ],
    "reference": "/myKMS/interview/2025#_6-react-fiber-架构",
    "source": "/myKMS/interview/2025"
  },
  {
    "id": 17,
    "question": "单点登录",
    "answer": [
      "用户在一个系统上登录后，就能无感知地访问其他关联系统，无需再次登录。",
      "统一身份认证中心（Identity Provider, IdP） 用户只在认证中心登录一次。 认证中心负责验证用户名/密码、签发令牌（如 JWT、SAML、OAuth2 Token）。",
      "业务系统（Service Provider, SP） 用户访问业务系统时，业务系统会跳转到认证中心校验。 认证成功后，认证中心返回一个「登录凭证」（Token / Ticket）。 业务系统验证凭证后，允许用户访问。",
      "Cookie + Session（早期） 依赖共享 Cookie（要求同域或二级域名一致）。 局限性大，不适合跨域。",
      "Token（JWT / OAuth2 / OpenID Connect）（主流） 用户认证成功后，认证中心签发 Token。 各系统通过 Token 识别用户，支持跨域、跨平台。"
    ],
    "reference": "/myKMS/interview/2025#_7-单点登录",
    "source": "/myKMS/interview/2025"
  },
  {
    "id": 18,
    "question": "状态管理redux mobx pinna 设计模式是啥？区别是啥",
    "answer": [
      "| 维度 | Redux | MobX | Pinia | | ----------- | ------------------- | ---------------------------- | --------------------------- | | 状态更新方式 | 不可变 + reducer | 可变 + observable | 可变 + reactive | | 阅读 /可预测性 | 高（统一入口） | 较低（更新处散落） | 较中等 /接近 Vue 响应式方式 | | 异步 /副作用管理 | 通过中间件（thunk / saga） | action / reaction / autorun | 普通 action + 插件 /订阅 | | 模块化 | 使用 reducer 组合拆分 | 多 store / classes | 天生模块 store | | 学习成本 | 较高 | 较低 | 中等（依赖 Vue 响应式理解） | | 调试工具 / 时间旅行 | 强支持（Redux DevTools） | 有 MobX DevTools、reaction 日志等 | Pinia Devtools /插件支持 | | 适合场景 | 大型复杂状态，团队协作 | 快速开发、响应性重 UI | Vue 应用 / Composition API 生态 |",
      "| 库 | 核心模式 | 特点 | | ------ | ---------------------------------- | ------------------------------------ | | Redux | 发布-订阅 + 单例模式 + 函数式编程 | 可预测、严格、样板代码多 | | MobX | 观察者模式 + 响应式 + 面向对象(OOP) | 简洁直观、自动追踪依赖、灵活 | | Pinia | 观察者模式 + 依赖注入 + 组合模式 | 结合 Vue3 响应式系统，轻量优雅 |",
      "观察者模式 与 发布-订阅模式（格式化）",
      "| 模式 | 是否有中介 | 耦合度 | 典型场景 | | ------------------ | ---------- | -------- | ---------------------------- | | 观察者模式 (Observer) | ❌ 没有中介 | 相对紧耦合 | UI 响应数据变化（如 Vue2） | | 发布-订阅模式 (Pub/Sub) | ✅ 有中介 | 松耦合 | 事件总线、跨模块通信、消息队列 |",
      "概念要点：",
      "观察者模式（Observer） 结构：有一个目标对象（Subject），维护观察者列表；状态变化时主动通知所有观察者。 特点：点对点通知，被观察者需要知道其观察者；适合一对多、紧密协作场景。",
      "发布-订阅模式（Publish‑Subscribe） 结构：引入消息中间件/事件中心，发布者发布事件到中间件，订阅者从中间件订阅事件。 特点：发布者与订阅者解耦，扩展性强，适合多对多和跨模块通信。",
      "对比总结：",
      "耦合：Observer 更紧耦合（Subject 知道 observers）；Pub/Sub 更松耦合（通过中介解耦）。 可扩展性：Pub/Sub 更易扩展和复用；Observer 更简单、直接，适合 UI 内部数据驱动场景。",
      "观察者模式（简要结构示例） Subject: 维护 observers 列表，提供 register / unregister / notify 方法。 Observer: 实现 update 接口，接收通知并更新自身。",
      "发布-订阅模式（简要结构示例） EventBus（中介）: on / off / emit。 发布者: emit(event, payload)。 订阅者: on(event, handler)。"
    ],
    "reference": "/myKMS/interview/2025#_8-状态管理redux-mobx-pinna-设计模式是啥-区别是啥",
    "source": "/myKMS/interview/2025"
  },
  {
    "id": 19,
    "question": "如果一个项目 使用了antd 组件库, 又使用了antd 2次开发组件库 会不会有问题",
    "answer": [
      "1. 样式冲突, 可以通过修改命名前缀区分 2. ConfigProvider 全局化配置也可能会冲突"
    ],
    "reference": "/myKMS/interview/2025#_9-如果一个项目-使用了antd-组件库-又使用了antd-2次开发组件库-会不会有问题",
    "source": "/myKMS/interview/2025"
  },
  {
    "id": 20,
    "question": "页面卡顿，内存泄露排查",
    "answer": [
      "| 现象 | 原因可能性 | | -------------------- | ------------------------------------------- | | 页面卡顿 / 帧率低 /响应迟钝 | JS 执行时间过长、频繁重绘/重排、布局触发、事件处理阻塞、定时器或循环、垃圾回收暂停 | | 内存持续上涨不降 /长时间运行后越来越慢 | 内存泄漏：一些对象、DOM、回调、事件监听器、定时器等未被释放仍被引用 |",
      "| 阶段 | 目标 | 使用工具 | 主要操作 | 关键观察点 | 可能问题 /风险 | | ------------- | ------------ | ------------------------------------------ | -------------------------------- | ------------------------------------- | ----------------- | | **1️⃣ 确认问题** | 复现卡顿或内存异常的场景 | 浏览器、用户日志、监控平台 | 收集用户反馈、复现路径、操作步骤 | 卡顿是否规律出现 / 内存是否持续上涨 | 确认是性能问题而非业务阻塞 | | **2️⃣ 初步检测** | 判断是卡顿还是内存泄漏 | Chrome DevTools → **Performance Monitor** | 观察 FPS、CPU、JS Heap、DOM Node 数量变化 | Heap、Node 数持续上升 | 存在潜在泄漏或渲染过频 | | **3️⃣ 拍快照分析** | 捕获堆内对象状态 | DevTools → **Memory → Heap Snapshot** | 操作前 / 操作后各拍一份快照 | Retained Size / Detached DOM Trees | 未被释放的 DOM / 对象被引用 | | **4️⃣ 对比快照** | 找出泄漏源头 | Memory → **Comparison 视图** | 比较两份快照差异 | 哪些对象 / 节点数量持续增加 | 确认泄漏对象及增长趋势 | | **5️⃣ 引用链分析** | 找出被谁持有 | Memory → **Retainers / Object References** | 追踪泄漏对象的引用路径 | 闭包、全局变量、事件监听、定时器 | 典型 JS 引用未释放 | | **6️⃣ 修复验证** | 移除引用 / 优化逻辑 | 代码修改 + 重测 | 清理事件、取消定时器、销毁监听、优化响应式 | 重新运行监控，确认 Heap 稳定 | 内存回收正常、卡顿消失 | | **7️⃣ 性能优化** | 防止再次发生 | Performance 面板 + Lighthouse | 分析长任务（>50ms）和渲染瓶颈 | Recalculate Style / Layout / Paint 频率 | 渲染层优化、减少阻塞 JS | | **8️⃣ 持续监控** | 监控上线表现 | 性能监控 SDK（如 Sentry、WebVitals） | 采集 FPS / Heap / 页面耗时数据 | 长时间运行后趋势 | 提前发现潜在泄漏 |"
    ],
    "reference": "/myKMS/interview/2025#_10-页面卡顿-内存泄露排查",
    "source": "/myKMS/interview/2025"
  },
  {
    "id": 21,
    "question": "定位白屏的常见原因",
    "answer": [
      "1.JavaScript 错误导致渲染中断 症状：控制台报错，页面无法正常渲染。 也可能接口返回异常数据或前端未兼容数据 2.关键资源加载失败 症状：页面依赖的 CSS、JS、图片等资源未加载，导致页面样式或功能缺失。 3.页面渲染逻辑异常 症状：页面结构正常，但内容未渲染。 排查方法： 检查 JavaScript 渲染逻辑，确认数据是否正确传递和处理。 使用断点调试，逐步执行代码，查看变量值和执行流程。 4.浏览器兼容性问题 症状：特定浏览器或版本下页面白屏。 排查方法： 使用 Can I Use 等工具，检查所用特性在目标浏览器中的支持情况。 添加适当的 Polyfill，确保功能在旧版浏览器中可用",
      "5. 网络环境或权限问题 症状：在特定网络环境下（如公司内网）页面白屏。 排查方法： 检查 Content Security Policy（CSP）设置，确保没有阻止资源加载。 确认没有被防火墙或安全软件拦截",
      "6.白屏检测方案 方案一：检测根节点是否渲染：通过检查根节点是否有内容，判断页面是否白屏。 方案二：Mutation Observer 监听 DOM 变化：监听页面 DOM 变化，判断页面是否渲染。 方案三：页面截图检测：对比页面截图与纯白图片，判断页面是否白屏。 方案四：采样对比：在页面中采样多个点，判断是否有元素渲染。",
      "步骤： 1.生成随机坐标点：在页面的宽度和高度范围内生成多个随机坐标点。 2.检查坐标点处的元素：使用 document.elementFromPoint(x, y) 方法获取指定坐标点处的最上层元素。 3.判断元素是否可见：检查获取到的元素是否存在且可见。",
      "```\nfunction isElementRendered(sampleCount = 10) {\n    let visibleCount = 0;\n    for (let i = 0; i < sampleCount; i++) {\n        const x = Math.random() * window.innerWidth;\n        const y = Math.random() * window.innerHeight;\n        const element = document.elementFromPoint(x, y);\n\n        if (element && element.offsetParent !== null) {\n            visibleCount++;\n        }\n    }\n\n    return visibleCount / sampleCount > 0.5; // 如果超过一半的采样点有可见元素，认为页面已渲染\n}\n```"
    ],
    "reference": "/myKMS/interview/2025#_11-定位白屏的常见原因",
    "source": "/myKMS/interview/2025"
  },
  {
    "id": 22,
    "question": "浏览器事件循环，网络请求是宏任务吗？",
    "answer": [
      "是的，浏览器中的网络请求（如使用 fetch 或 XMLHttpRequest）属于宏任务（macrotask）。",
      "调用栈（Call Stack）：执行同步代码。 宏任务队列（Macrotask Queue）：存放宏任务的回调函数，例如 setTimeout、setInterval、DOM 事件、网络请求, UI 渲染等。 微任务队列（Microtask Queue）：存放微任务的回调函数，例如 Promise.then、MutationObserver 等。",
      "事件循环的执行顺序如下： 执行调用栈中的同步代码。 执行微任务队列中的所有任务，直到队列为空。 更新渲染（如果需要）。 从宏任务队列中取出一个任务执行。 重复上述步骤",
      "宏任务 → 微任务 → ✅ 渲染 → 下一个宏任务",
      "```\n┌────────────────────────────┐\n│       1. 取一个宏任务       │ (如 script, I/O, setTimeout 回调)\n├────────────────────────────┤\n│       2. 执行所有微任务     │ (Promise.then, MutationObserver)\n├────────────────────────────┤\n│       3. 执行渲染前钩子     │ (requestAnimationFrame)\n├────────────────────────────┤\n│       4. 执行渲染 / 绘制    │ (样式计算, 布局, 合成, 绘制)\n├────────────────────────────┤\n│       5. requestIdleCallback │ (如果有空闲)\n├────────────────────────────┤\n│       6. 下一个宏任务循环    │\n└────────────────────────────┘\n\n```",
      "**宏任务 → 微任务 → rAF → 渲染 → idle → 下一宏任务**"
    ],
    "reference": "/myKMS/interview/2025#_12-浏览器事件循环-网络请求是宏任务吗",
    "source": "/myKMS/interview/2025"
  },
  {
    "id": 23,
    "question": "页面的线程",
    "answer": [
      "| 线程名称 | 职责 | 是否并行 | 示例说明 | | ---------------------------------- | --------------------------------------- | ----- | ----------------------- | | **主线程（Main Thread）** | 执行 JS、解析 HTML、计算样式、布局（layout）、绘制（paint） | ❌ 单线程 | JS 运行、DOM 操作、重排、重绘都在此执行 | | **渲染线程 / 合成线程（Compositor Thread）** | 接收绘制指令，合成图层生成最终画面 | ✅ 可并行 | 负责 GPU 合成层的渲染，保证流畅动画 | | **光栅化线程（Raster Thread）** | 把图层位图栅格化（交给 GPU 绘制） | ✅ 多线程 | 将合成层绘制成像素输出 | | **网络线程（Network Thread）** | 处理网络请求（HTTP、WebSocket、fetch） | ✅ 独立 | 不受主线程阻塞，可同时并发多个请求 | | **IO 线程（Browser Process）** | 管理文件、Cookie、缓存、输入输出等 | ✅ 独立 | 负责硬盘 / 系统层交互 | | **定时器线程（Timer Thread）** | 管理定时器（setTimeout / setInterval） | ✅ 独立 | 到期后把回调放回主线程事件队列执行 | | **Web Worker 线程** | 执行耗时 JS 计算（不操作 DOM） | ✅ 多线程 | 后台计算、大文件处理、AI、解析任务 | | **Service Worker 线程** | 拦截请求、缓存资源、推送等 | ✅ 独立 | PWA 核心线程，生命周期独立于页面 | | **GPU 线程（GPU Process）** | 负责页面绘制、图像合成、3D 渲染 | ✅ 独立 | 合成层最终交由 GPU 渲染输出 |",
      "**JS、DOM、CSSOM、Layout、Paint、事件响应、垃圾回收（GC）都在主线程中执行。**",
      "因此：当 JS 执行时间过长时（例如死循环 / 大量同步逻辑），会阻塞渲染 → 页面卡顿。当频繁修改 DOM、触发布局重排（Reflow）、重绘（Repaint）时，主线程负载增加 → FPS 下降。",
      "✅ 这就是为什么浏览器看似“多线程”，但 JS 执行仍是单线程的根本原因：JS 与渲染共用主线程，为了避免线程竞争 DOM。"
    ],
    "reference": "/myKMS/interview/2025#_13-页面的线程",
    "source": "/myKMS/interview/2025"
  },
  {
    "id": 24,
    "question": "ts type interface",
    "answer": [
      "interface：适用于定义对象的结构，支持声明合并和扩展，便于面向对象编程。(推荐interface)",
      "type：适用于定义联合类型、交叉类型、元组等复杂类型，提供更强的表达能力",
      "| 对比维度 | `interface` | `type` | | -------------- | --------------------------- | ----------------------- | | **语义** | 描述“对象的结构”或“类的契约” | 可定义任意类型（对象、联合、交叉、原始类型等） | | **扩展方式** | 通过 `extends` 继承 | 通过 `&`（交叉类型）组合 | | **可合并性（声明合并）** | ✅ 可以多次定义同名接口，自动合并 | ❌ 不可重复声明同名 type | | **能定义的类型范围** | 仅限对象、函数、类结构 | ✅ 可定义联合类型、交叉类型、条件类型、元组等 | | **实现关系** | 类（class）可实现（`implements`）接口 | 类不能直接实现 `type` | | **复杂类型表达** | 不支持直接定义联合、映射等复杂类型 | ✅ 支持高级类型语法（联合、条件、映射等） | | **兼容性** | 更适合定义公共 API（库、类） | 更灵活，适合组合与函数类型 | | **编译后表现** | 不会生成 JS 代码，仅用于类型检查 | 同样仅存在于类型层 |",
      "| 场景 | 推荐类型 | 理由 | | ------------ | ----------- | ------------ | | 定义对象结构 / 类契约 | `interface` | 语义更清晰、支持声明合并 | | 定义联合、交叉、映射类型 | `type` | 表达力更强 | | 在公共库、类型声明文件中 | `interface` | 更好扩展性 | | 内部工具类型、组合类型 | `type` | 更灵活简洁 |"
    ],
    "reference": "/myKMS/interview/2025#_14-ts-type-interface",
    "source": "/myKMS/interview/2025"
  },
  {
    "id": 25,
    "question": "ts 泛型",
    "answer": [
      "泛型（Generics） 是一种强大的特性，允许在定义函数、接口或类时不预先指定具体的类型，而在使用时再指定类型，从而实现类型的复用和灵活性。 泛型使得代码在处理不同类型的数据时，仍能保持类型安全。",
      "泛型的优势 类型安全：在编译时进行类型检查，避免运行时错误。 代码复用：编写与特定类型无关的通用代码，提高代码的复用性。 灵活性：根据实际需要指定类型，适应不同的数据类型和数据结构。",
      "高级: 泛型约束, 默认泛型类型, 泛型与联合类型, **函数重载: 所谓函数重载就是同一个函数，根据传递的参数不同，会有不同的表现形式** never是其它类型(null undefined)的子类型，代表不会出现的值"
    ],
    "reference": "/myKMS/interview/2025#_15-ts-泛型",
    "source": "/myKMS/interview/2025"
  },
  {
    "id": 26,
    "question": "从输入 URL 到页面渲染的完整流程, 说出自己的理解",
    "answer": [
      "当用户输入一个 URL 并回车，整个过程可以拆成 五个阶段：",
      "| 阶段 | 描述 | 涉及层次 | | --------- | --------------------------------------------------------- | ----- | | 1️⃣ 地址解析 | URL 解析、缓存检查、DNS 查询、协议判断（HTTP/HTTPS） | 网络层 | | 2️⃣ 建立连接 | TCP 三次握手、TLS 握手（HTTPS） | 传输层 | | 3️⃣ 发送请求 | HTTP 请求报文构造与发送 | 应用层 | | 4️⃣ 服务器响应 | 服务端处理并返回 HTML/CSS/JS/图片等资源 | 服务端 | | 5️⃣ 浏览器渲染 | 构建 DOM / CSSOM / Render Tree / Layout / Paint / Composite | 浏览器内核 |",
      "1. URL 解析与 DNS 查询",
      "流程：",
      "浏览器解析输入内容（判断是搜索词还是 URL）； 检查本地缓存（DNS 缓存、hosts 文件）； 若无缓存，向本地 DNS 服务器递归/迭代查询； 得到目标 IP。",
      "可以优化的点",
      "| 优化项 | 说明 | | ------------------------------------------------------------ | ---------------- | | ✅ 使用 CDN | 缩短 DNS 路径与物理距离 | | ✅ DNS 预解析 (`<link rel=\"dns-prefetch\" href=\"//example.com\">`) | 提前解析域名 | | ✅ 减少跨域请求 | 减少不同域名下的资源请求数 | | ✅ 服务端启用 HTTP/2 | 复用连接，减少 DNS 解析次数 |",
      "2. 建立 TCP / TLS 连接",
      "流程： TCP 三次握手； 若 HTTPS：还需 TLS 握手（证书验证、密钥协商）； 建立安全连接。",
      "可以优化的点:",
      "| 优化项 | 说明 | | --------------------- | ----------- | | ✅ 开启 HTTP/2 or HTTP/3 | 多路复用，减少握手消耗 | | ✅ 复用连接（Keep-Alive） | 减少新连接建立的开销 | | ✅ TLS 1.3 | 减少握手 RTT 次数 | | ✅ 使用 CDN 边缘节点 | 减少物理延迟 |",
      "3. 发送 HTTP 请求",
      "流程： 浏览器构造请求头； 附带 cookie / token； 发送到服务器。",
      "可以优化的点: | 优化项 | 说明 | | ------------------------------- | ------------ | | ✅ 压缩请求头（HTTP/2） | 减少 header 体积 | | ✅ 合理使用缓存头（ETag / Cache-Control） | 减少重复请求 | | ✅ 精简 Cookie | 减少请求体积 | | ✅ 使用 POST/GET 正确语义 | 避免误用 |",
      "4. 服务器响应阶段",
      "流程： 服务器解析请求； 调用后端逻辑 / 查询数据库； 渲染模板（SSR 或返回静态文件）； 返回响应体（HTML、CSS、JS、图片等）",
      "可以优化的点: | 优化项 | 说明 | | ----------------------------------- | --------- | | ✅ 静态化 / CDN 缓存 | HTML/资源分发 | | ✅ SSR / SSG | 加快首屏渲染 | | ✅ 接口聚合 / GraphQL | 减少多次请求 | | ✅ 压缩响应（Gzip/Brotli） | 减小传输体积 | | ✅ 分片传输 (Transfer-Encoding: chunked) | 边传输边渲染 |",
      "5. 浏览器渲染阶段",
      "5.1. 构建 DOM",
      "解析 HTML → 生成 DOM 树； `<script>` 会阻塞解析（除非 async 或 defer）。",
      "优化： defer / async 加载 JS； HTML 压缩； 优化首屏 HTML 结构（避免过多嵌套）； 将不关键的脚本延迟加载。",
      "5.2. 构建 CSSOM",
      "下载并解析 CSS； 与 DOM 合并成 Render Tree。",
      "优化：",
      "减少外链 CSS； 使用关键路径渲染优化（Critical CSS）； 避免复杂选择器； 使用 <link rel=\"preload\"> 预加载关键 CSS。",
      "5.3. Render Tree → Layout → Paint → Composite",
      "Layout：计算每个节点的几何位置； Paint：绘制像素； Composite：合成层，GPU 加速渲染。",
      "| 优化项 | 原理 | | ------------------------- | ------------------------------------ | | ✅ 减少重排重绘 | 避免频繁修改 layout 属性（如 `width`、`height`） | | ✅ 使用 transform/opacity 动画 | 利用 GPU 合成层 | | ✅ 合理使用 will-change | 告诉浏览器提前优化渲染层 | | ✅ 懒加载图片与组件 | 降低首屏压力 | | ✅ 使用虚拟列表 | 优化长列表性能 |",
      "整体性能优化策略总结: | 阶段 | 关键优化方向 | | -- | --------------------------------- | | 网络 | DNS 缓存、HTTP/2、CDN、Keep-Alive | | 请求 | 缓存策略、资源合并与压缩 | | 传输 | Gzip/Brotli 压缩、分片传输 | | 渲染 | 异步加载、懒加载、Critical CSS、DOM 优化 | | 交互 | Debounce/Throttle、GPU 动画、虚拟滚动 | | 构建 | Tree-shaking、Code Splitting、懒加载模块 |",
      "可量化的指标（Web Vitals） | 指标 | 说明 | 理想值 | | ---------------------------------- | -------- | ------- | | **LCP** (Largest Contentful Paint) | 最大内容渲染时间 | < 2.5s | | **FID** (First Input Delay) | 首次交互延迟 | < 100ms | | **CLS** (Cumulative Layout Shift) | 页面布局稳定性 | < 0.1 | | **TTFB** (Time to First Byte) | 首字节时间 | < 0.8s | | **FCP** (First Contentful Paint) | 首次内容绘制 | < 1.8s |"
    ],
    "reference": "/myKMS/interview/2025#_16-从输入-url-到页面渲染的完整流程-说出自己的理解",
    "source": "/myKMS/interview/2025"
  },
  {
    "id": 27,
    "question": "缓存",
    "answer": [
      "浏览器 / 缓存层（代理、CDN）会将服务器响应保存起来，当下次请求相同资源时可直接从缓存中返回，而不必到服务器取。这样可以减少网络延迟和服务器负荷。",
      "新鲜度判断（Freshness） vs 验证（Validation）",
      "新鲜（Fresh）：在有效期内，缓存可直接返回给客户端。 陈旧（Stale）：资源已过有效期，需要验证是否更新（例如通过 ETag / Last-Modified）或强制重新下载。",
      "验证机制：客户端发送条件请求（If-None-Match, If-Modified-Since），服务器如资源未变返回 304 Not Modified 让客户端继续用缓存。",
      "缓存作用域",
      "私有缓存（Private Cache）：如浏览器本地缓存，仅对单个用户可见。",
      "共享缓存（Shared Cache / Proxy / CDN）：CDN / 代理服务器等中间缓存，可被多个用户共享。对于涉及用户隐私或基于 cookie 的响应，要限制这类缓存",
      "no-cache ≠ “不缓存” —— 它允许缓存储存，但使用前必须验证。 no-store 是“不储存”的真正指令，但不会清除已经缓存的旧数据。 Expires 比较老旧，现代多数场景用 cache-control 的 max-age。 实践中: 一般index.html 都是 no-store no-cache 的, 其他静态资源都是设置长缓存的."
    ],
    "reference": "/myKMS/interview/2025#_19-缓存",
    "source": "/myKMS/interview/2025"
  },
  {
    "id": 28,
    "question": "组件 key 改变和 props 改变有什么区别",
    "answer": [
      "| 变化类型 | 对组件实例的影响 | 生命周期 | state 是否保留 | 主要使用场景 | | ------------------------ | ------------------------------------- | ---------------------------------------------------------------------------------------------------- | --------------------- | ----------------------------------------- | | **key 改变** | **卸载旧组件 → 挂载新组件**（实例被销毁并重建） | 先触发旧组件的 `componentWillUnmount` / `useEffect` 的 cleanup，再触发新组件的 `constructor` → `render` → `useEffect` | **不会保留**（因为是全新实例） | 当需要强制重新初始化组件（比如重置表单、重新加载数据） | | **props 改变（key 不变）** | **复用原组件实例** | 触发 `shouldComponentUpdate`（如有）/ `render` / 更新后的 `useEffect` | **会保留**（除非代码主动重置） | 正常的属性更新：列表内容变化、UI 随数据更新 |",
      "#### 核心思想",
      "key 是身份标签：一变就换人（卸载 + 重建）。 props 是输入数据：只变数据，不换人（实例保留）。",
      "##### 一句话总结",
      "需要强制重新初始化组件（如清空表单、重新加载动画）时，用 key； 仅需更新组件展示的数据时，修改 props 即可。",
      "#### 深入: props 引用没变 vs 引用改变",
      "props 引用没变 父组件重新渲染，但 data 对象引用没变。 React 认为 props 没有变化，子组件如果是 React.memo，不会重新渲染。 state 保留，useEffect 依赖不会触发（如果依赖该 prop）。",
      "props 引用改变 每次父组件渲染都会生成新对象。 即使内容相同，引用改变 → React 认为 props 改变。 React.memo 会触发重新渲染。 useEffect 依赖该 prop 也会重新执行。"
    ],
    "reference": "/myKMS/interview/2025#_20-组件-key-改变和-props-改变有什么区别",
    "source": "/myKMS/interview/2025"
  },
  {
    "id": 29,
    "question": "react form 里面非受控组件 如何对应上值的改变",
    "answer": [
      "| 方式 | 数据存放 | 值变化的响应 | 外部值改变时 | | ----- | ----------- | ---------------------------- | ---------------------------------- | | 受控组件 | React state | `onChange` → setState → 重新渲染 | 直接受 state 驱动，值自动更新 | | 非受控组件 | DOM 元素内部 | 通过 `ref` 读取 | 需要用 `ref.current.value = ...` 手动更新 |",
      "总结",
      "非受控组件默认不会随着 props 变化而更新。 如果想同步外部变化： 用 ref + useEffect 直接赋值给 DOM。 或者通过改变 key 来强制重建。 如果频繁需要同步外部数据，最好改用 受控组件"
    ],
    "reference": "/myKMS/interview/2025#_26-react-form-里面非受控组件-如何对应上值的改变",
    "source": "/myKMS/interview/2025"
  },
  {
    "id": 30,
    "question": "antd form是如何控制内部组件的value的",
    "answer": [
      "基于 v4+ 分析",
      "##### 总体设计思路",
      "Antd Form 并不是简单地把 `<Form.Item>` 里的 `<Input>` 当作受控组件包一层，而是自己实现了一套 “表单状态管理 + 受控注入” 机制。 核心：",
      "Form 内部维护一个 FormStore（字段名 → 值 的状态）。 每个 `<Form.Item>` 都会通过 Context 注册到 FormStore。 FormStore 变化后，通过 Context + forceUpdate 通知对应 Form.Item 重新渲染。 Form.Item 渲染时，会把 value 和 onChange 注入到子组件，实现受控。",
      "典型用法:",
      "```jsx\n<Form form={form} initialValues={{ username: 'Tom' }}>\n  <Form.Item name=\"username\">\n    <Input />\n  </Form.Item>\n</Form>\n```",
      "对应关系：",
      "```js\n<Form>           —— 维护 FormStore（字段状态）\n   │\n   └─<FormContext.Provider>  —— 提供 Store 和订阅方法\n        │\n        └─<Form.Item name=\"username\"> —— 注册字段\n              │\n              └─ cloneElement(<Input>, {value, onChange})\n```",
      "1. 流程详解",
      "1. FormStore Form 创建时，内部有一个 store = {} 保存所有字段的值。 提供方法： getFieldValue(name) / getFieldsValue() setFieldValue(name, value) subscribe(callback) 订阅字段变化 Form.useForm() 返回的就是对这个 Store 的引用",
      "2.Form.Item 注册字段 `<Form.Item name=\"username\">` 渲染时，会通过 Context 把 name 注册到 Store。 它会订阅对应字段，当该字段值变化时触发 forceUpdate() 来重新渲染该 Item。",
      "3. 克隆子节点注入受控属性 渲染时，Form.Item 会用 React.cloneElement 给子组件（如 `<Input />`）注入：",
      "```js\n    {\n    value: store[name],\n    onChange: (e) => {\n      const newValue = e && e.target ? e.target.value : e;\n      store.setFieldValue(name, newValue);\n    }\n  }\n  ```",
      "这样，子组件（比如 antd Input）变成了 FormStore 受控的受控组件。 ***自定义组件支持接收value,onChange属性即可*** 如果原本子组件自己也传了 value 和 onChange，Form.Item 会合并，但以 Form 为主。 因此，用 antd Form 时，不需要再手动写 value 和 onChange。",
      "4. 触发更新 用户在 Input 中输入： 1. Input 调用 onChange → store.setFieldValue(name, newValue) 2. Store 更新值后通知所有订阅者（相关 Form.Item） 3. 对应 Form.Item forceUpdate()，重新渲染，给 Input 新的 value 从而保证 Input 的显示值始终与 FormStore 中的值同步。 5.特殊场景 initialValues：初始渲染时写入 Store，Form.Item 会读取。 setFieldsValue / resetFields：调用这些 API 时直接改 Store → 通知订阅 → 触发 Form.Item 更新。 dependencies：依赖项变化时重新渲染 Form.Item。 shouldUpdate：控制 Form.Item 是否重新渲染。",
      "受控与非受控的对比",
      "| 特性 | 普通非受控表单 | antd Form 内部机制 | | ---- | -------------------- | ---------------------------------- | | 值存放 | DOM（通过 defaultValue） | FormStore（JS 对象） | | 组件更新 | 用户输入不会触发 React 重新渲染 | 每次输入都更新 Store 并触发 Form.Item 重渲染 | | 外部控制 | 需要 ref 手动更新 DOM | 用 `form.setFieldsValue()` 即可更新所有字段 |",
      "👉 可以认为： **Antd Form 把所有字段都变成了受控组件，并用集中式 Store 管理。**",
      "**总结**",
      "核心机制：**集中式 FormStore 管理所有字段。** 关键手段：Form.Item 通过 Context 注册并订阅字段变化。 数据流： 外部调用 setFieldsValue 或用户输入 → 更新 Store → 通知 Form.Item → 渲染子组件 → 子组件显示最新值。 因此，antd Form 里的 Input、Select、Checkbox 等都是受控的，值完全由 FormStore 决定。"
    ],
    "reference": "/myKMS/interview/2025#_27-antd-form是如何控制内部组件的value的",
    "source": "/myKMS/interview/2025"
  },
  {
    "id": 31,
    "question": "链式调用的任务调度器",
    "answer": [
      "```js\nfunction arrange(name) {\n  const queue = []\n\n  const obj = {\n    do(task) {\n      queue.push({ first: false, fn: () => console.log(`Start to ${task}`) })\n      return obj\n    },\n    wait(sec) {\n      queue.push({ first: false, fn: () => new Promise(r => {\n        console.log(`等待 ${sec} 秒`)\n        setTimeout(r, sec * 1000)\n      })})\n      return obj\n    },\n    waitFirst(sec) {\n      queue.push({ first: true, fn: () => new Promise(r => {\n        console.log(`等待 ${sec} 秒`)\n        setTimeout(r, sec * 1000)\n      })})\n      return obj\n    },\n    async execute() {\n      // 先执行所有 waitFirst\n      for (const t of queue.filter(t => t.first)) await t.fn()\n      // 打印通知\n      console.log(`${name} is notified`)\n      // 执行剩下的普通任务\n      for (const t of queue.filter(t => !t.first)) {\n        const res = t.fn()\n        if (res instanceof Promise) await res\n      }\n    }\n  }\n\n  return obj\n}\n```"
    ],
    "reference": "/myKMS/interview/code#_2-链式调用的任务调度器",
    "source": "/myKMS/interview/code"
  },
  {
    "id": 32,
    "question": "从0到1新建一个React前端工程，并写一个页面，实现下面功能：上面有个2分钟的倒计时,倒计时下，有2个按钮，一个按钮可以暂停/恢复倒计时，另一个按钮可以减10秒倒计时,然后倒计时到0之后，出现一个秒杀新按钮. 进阶增加重新开始功能",
    "answer": [
      "```jsx\n// 代码由github copilot 生成\n\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n\nconst INITIAL = 120;\n\nconst Demo = () => {\n  const [time, setTime] = useState(INITIAL);\n  const [isStop, setStop] = useState(false);\n  const t = useRef(null);\n\n  // 提取清理函数，统一调用\n  const clearTimer = useCallback(() => {\n    if (t.current) {\n      clearInterval(t.current);\n      t.current = null;\n    }\n  }, []);\n\n  useEffect(() => {\n    // 如果暂停，清理定时器并返回\n    if (isStop) {\n      clearTimer();\n      return;\n    }\n\n    // 已有定时器则不重复创建\n    if (t.current) return;\n\n    t.current = setInterval(() => {\n      setTime((prev) => {\n        if (prev <= 1) {\n          // 到 0 时清理定时器并返回 0\n          clearTimer();\n          return 0;\n        }\n        return prev - 1;\n      });\n    }, 1000);\n\n    // 卸载时清理\n    return () => {\n      clearTimer();\n    };\n  }, [isStop, clearTimer]);\n\n  // 卸载时再确保清理（保险）\n  useEffect(() => {\n    return () => {\n      clearTimer();\n    };\n  }, [clearTimer]);\n\n  const stopAc = useCallback(() => {\n    setStop((v) => !v);\n  }, []);\n\n  const down = useCallback(() => {\n    setTime((t) => (t - 10 > 0 ? t - 10 : 0));\n  }, []);\n\n  // 重新开始：清理旧定时器、重置时间并立即启动新定时器\n  const restart = useCallback(() => {\n    clearTimer();\n    setTime(INITIAL);\n    setStop(false);\n\n    // 立即启动新的定时器（与 useEffect 中逻辑一致）\n    if (!t.current) {\n      t.current = setInterval(() => {\n        setTime((prev) => {\n          if (prev <= 1) {\n            clearTimer();\n            return 0;\n          }\n          return prev - 1;\n        });\n      }, 1000);\n    }\n  }, [clearTimer]);\n\n  const formatTime = (secs) => {\n    const m = Math.floor(secs / 60)\n      .toString()\n      .padStart(2, \"0\");\n    const s = (secs % 60).toString().padStart(2, \"0\");\n    return `${m}:${s}`;\n  };\n\n  return (\n    <>\n      <div aria-live=\"polite\" style={{ fontSize: 32, marginBottom: 12 }}>\n        {formatTime(time)}\n      </div>\n      <button onClick={stopAc} aria-pressed={isStop}>\n        {isStop ? \"恢复\" : \"暂停\"}\n      </button>\n      <button onClick={down} disabled={time === 0} aria-disabled={time === 0}>\n        减10秒倒计时\n      </button>\n      <button onClick={restart} style={{ marginLeft: 8 }}>\n        重新开始\n      </button>\n      {time === 0 ? <button aria-label=\"秒杀按钮\">秒杀</button> : null}\n    </>\n  );\n};\n\nexport default Demo;\n\n```"
    ],
    "reference": "/myKMS/interview/code#_3-从0到1新建一个react前端工程-并写一个页面-实现下面功能-上面有个2分钟的倒计时-倒计时下-有2个按钮-一个按钮可以暂停-恢复倒计时-另一个按钮可以减10秒倒计时-然后倒计时到0之后-出现一个秒杀新按钮-进阶增加重新开始功能",
    "source": "/myKMS/interview/code"
  },
  {
    "id": 33,
    "question": "防抖（debounce）",
    "answer": [
      "```js\n\nfunction debounce(fn, wait = 300) {\n  let timer = null;\n  return function(...args) {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      fn.apply(this, args);\n    }, wait);\n  };\n}\n\n```"
    ],
    "reference": "/myKMS/interview/code#_4-防抖-debounce",
    "source": "/myKMS/interview/code"
  },
  {
    "id": 34,
    "question": "节流（throttle）",
    "answer": [
      "```js\n\nfunction throttle_timestamp(fn, wait) {\n  let last = 0; // 上次执行时间（ms）\n\n  return function (...args) {\n    const now = Date.now();\n    if (now - last >= wait) {\n      last = now;\n      fn.apply(this, args);\n    }\n  };\n}\n\n\n```"
    ],
    "reference": "/myKMS/interview/code#_5-节流-throttle",
    "source": "/myKMS/interview/code"
  },
  {
    "id": 35,
    "question": "手写 Promise",
    "answer": [
      "```js\nclass MyPromise {\n        static PENDING = \"pending\";\n        static RESOLVED = \"resolved\";\n        static REJECTED = \"rejected\";\n        constructor(executor) {\n          this.status = MyPromise.PENDING;\n          // resolve 的值\n          this.value = null;\n          // reject 的值\n          this.reason = null;\n          // then 成功回调\n          this.onFulfilledQueues = [];\n          // then 失败回调\n          this.onRejectedQueues = [];\n\n          // 执行成功回掉\n          let resolve = (value) => {\n            if (this.status === MyPromise.PENDING) {\n              this.status = MyPromise.RESOLVED;\n              this.value = value;\n              // console.log(\"this.onFulfilledQueues\", this.onFulfilledQueues);\n              this.onFulfilledQueues.forEach((item) => {\n                try {\n                  item(value);\n                } catch (err) {\n                  reject(err);\n                }\n              });\n            }\n          };\n\n          // 执行失败回掉\n          let reject = (reason) => {\n            if (this.status === MyPromise.PENDING) {\n              this.status = MyPromise.REJECTED;\n              this.reason = reason;\n              this.onRejectedQueues.forEach((item) => {\n                try {\n                  item(value);\n                } catch (err) {\n                  reject(err);\n                }\n              });\n            }\n          };\n\n          try {\n            executor(resolve, reject);\n          } catch (err) {\n            reject(err);\n          }\n        }\n\n        then(onFulfilled, onRejected) {\n          onFulfilled =\n            typeof onFulfilled === \"function\" ? onFulfilled : (value) => value;\n          onRejected =\n            typeof onRejected === \"function\"\n              ? onRejected\n              : (reason) => {\n                  throw reason;\n                };\n\n          const promise = new MyPromise((res, rej) => {\n            if (this.status === MyPromise.PENDING) {\n              this.onFulfilledQueues.push((v) => res(onFulfilled(v)));\n              this.onRejectedQueues.push((v) => rej(onRejected(v)));\n            }\n            // 状态是成功态，直接就调用 onFulfilled 函数\n            if (this.status === MyPromise.RESOLVED) {\n              res(onFulfilled(this.value));\n            }\n\n            // 状态是成功态，直接就调用 onRejected 函数\n            if (this.status === MyPromise.REJECTED) {\n              rej(onRejected(this.reason));\n            }\n          });\n\n          return promise;\n        }\n\n        // 将多个 Promise 并行等待：所有都成功则返回按原数组顺序的结果数组，\n        // 只要有一个失败则立即 reject（行为类似原生 Promise.all）\n        // 参数：arr - Promise 实例数组\n        // 返回：MyPromise，resolve(valueArray) / reject(firstError)\n        static all(arr) {\n          return new MyPromise((res, rej) => {\n            let result = [];\n            let count = 0;\n            for (let i = 0; i < arr.length; i++) {\n              arr[i].then(\n                (d) => {\n                  result[i] = d;\n                  if (++count === arr.length) {\n                    res(result);\n                  }\n                },\n                (err) => {\n                  rej(err);\n                }\n              );\n            }\n          });\n        }\n        // 竞速：返回第一个完成（resolve 或 reject）的结果（类似原生 Promise.race）\n        // 参数：arr - Promise 实例数组\n        // 返回：MyPromise，resolve(firstResolved) 或 reject(firstRejected)\n      \n        static race(arr) {\n          return new MyPromise((res, rej) => {\n            for (let i = 0; i < arr.length; i++) {\n              arr[i].then(res, rej);\n            }\n          });\n        }\n        \n        // allSettled：等待所有 Promise 都 settle（不论成功或失败）后返回结果集合\n        // 参数：promises - Promise 实例数组\n        // 返回：MyPromise，resolve(resultArray)\n        // 说明：本实现将每个 Promise 的 finally 视作“完成”的回调点并把返回值放到结果数组，\n        //       意味着结果数组项的结构取决于 finally 回调传入的值 —— 与原生 Promise.allSettled 返回\n        //       的 {status, value/reason} 结构有所不同。调整以匹配原生行为可在 finally/then 中\n        //       分别处理 fulfilled/rejected 情况。\n\n        static allSettled(promises) {\n          return new MyPromise((resolve) => {\n            let result = [];\n            let count = 0;\n            for (let i = 0; i < promises.length; i++) {\n              promises[i].finally((res) => {\n                result[i] = res;\n                if (++count == promises.length) {\n                  resolve(result);\n                }\n              });\n            }\n          });\n        }\n\n        // any：只要有一个 Promise 成功就 resolve（值为第一个成功的结果），\n        //      若全部失败则 reject，返回所有错误组成的数组（行为类似原生 Promise.any，\n        //      但原生 Promise.any 在全部失败时会返回 AggregateError）\n        // 参数：arr - Promise 实例数组\n        // 返回：MyPromise，resolve(firstSuccess) 或 reject(errorArray)\n \n        static any(arr) {\n          return new MyPromise((res, rej) => {\n            let result = [];\n            let count = 0;\n            for (let i = 0; i < arr.length; i++) {\n              arr[i].then(\n                (d) => {\n                  res(d);\n                },\n                (err) => {\n                  result[i] = err;\n                  if (++count === arr.length) {\n                    rej(result);\n                  }\n                }\n              );\n            }\n          });\n        }\n\n        catch(rej) {\n          return this.then(null, rej);\n        }\n\n        finally(res) {\n          return this.then(res, res);\n        }\n\n        // map：限制并发数的 Promise 执行器\n        // 参数：\n        //   promises - Promise 实例数组（或返回 Promise 的函数数组，视使用场景）\n        //   concurrency - 最大并发数（同时运行的 Promise 数量上限）\n        // 返回：MyPromise，resolve(resultArray) 在所有 Promise 完成后触发\n        // 算法要点：\n        //  - 使用 nextIndex 指向下一个待启动的 Promise，下发任务时递增 nextIndex\n        //  - 初始启动 concurrency 个任务；每当一个任务完成后（finally 回调），\n        //    记录结果并启动下一个待办任务，从而始终保持并发数量不超过 concurrency\n        //  - 通过 count 统计已完成任务数，全部完成后 resolve 最终结果数组\n        // 注意：\n        //  - 这里通过 promises[i].finally(...) 作为“完成”判定点，因此无论成功或失败都\n        //    会触发后续调度；若需区分成功/失败并保留状态信息，需要在 finally/then 中\n        //    对 result 数组项存储更丰富的对象（如 { status, value/reason }）\n\n        static map(promises, concurrency) {\n          // 返回一个新的 MyPromise\n          return new MyPromise((resolve) => {\n            let result = []; // 用于保存每个 Promise 的结果\n            let count = 0; // 已完成的 Promise 数量\n            let nextIndex = 0; // 下一个要启动的 Promise 下标\n\n            // 并发执行的函数\n            function run() {\n              // 如果所有 Promise 都已启动，则直接返回\n              if (nextIndex >= promises.length) return;\n              const current = nextIndex; // 当前要启动的 Promise 下标\n              nextIndex++; // 下一个要启动的下标\n              // 启动当前 Promise，并在其 finally 后处理结果\n              promises[current].finally((res) => {\n                result[current] = res; // 保存结果到对应位置\n                count++; // 完成数量加一\n                if (count === promises.length) {\n                  // 所有 Promise 都完成后，resolve 最终结果\n                  resolve(result);\n                } else {\n                  // 启动下一个 Promise\n                  run();\n                }\n              });\n            }\n\n            // 一开始并发启动 concurrency 个 Promise\n            for (let i = 0; i < concurrency && i < promises.length; i++) {\n              run();\n            }\n          });\n        }\n      }\n\n      let p1 = new MyPromise((resolve, reject) => {\n        setTimeout(() => {\n          console.log(\"ok\");\n          resolve(\"成功了\");\n        }, 1000);\n      });\n\n      p1.then(\n        (data) => {\n          console.log(\"then1 resolve\", data);\n          return 111;\n        },\n        (err) => {\n          console.log(\"then1 reject\", err);\n        }\n      )\n        .then(\n          (data) => {\n            console.log(\"then2 resolve\", data);\n          },\n          (err) => {\n            console.log(\"then2 reject\", err);\n          }\n        )\n        .then(\n          (data) => {\n            console.log(\"then3 resolve\", data);\n          },\n          (err) => {\n            console.log(\"then3 reject\", err);\n          }\n        );\n\n      let Promise1 = new MyPromise((resolve, reject) => {\n        setTimeout(() => {\n          resolve(\"Promise1\");\n        }, 5000);\n        resolve(\"Promise2\");\n      });\n\n      let Promise2 = new MyPromise((resolve, reject) => {\n        resolve(\"Promise2\");\n      });\n\n      let Promise3 = new MyPromise((resolve, reject) => {\n        resolve(\"Promise3\");\n      });\n\n      let Promise4 = new MyPromise((resolve, reject) => {\n        resolve(\"Promise4\");\n      });\n      let Promise5 = new MyPromise((resolve, reject) => {\n        reject(\"Promise5\");\n      });\n      let Promise6 = new MyPromise((resolve, reject) => {\n        reject(\"Promise6\");\n      });\n\n      let p = MyPromise.all([Promise1, Promise2, Promise3, Promise4]);\n\n      p.then(\n        (res) => {\n          // 三个都成功则成功\n          console.log(\"all ---成功了\", res);\n        },\n        (err) => {\n          console.log(\"all ---失败了\", err);\n        }\n      ).catch((error) => {\n        // 只要有失败，则失败\n        console.log(\"all ---失败了\", err);\n      });\n\n      MyPromise.any([Promise4, Promise5, Promise6])\n        .then(\n          (res) => {\n            // 三个都成功则成功\n            console.log(\"any 成功了\", res);\n          },\n          (err) => {\n            console.log(\"any 失败了\", err);\n          }\n        )\n        .catch((error) => {\n          // 只要有失败，则失败\n          console.log(\"any 失败了\", err);\n        });\n\n      Promise.race([Promise1, Promise2, Promise3]).then(\n        (res) => {\n          console.log(\"race resolve\", res);\n        },\n        (rej) => {\n          console.log(\"race reject\", rej);\n        }\n      );\n\n      let pAll = MyPromise.allSettled([Promise1, Promise2, Promise3, Promise4]);\n\n      pAll.then(\n        (res) => {\n          // 三个都成功则成功\n          console.log(\"---成功了 allSettled\", res);\n        },\n        (err) => {\n          // 只要有失败，则失败\n          console.log(\"---失败了 allSettled\", err);\n        }\n      );\n\n      // 2s 后输出：---成功了 (4) [\"Promise1\", \"Promise2\", \"Promise3\", \"Promise4\"]\n\n      // 直接输出：---失败了 Promise4\n\n\n```"
    ],
    "reference": "/myKMS/interview/code#_5-手写-promise",
    "source": "/myKMS/interview/code"
  },
  {
    "id": 36,
    "question": "js bind 实现机制？手写一个 bind 方法？",
    "answer": [
      "bind的 作用: **返回一个新的函数，这个新函数在被调用时，其内部的 this 会永久绑定为你指定的对象。**",
      "bind 做了三件事：",
      "绑定 this：返回一个新的函数，内部的 this 固定为传入的对象； 支持参数预置：可以提前绑定部分参数； 兼容 new 调用：如果用 new 调用 bind 生成的函数，this 绑定失效，应该指向新实例。",
      "```js\n// 简单版\nFunction.prototype.myBind = function (context) {\n  const fn = this; // 保存原函数\n  return function () {\n    return fn.apply(context);\n  };\n};\n\n// 支持参数传递（柯里化）\nFunction.prototype.myBind = function (context, ...args) {\n  const fn = this;\n  return function (...innerArgs) {\n    return fn.apply(context, [...args, ...innerArgs]);\n  };\n};\n\n\n// 考虑 new 构造调用\nFunction.prototype.myBind = function (context, ...args) {\n  const fn = this;\n\n  function boundFn(...innerArgs) {\n    // 如果作为构造函数被调用\n    const isNew = this instanceof boundFn;\n    return fn.apply(isNew ? this : context, [...args, ...innerArgs]);\n  }\n\n  // 继承原函数原型\n  boundFn.prototype = Object.create(fn.prototype);\n\n  return boundFn;\n};\n\n```",
      "bind、call、apply: | 特点 | 描述 | | ----- | ------------------- | | 功能目标 | 改变函数执行时的 `this` 指向 | | 调用对象 | 必须是函数（Function 的实例） | | 第一个参数 | 都是要绑定的 `this` 对象 | | 后续参数 | 都是函数的参数（但传法不同） |",
      "| 方法 | 是否立即执行 | 参数传递方式 | 返回值 | | --------------------------------- | ------- | ------- | --------------- | | **`call(thisArg, ...args)`** | ✅ 立即执行 | 按参数依次传入 | 函数执行结果 | | **`apply(thisArg, [argsArray])`** | ✅ 立即执行 | 数组形式传参 | 函数执行结果 | | **`bind(thisArg, ...args)`** | ❌ 不立即执行 | 按参数依次传入 | **返回新函数**（延迟执行） |",
      "```js\nfunction greet(g1, g2) {\n  console.log(this.name, g1, g2);\n}\n\nconst obj = { name: \"Alice\" };\n\ngreet.call(obj, \"Hello\", \"World\");   // Alice Hello World\ngreet.apply(obj, [\"Hi\", \"JS\"]);      // Alice Hi JS\nconst bound = greet.bind(obj, \"Hey\");\nbound(\"React\");                      // Alice Hey React\n\n```",
      "| 特性 | `call` | `apply` | `bind` | | --------- | ------ | ------- | ----------- | | 是否立即执行 | ✅ 是 | ✅ 是 | ❌ 否 | | 参数形式 | 单个、多个 | 数组 | 单个、多个 | | 返回值 | 执行结果 | 执行结果 | 新函数 | | 是否可用作构造函数 | ❌ 否 | ❌ 否 | ✅ 可（支持 new） | | 是否能预置参数 | ❌ 否 | ❌ 否 | ✅ 可 | | 是否影响原函数 | ❌ 否 | ❌ 否 | ❌ 否 |",
      "应用场景: | 场景 | 使用方法 | | ------------ | ------------------------------------------------ | | 借用其他对象方法 | `Array.prototype.slice.call(arguments)` | | 动态传参 | `fn.apply(obj, [1, 2, 3])` | | 函数柯里化 / 预置参数 | `fn.bind(obj, 1, 2)` | | 定时器中固定 this | `setTimeout(fn.bind(this), 1000)` | | React 组件事件绑定 | `this.handleClick = this.handleClick.bind(this)` |",
      "**call：立刻执行，参数依次传。**",
      "**apply：立刻执行，参数打包传。**",
      "**bind：返回函数，稍后执行。**"
    ],
    "reference": "/myKMS/interview/code#_6-js-bind-实现机制-手写一个-bind-方法",
    "source": "/myKMS/interview/code"
  },
  {
    "id": 37,
    "question": "图片查看器",
    "answer": [
      "| 层级 | 功能模块 | 描述 | | ------ | ------------------------- | ----------- | | 🧱 基础层 | **加载、显示、缩放、平移、旋转** | 图片展示的最小功能集合 | | 🧭 导航层 | **缩略图 / 小地图 / 缩放滑块** | 帮助用户快速定位和缩放 | | 🧰 工具层 | **标注、测量、取色、截图、对比** | 用户交互功能 | | 💾 数据层 | **多图层、多通道、切片加载、缓存** | 支撑大图和多维数据展示 | | 🧠 智能层 | **懒加载、GPU 渲染、离屏渲染、预加载预测** | 性能优化和体验提升 | | 🧩 扩展层 | **插件体系 / 事件系统 / 定制UI** | 框架化、工程化能力 |"
    ],
    "reference": "/myKMS/interview/code#_7-图片查看器",
    "source": "/myKMS/interview/code"
  },
  {
    "id": 38,
    "question": "手写 instanceof 方法",
    "answer": [
      "instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。",
      "实现步骤： 首先获取类型的原型 然后获得对象的原型 然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null",
      "```js\nfunction myInstanceof(left, right) {\n  let proto = Object.getPrototypeOf(left), // 获取对象的原型\n      prototype = right.prototype; // 获取构造函数的 prototype 对象\n\n  // 判断构造函数的 prototype 对象是否在对象的原型链上\n  while (true) {\n    if (!proto) return false;\n    if (proto === prototype) return true;\n\n    proto = Object.getPrototypeOf(proto);\n  }\n}\n```"
    ],
    "reference": "/myKMS/interview/code#_8-手写-instanceof-方法",
    "source": "/myKMS/interview/code"
  },
  {
    "id": 39,
    "question": "手写 new 操作符",
    "answer": [
      "在调用 new 的过程中会发生以上四件事情：",
      "（1）首先创建了一个新的空对象",
      "（2）设置原型，将对象的原型设置为函数的 prototype 对象。",
      "（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）",
      "（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。",
      "```js\n\nfunction myNew(constructor, ...args) {\n  if (typeof constructor !== \"function\") return\n  let obj = {}\n  obj.prototype = Object.create(constructor.prototype)\n  const res = constructor.apply(obj, args)\n  if (res && (typeof res !== \"object\" || typeof res === \"function\")) return res\n  return obj\n}\nfunction Fn(obj) {\n  this.obj =obj\n}\nlet obj =myNew(Fn,'222')\nconsole.log(obj);\n\n```"
    ],
    "reference": "/myKMS/interview/code#_9-手写-new-操作符",
    "source": "/myKMS/interview/code"
  },
  {
    "id": 40,
    "question": "函数柯里化",
    "answer": [
      "柯里化（Currying） 是把一个接受多个参数的函数，转换成一系列每次只接收一个参数的函数。",
      "类比: “一次性买 3 个苹果”，变成 “一次买 1 个，买 3 次，最后结算”。",
      "```\nfunction add(a, b, c) {\n  return a + b + c;\n}\n\nadd(1, 2, 3)  →  curry(add)(1)(2)(3)\n\ncurry(add)(1)  // 返回一个函数，等待第二个参数\n\n\n```",
      "好处: ✅ 参数复用（延迟调用）",
      "✅ 提高函数复用性、组合性",
      "✅ 实现函数“预设参数”（偏函数）",
      "✅ 提升代码可读性和函数式风格",
      "```js\n\nfunction curry(fn) {\n  const curried = (...args) => {\n    // 如果参数足够就执行，否则返回新函数继续收集\n    return args.length >= fn.length\n      ? fn(...args)\n      : (...next) => curried(...args, ...next);\n  };\n  return curried;\n}\n\n```"
    ],
    "reference": "/myKMS/interview/code#_10-函数柯里化",
    "source": "/myKMS/interview/code"
  },
  {
    "id": 41,
    "question": "如何判断用户是否离开当前页面?",
    "answer": [
      "一、页面可见性 Page Visibility API",
      "判断用户标签页是否可见（切换到后台/最小化浏览器）",
      "```\ndocument.addEventListener('visibilitychange', () => {\n  if (document.hidden) {\n    console.log('用户离开页面（切换标签页或最小化）');\n  } else {\n    console.log('用户回到页面');\n  }\n});\n\n```",
      "二、窗口焦点（Focus / Blur）",
      "检测窗口或 iframe 是否获得焦点",
      "```\nwindow.addEventListener('blur', () => {\n  console.log('用户离开了当前窗口/标签页');\n});\n\nwindow.addEventListener('focus', () => {\n  console.log('用户回到当前窗口/标签页');\n});\n\n```",
      "三、用户离开页面 / 卸载（beforeunload / unload）",
      "检测用户关闭页面、刷新或跳转。",
      "```\nwindow.addEventListener('beforeunload', (e) => {\n  console.log('用户可能离开页面');\n  // 阻止默认提示（可选）\n  e.preventDefault();\n  e.returnValue = '';\n});\n\n```",
      "四、鼠标 / 用户交互检测",
      "当用户长时间没有交互（鼠标、键盘、触屏），可推测用户离开",
      "```\nlet idleTimer;\nfunction resetIdle() {\n  clearTimeout(idleTimer);\n  idleTimer = setTimeout(() => {\n    console.log('用户可能离开或无操作');\n  }, 30000); // 30秒无操作\n}\n\n// 监听用户操作\n['mousemove','keydown','click','scroll','touchstart'].forEach(ev =>\n  document.addEventListener(ev, resetIdle)\n);\nresetIdle();\n\n```",
      "可以检测“用户不活跃”，用于自动登出、心跳等.",
      "```\nlet idleTimer;\nfunction onUserIdle() { console.log('用户离开页面或长时间不操作'); }\nfunction resetIdle() {\n  clearTimeout(idleTimer);\n  idleTimer = setTimeout(onUserIdle, 30000);\n}\n['mousemove','keydown','click','scroll','touchstart'].forEach(ev => \n  document.addEventListener(ev, resetIdle)\n);\nresetIdle();\n\ndocument.addEventListener('visibilitychange', () => {\n  if (document.hidden) onUserIdle();\n});\nwindow.addEventListener('blur', onUserIdle);\nwindow.addEventListener('focus', resetIdle);\n\n```"
    ],
    "reference": "/myKMS/interview/index#_1-如何判断用户是否离开当前页面",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 42,
    "question": "前端如何预览pdf?",
    "answer": [
      "一、直接使用浏览器内置 PDF 渲染 `<iframe>` 嵌入 `<embed>` 标签 新开标签页",
      "二、使用 PDF.js PDF.js 是最常用的前端 PDF 渲染库，可以在 `<canvas>` 上渲染 PDF 页面。"
    ],
    "reference": "/myKMS/interview/index#_2-前端如何预览pdf",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 43,
    "question": "前端批量请求失败Toast重复弹窗怎么解决？",
    "answer": [
      "全局标志拦截: 无论多少错误只弹出一个错误 Toast 自身防抖, 短时间内只弹一次 错误聚合：在拦截器层面，收集短时间内的所有错误，然后合并成一条 Toast 显示 在拦截器中不立即弹窗，而是将错误“收集”起来，用一个 debounce 函数在短时间后统一处理 错误分类队列和分类处理 业务层处理 在发起请求时，告知拦截器“不要弹 Toast”，然后在业务代码中用 Promise.allSettled 手动处理所有结果 还可以加上重试机制和错误上报"
    ],
    "reference": "/myKMS/interview/index#_3-前端批量请求失败toast重复弹窗怎么解决",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 44,
    "question": "如何解决页面接口请求大规模并发问题",
    "answer": [
      "请求去重（防抖 + 节流 + 队列） 核心思想：同一资源、同一参数，不重复发请求。",
      "请求合并 把多个相似请求合并为一个。",
      "并发限制 控制同时发出的请求数，超过的进入队列。",
      "缓存 优化请求时机"
    ],
    "reference": "/myKMS/interview/index#_4-如何解决页面接口请求大规模并发问题",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 45,
    "question": "渲染元素很多, 如何保证页面不卡顿?",
    "answer": [
      "核心思想是 **只渲染用户可见的部分**",
      "解决思路：**减少一次性渲染的 DOM 数量 + 批量更新 + GPU 加速 + 异步渲染**",
      "虚拟列表（Virtual List） 时间分片（Time Slicing）/分批渲染 数据加载优化 分页 无限滚动 DOM 操作批量化 避免复杂的 CSS 样式 减少重排与重绘 合并 DOM 操作 避免频繁修改 layout 属性 使用 transform / opacity 做动画，配合 will-change 提前优化 CSS GPU 加速 虚拟 DOM / diff 优化 异步计算 对大量计算操作使用 Web Worker 主线程只负责渲染，避免 JS 阻塞 框架优化"
    ],
    "reference": "/myKMS/interview/index#_5-渲染元素很多-如何保证页面不卡顿",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 46,
    "question": "前端低代码平台表单联动如何实现",
    "answer": [
      "1. 解析依赖关系 2. 构建观察者 / 订阅机制 3. 动态执行规则",
      "```\nformFields = [\n  { field: 'province', type: 'select' },\n  { field: 'city', type: 'select', dependsOn: 'province', compute: (state) => cities[state.province] }\n]\n\n// 生成依赖图\ndepMap = {\n  province: ['city']\n}\n\n// 字段值变化时触发依赖\nfunction onChange(field, value) {\n  formState[field] = value;\n  (depMap[field] || []).forEach(depField => {\n    const compute = formFields.find(f => f.field === depField).compute;\n    if(compute) formState[depField] = compute(formState);\n  });\n}\n\n```"
    ],
    "reference": "/myKMS/interview/index#_6-前端低代码平台表单联动如何实现",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 47,
    "question": "想象一下，如果项目上线前一天，测试团队发现一个严重bug，但修复可能导致发布延期，你会如何处理？",
    "answer": [
      "第一步：冷静评估 —— 判断问题的性质与影响范围 影响范围 复现条件 修复风险",
      "输出：问题严重程度报告（Critical / High / Medium / Low）+ 修复复杂度评估（简单 / 中等 / 高风险",
      "第二步：权衡方案 —— 快速制定应急策略 高风险 + 高影响（核心功能挂） 坚决延期上线 低风险 + 高影响（可临时绕过） 上线但添加临时兜底方案 高风险 + 低影响（边缘功能有隐患） 修复放入下个小版本或灰度",
      "沟通与协作策略 要让决策透明，团队共识明确 上线后风控 快速回滚脚本 实时监控"
    ],
    "reference": "/myKMS/interview/index#_8-想象一下-如果项目上线前一天-测试团队发现一个严重bug-但修复可能导致发布延期-你会如何处理",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 48,
    "question": "请分享一个你通过优化前端性能提升用户体验的案例，具体用了哪些技术手段",
    "answer": [
      "路由级 按需加载 使用 Preload / Prefetch 提前请求关键资源 gzip 压缩 Tree Shaking loading 合并接口/减少接口 渲染分级 骨架屏 + 异步渲染",
      "比如: 旧项目 webpackChunkName 设置不和导致code slipt 基本没效果, 根据项目实际重新配置 webpackChunkName"
    ],
    "reference": "/myKMS/interview/index#_9-请分享一个你通过优化前端性能提升用户体验的案例-具体用了哪些技术手段",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 49,
    "question": "想象一下，如果你的团队在开发过程中遇到第三方库的严重漏洞，你会如何处理",
    "answer": [
      "1️⃣ 立即评估风险 确认漏洞影响范围 确定漏洞严重性",
      "2️⃣ 暂时缓解方案 如果漏洞立即可被利用： 临时回退/锁定依赖版本：回退到无漏洞的历史版本； 增加防护：例如在后端增加校验、限制敏感接口调用、关闭受影响功能； 升级依赖库：如果官方已经修复，尽快升级并回归测试。",
      "关键点：**先保护生产环境，保证业务安全**",
      "3️⃣ 团队协作与信息通报 通知相关团队：产品、测试、运维和安全团队； 记录漏洞事件：漏洞类型、影响范围、临时处理方案； 同步上线计划：判断是否需要紧急发布补丁，或在下次发布中修复。",
      "4️⃣ 长期解决方案 建立依赖管理策略 替换或隔离高风险库 增强 CI/CD 安全管控"
    ],
    "reference": "/myKMS/interview/index#_10-想象一下-如果你的团队在开发过程中遇到第三方库的严重漏洞-你会如何处理",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 50,
    "question": "请求竞态如何处理?",
    "answer": [
      "竞态往往导致了 UI 显示错误的旧数据",
      "1. 请求标识（requestId + 比对） 每个请求都有唯一 ID，只保留最后一次发出的响应结果。 react 可以使用 ref 包裹 lastRequestId",
      "```\nlet lastRequestId = 0;\n\nasync function fetchData(query) {\n  const requestId = ++lastRequestId; // 每次请求自增\n  const res = await fetch(`/api/search?q=${query}`);\n  const data = await res.json();\n\n  if (requestId === lastRequestId) {\n    setData(data); // 只有最新请求才能更新UI\n  }\n}\n\n```",
      "2. AbortController（中断旧请求） 在发新请求前，主动“中止”旧请求。",
      "3. 使用 useEffect + cleanup",
      "```\nuseEffect(() => {\n  let canceled = false;\n\n  (async () => {\n    const res = await fetch(`/api/data?id=${id}`);\n    const data = await res.json();\n    if (!canceled) setData(data);\n  })();\n\n  return () => (canceled = true); // 清理逻辑\n}, [id]);\n\n```",
      "4. 使用 SWR / React Query 等数据层库",
      "请求竞态的本质是异步返回的先后顺序失序。",
      "解决方案的核心思想就是： 要么 中止旧请求； 要么 忽略旧响应； 或者 让库帮你管理一致性。"
    ],
    "reference": "/myKMS/interview/index#_11-请求竞态如何处理",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 51,
    "question": "实现 从详情页返回列表页保存上次加载的数据和自动还原上次的浏览位置。",
    "answer": [
      "| 方案 | 实现原理 | 适用场景 | | ----------------- | --------------------------------------------------- | ---------- | | **方案 1：状态提升到全局** | 把列表数据与滚动位置存入全局状态（Context、Redux、Recoil、Zustand等） | ✅ 通用、推荐 | | **方案 2：缓存整个列表组件** | 使用 `<KeepAlive>` 或路由缓存（React Router + custom cache） | ✅ 简单但侵入性较高 |",
      "Vue 3 自带了` <KeepAlive>` 组件",
      "react 实现 keep-alive",
      "```\n// KeepAlive.jsx \nimport { useRef } from 'react';\nimport { useLocation } from 'react-router-dom';\n\nexport default function KeepAlive({ children }) {\n  const location = useLocation();\n  const cacheRef = useRef({});\n  const path = location.pathname;\n\n  Object.keys(cacheRef.current).forEach((key) => {\n    cacheRef.current[key].style.display = key === path ? 'block' : 'none';\n  });\n\n  if (!cacheRef.current[path]) {\n    const div = document.createElement('div');\n    div.style.display = 'block';\n    cacheRef.current[path] = div;\n  }\n\n  return (\n    <>\n      {Object.entries(cacheRef.current).map(([key, container]) => (\n        <div\n          key={key}\n          style={{ display: key === path ? 'block' : 'none' }}\n        >\n          {key === path ? children : null}\n        </div>\n      ))}\n    </>\n  );\n}\n\n```"
    ],
    "reference": "/myKMS/interview/index#_12-实现-从详情页返回列表页保存上次加载的数据和自动还原上次的浏览位置。",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 52,
    "question": "设计一套全站页面加载耗时统计工具",
    "answer": [
      "实时/离线监控页面加载体验（首屏、交互、资源、网络等）。 支持 SPA + MPA、移动端与桌面端。 能按 URL、用户群、地理/运营维度切分（例如：p50/p90/p95）。 支持异常告警（例如：p95 突增、LCP 超阈值）。 低埋点侵入、低成本存储、可扩展分析与可视化。",
      "指标（What to collect）",
      "分为「关键体验指标（Web Vitals）」与「补充指标」： 核心（必须） LCP（Largest Contentful Paint） FCP（First Contentful Paint） TTFB（Time To First Byte） DOMContentLoaded（DCL） Load Event（onload） CLS（Cumulative Layout Shift） FID / INP（First Input Delay / Interaction to Next Paint） JS/Vue/React 渲染耗时（自定义埋点） 页面总体耗时：导航开始到 onload、以及自定的“首交互完成”时间",
      "资源类（可选） Resource timing（各静态资源的加载耗时：dns, connect, ssl, request, response, duration） 图片/字体/第三方脚本的失败率与耗时",
      "网络/环境上下文（必须）",
      "URL / route（路由名） Referrer / entry type（navigate, reload, back_forward） UserAgent / 浏览器、版本、操作系统 网络信息：effectiveType、downlink、rtt（若可用） 地点（可选：基于 IP 反查或前端传入地区） Client timestamp / server timestamp（用于校准）",
      "错误上下文（可选）",
      "JS 错误（message, stack, filename, lineno）以便关联慢页面与错误。",
      "采样与频率",
      "生产环境：默认采样率 1% - 10%（视流量与预算），关键页面或实验中 100% 采集。 支持动态下发采样策略（CDN / 配置中心）。",
      "前端采集 SDK（关键实现要点 + 代码示例）",
      "要点：",
      "仅在 document.visibilityState === 'visible' 时采集（避免 background 干扰） 优先用 PerformanceObserver 捕获 LCP / FID / CLS / Paint 收集 performance.getEntriesByType('resource')（资源耗时，限量采样） 批量上报：合并短时间内的多条事件，阈值（条数/时长）触发上报 在 pagehide/unload 用 navigator.sendBeacon 发送最后一条数据 控制上报体积：每次上报限制 10KB 左右，过大时只上报关键字段或采样",
      "js sdk",
      "```\n// perf-sdk.js (浏览器端核心逻辑, 精简示例)\n(function (window) {\n  const APP = {};\n  const SEND_URL = '/beacon/perf';\n  const BATCH_MAX = 20;\n  const BATCH_INTERVAL = 5000; // ms\n  let queue = [];\n\n  function now() { return Math.round(performance.now()); }\n\n  // 收集 web vitals\n  function installVitals() {\n    // LCP\n    try {\n      const po = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        const last = entries[entries.length - 1];\n        if (last) push({ k: 'lcp', v: Math.round(last.startTime) });\n      });\n      po.observe({ type: 'largest-contentful-paint', buffered: true });\n    } catch (e) {}\n\n    // CLS\n    try {\n      let clsValue = 0;\n      const po2 = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          if (!entry.hadRecentInput) clsValue += entry.value;\n        }\n      });\n      po2.observe({ type: 'layout-shift', buffered: true });\n      window.addEventListener('visibilitychange', () => {\n        if (document.visibilityState === 'hidden') push({ k: 'cls', v: clsValue });\n      });\n    } catch (e) {}\n\n    // FCP\n    try {\n      const po3 = new PerformanceObserver((list) => {\n        const fcp = list.getEntries()[0];\n        if (fcp) push({ k: 'fcp', v: Math.round(fcp.startTime) });\n      });\n      po3.observe({ type: 'paint', buffered: true });\n    } catch (e) {}\n  }\n\n  function captureNavigation() {\n    const nav = performance.getEntriesByType('navigation')[0];\n    if (nav) {\n      push({ k: 'ttfb', v: Math.round(nav.responseStart) });\n      push({ k: 'domcontentloaded', v: Math.round(nav.domContentLoadedEventEnd) });\n      push({ k: 'load', v: Math.round(nav.loadEventEnd) });\n    } else if (performance.timing) {\n      const t = performance.timing;\n      push({ k: 'ttfb', v: t.responseStart - t.requestStart });\n    }\n  }\n\n  function push(event) {\n    const payload = {\n      ts: Date.now(),\n      url: location.pathname + location.search,\n      ua: navigator.userAgent,\n      navType: performance.getEntriesByType('navigation')[0]?.type || 'navigate',\n      ...event\n    };\n    queue.push(payload);\n    if (queue.length >= BATCH_MAX) flush();\n  }\n\n  function flush() {\n    if (queue.length === 0) return;\n    const body = JSON.stringify(queue.splice(0, BATCH_MAX));\n    // prefer sendBeacon\n    if (navigator.sendBeacon) {\n      navigator.sendBeacon(SEND_URL, body);\n    } else {\n      fetch(SEND_URL, { method: 'POST', keepalive: true, headers: { 'Content-Type': 'application/json' }, body }).catch(()=>{});\n    }\n  }\n\n  // 定时发送\n  setInterval(flush, BATCH_INTERVAL);\n\n  // 在卸载页面时发送\n  window.addEventListener('pagehide', flush);\n\n  // init\n  installVitals();\n  captureNavigation();\n  APP.flush = flush;\n  window.__PerfSDK = APP;\n})(window);\n\n\n```"
    ],
    "reference": "/myKMS/interview/index#_13-设计一套全站页面加载耗时统计工具",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 53,
    "question": "H5 如何解决移动端适配问题",
    "answer": [
      "HTML`<meta viewport>`标签告诉浏览器页面的“逻辑宽度”和缩放比例。",
      "`<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">`",
      "`width=device-width`：逻辑宽度等于设备宽度；",
      "`initial-scale=1.0`：不缩放；",
      "禁止用户缩放，避免布局错乱。",
      "使用 rem 适配 ;",
      "使用 vw/vh 适配"
    ],
    "reference": "/myKMS/interview/index#_14-h5-如何解决移动端适配问题",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 54,
    "question": "函数式编程",
    "answer": [
      "函数式编程是一种编程范式，它强调使用函数进行计算，尽量避免可变状态和副作用。",
      "**函数是一等公民：函数可以像变量一样传递、返回、赋值。** **避免共享状态：数据不可变，改变数据会产生新副本。** **组合函数：通过小函数组合形成大函数。**",
      "| 概念 | 说明 | 示例（JS） | | ------------------------------- | --------------------- | ----------------------------------------------------------------- | | **纯函数（Pure Function）** | 相同输入，永远得到相同输出，不修改外部状态 | `const add = (a,b) => a+b;` | | **不可变数据（Immutable）** | 数据不被修改，每次操作返回新对象/数组 | `const newArr = [...arr, 4];` | | **高阶函数（Higher-Order Function）** | 函数作为参数或返回值 | `arr.map(x => x*2)` | | **函数组合（Function Composition）** | 小函数组合形成复杂逻辑 | `const f = x => x+1; const g = x => x*2; const h = x => g(f(x));` | | **递归（Recursion）** | FP 常用代替循环 | `const factorial = n => n<=1?1:n*factorial(n-1);` | | **不可变状态与副作用控制** | 避免修改全局变量 | 使用 `map`, `filter`, `reduce` |"
    ],
    "reference": "/myKMS/interview/index#_15-函数式编程",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 55,
    "question": "js如何统计长任务时间、长任务执行次数",
    "answer": [
      "**当主线程（Main Thread）执行某个任务超过 50ms**，它就被标记为一个 “Long Task”。",
      "浏览器提供了 PerformanceObserver 接口，监听类型为 \"longtask\" 的性能条目。",
      "```\n\nlet longTaskCount = 0;\nlet totalLongTaskTime = 0;\n\nif ('PerformanceObserver' in window) {\n  const observer = new PerformanceObserver((list) => {\n    list.getEntries().forEach(entry => {\n      // 每个 entry 表示一个长任务\n      longTaskCount++;\n      totalLongTaskTime += entry.duration;\n\n      console.log(`[LongTask] ${entry.name} 耗时 ${entry.duration.toFixed(2)}ms`);\n      console.log('来源：', item.name, '类型：', item.entryType, 'URL：', item.containerSrc);\n    });\n  });\n\n  observer.observe({ entryTypes: ['longtask'] });\n}\n\n\n```"
    ],
    "reference": "/myKMS/interview/index#_16-js如何统计长任务时间、长任务执行次数",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 56,
    "question": "如何禁止别人调试自己的前端页面代码?",
    "answer": [
      "代码混淆 & 压缩 (obfuscation / minification)",
      "不提供／禁用 source-map 在生产环境",
      "检测 DevTools 或控制台开启并做限制 无限 debugger, 定时器内无限 debugger, 打卡DevTools 就会无限DevTools 无限 debugger 代码 加密 混淆, 用 eval 执行 判断宽高变化",
      "将核心逻辑或敏感信息放到服务端执行",
      "限制 API／资源访问，通过认证、授权、接口防滥用"
    ],
    "reference": "/myKMS/interview/index#_18-如何禁止别人调试自己的前端页面代码",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 57,
    "question": "web 系统里面， 如何对图片进行优化？",
    "answer": [
      "总体目标: **以 最小的文件体积、最快的加载速度、最好的视觉质量 呈现图片。** 图片优化是提升用户体验、提高网站性能、减少流量消耗和增加搜索引擎曝光度的关键因素。",
      "| 优化方向 | 关键手段 | 说明 | | ------------- | ----------------------- | ------------- | | 1️⃣ 格式优化 | WebP / AVIF / SVG 等新格式 | 减少体积，兼容回退 | | 2️⃣ 压缩优化 | 无损 / 有损压缩 | 使用工具或 CI 自动处理 | | 3️⃣ 尺寸优化 | 响应式图片（`srcset`） | 按设备分发合适大小 | | 4️⃣ 缓存优化 | HTTP 缓存 + CDN 缓存 | 减少重复加载 | | 5️⃣ 加载优化 | 懒加载 / 占位图 | 减少首屏压力 | | 6️⃣ 传输优化 | CDN 加速 + Brotli/Gzip 压缩 | 优化网络传输层 | | 7️⃣ 渲染优化 | 使用 CSS / SVG 替代位图 | 减少渲染消耗 | | 8️⃣ 预加载与优先级控制 | preload / fetchpriority | 优化关键资源加载顺序 |",
      "格式优化：选对图片格式",
      "| 类型 | 适用场景 | 优点 | 缺点 | | --------------- | ------- | -------------- | ------------ | | **JPEG** | 照片、复杂色彩 | 体积小 | 有损压缩 | | **PNG** | 图标、透明图 | 无损 | 体积大 | | **SVG** | 矢量图、图标 | 无限放大不失真 | 不适合照片 | | **WebP** | 通用 | 小体积 + 透明 + 动图 | 旧浏览器兼容性较差 | | **AVIF** | 下一代格式 | 比 WebP 再小 20%+ | 解码慢，部分浏览器不支持 | | **GIF → video** | 动图替换 | 用 MP4 / WebM | 体积更小，流畅度高 | **使用 WebP**",
      "性能监控与指标追踪",
      "| 指标 | 说明 | 监控方式 | | ---------------------------------- | ----------- | --------------------- | | **LCP (Largest Contentful Paint)** | 首屏最大图片加载时间 | `PerformanceObserver` | | **CLS (Cumulative Layout Shift)** | 图片未占位导致布局抖动 | 预设宽高可避免 | | **Image Decode Time** | 解码耗时 | `PerformanceEntry` |",
      "**“新格式、小体积、延迟加载、缓存稳、动态转。”** 即：WebP/AVIF + 压缩 + LazyLoad + CDN + 缓存。"
    ],
    "reference": "/myKMS/interview/index#_19-web-系统里面-如何对图片进行优化",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 58,
    "question": "后端一次性返回树形结构数据，数据量非常大, 前端该如何处理？",
    "answer": [
      "**“只渲染用户当前可见的部分 + 按需加载或异步展开 + 高效数据结构存取”**",
      "| 目标 | 核心思路 | 实现方式 | | -------- | ------------ | ----------------------------------- | | 降低初始渲染压力 | 懒加载、虚拟化 | 按需展开、按需渲染 | | 优化渲染性能 | 虚拟滚动、diff 优化 | react-window / vue-virtual-scroller | | 优化数据结构 | 扁平化存储 | Map + parent/children 索引 | | 提升交互性能 | 异步渲染 / 分片渲染 | requestIdleCallback + 分批渲染 | | 资源分块 | 分页 / 分层加载 | 后端分页返回子节点 |",
      "后端按需返回 前端仅请求需要展开的节点子树 虚拟滚动 即使数据全在内存中，也只渲染可视范围内的节点 数据扁平化 + Map 索引结构 将嵌套树结构转成扁平表结构，快速查找与局部更新。 分片渲染（Chunk Rendering） 当必须一次性渲染大量节点时，用时间分片让主线程喘口气 😮 Worker 分线程解析数据 在后台线程中解析 / 扁平化树，主线程只负责渲染",
      "**“懒加载、虚拟化、扁平存、分片渲、后台解。”**"
    ],
    "reference": "/myKMS/interview/index#_20-后端一次性返回树形结构数据-数据量非常大-前端该如何处理",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 59,
    "question": "你认为组件封装的一些基本准则是什么？",
    "answer": [
      "组件封装的一些基本准则包括： 1. 单一职责原则：一个组件应该具有单一的功能，并且只负责完成该功能，避免组件过于庞大和复 杂。 2. 高内聚低耦合：组件内部的各个部分之间应该紧密相关，组件与其他组件之间应该尽量解耦，减少 对外部的依赖。 3. 易用性：组件应该易于使用，提供清晰的接口和文档，使用户能够方便地使用组件。 4. 可扩展性：组件应该具有良好的扩展性，能够方便地添加新的功能或进行修改，同时不影响已有的 功能。 5. 可重用性：组件应该是可重用的，能够在多个项目中使用，减少重复开发的工作量。 6. 高效性：组件应该具有高性能和低资源消耗的特点，不会成为整个系统的性能瓶颈。 7. 安全性：组件应该具有安全性，能够防止恶意使用或攻击。 8. 可测试性：组件应该容易进行单元测试和集成测试，以保证组件的质量和稳定性"
    ],
    "reference": "/myKMS/interview/index#_21-你认为组件封装的一些基本准则是什么",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 60,
    "question": "组件升级怎么让使用这个组件的人都知道。",
    "answer": [
      "语义化版本, 安装依赖自动升级 对接机器人, 群通知, 邮件通知 组件库加入运行时代码, 进行可版本检测, 不是最新时通知 文档更新 当面通知"
    ],
    "reference": "/myKMS/interview/index#_22-组件升级怎么让使用这个组件的人都知道。",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 61,
    "question": "如果让你设计项目自动设计组件升级，并且安全，你会怎么去设计",
    "answer": [
      "```\n\n组件库发布\n   │\n   ├─ 生成 CHANGELOG\n   ├─ 更新远程版本记录\n   │\n项目启动 / 构建\n   │\n   ├─ 自动检测组件版本\n   │\n   ├─ 判断安全性（PATCH / MINOR / MAJOR）\n   │\n   ├─ 控制台 / UI 提醒开发者\n   │\n   └─ 开发者选择：\n        ├─ 自动升级（安全）\n        └─ 手动升级（MAJOR）\n   │\n升级完成 → 自动记录版本 → 支持回滚\n\n```"
    ],
    "reference": "/myKMS/interview/index#_23-如果让你设计项目自动设计组件升级-并且安全-你会怎么去设计",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 62,
    "question": "前端 sourcemap原理",
    "answer": [
      "在现代前端构建后变成浏览器可执行的 压缩/混淆后的 JS、CSS 文件,如果出错，根本找不到源文件对应的行。于是引入 Source Map（源码映射文件） 来解决这个问题。",
      "Source Map: **它本质上是一个 JSON 文件，记录了编译后代码和原始源码之间的 映射关系。**",
      "| 字段名 | 含义 | | ------------------ | -------------------------- | | **version** | Source Map 规范版本，目前是 3 | | **file** | 生成的文件名（编译后的） | | **sources** | 源文件路径列表（相对路径或绝对路径） | | **sourcesContent** | 源文件内容（可选，便于调试） | | **names** | 所有符号名（变量、函数名） | | **mappings** | 最关键的部分！记录了 “编译后 → 源代码” 的映射 |",
      "mappings 字段的核心 —— VLQ 编码",
      "mappings 是一串非常长的字符串（例如 \"AAAAA,QAAQC,IAAI,CAAC\"），它是使用 Base64 VLQ（Variable Length Quantity） 编码的。",
      "这一串编码可以还原出：",
      "目标文件的行、列； 对应的源文件 index； 源文件的行、列； 对应符号的 index（在 names 中）。",
      "浏览器调试原理",
      "当你打开 DevTools 并加载一个带有 //# sourceMappingURL 的文件时： 浏览器读取 .map 文件； 根据 mappings 表恢复出源文件与压缩文件之间的映射； 如果 sourcesContent 存在，则直接显示源码； 否则请求原始 .ts/.jsx 文件； 当断点或错误发生时，浏览器通过映射表将位置还原到源代码行列。"
    ],
    "reference": "/myKMS/interview/index#_24-前端-sourcemap原理",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 63,
    "question": "摘要和加密?",
    "answer": [
      "| 概念 | 功能 | 可逆性 | | ------------------ | ---------------------- | --------- | | **摘要（Hash）** | 把任意长度数据映射为固定长度“指纹” | ❌ 不可逆 | | **加密（Encryption）** | 保护数据机密性，转换成只有授权方能还原的密文 | ✅ 可逆（需密钥） |",
      "摘要算法（Hash Function）是指一种 单向函数：把输入（任意长度）转成一个固定长度的输出（摘要）。 原文 → 哈希函数 → 摘要",
      "特点： 同样输入 → 永远同样输出； 不同输入 → 几乎不可能得到相同输出； 不能从输出反推出输入（单向不可逆）。",
      "常见算法：MD5（已不安全）;SHA-1（不安全）;SHA-256、SHA-512;BLAKE3（新一代高性能)",
      "加密算法 是可逆的，用来保证数据机密性。",
      "明文 + 密钥 → 加密算法 → 密文 密文 + 密钥 → 解密算法 → 明文",
      "特点： 可逆（只要有密钥）； 主要目标是保密； 输入和输出都是数据； 对称/非对称两类。",
      "| 类比 | 摘要（Hash） | 加密（Encryption） | | -------- | ------------------------ | -------------- | | 📄 功能 | 生成数据指纹 | 隐藏数据内容 | | 🔁 可逆性 | 不可逆 | 可逆（需密钥） | | 🔑 是否用密钥 | 否 | 是 | | 📏 输出长度 | 固定 | 可变 | | 🧱 典型算法 | SHA256, MD5 | AES, RSA | | 🎯 应用场景 | 密码校验、完整性验证 | 安全通信、存储加密 | | 🧮 举例 | 登录验证：`hash(password)` 对比 | HTTPS 加密传输 |",
      "| 类别 | 是否使用相同密钥 | 示例 | | --------------------------------- | ---------------- | ------------------------- | | **对称加密 (Symmetric Encryption)** | 加密和解密使用同一个密钥 | AES、DES、3DES、RC4、ChaCha20 | | **非对称加密 (Asymmetric Encryption)** | 使用一对密钥：公钥加密、私钥解密 | RSA、ECC、ElGamal |",
      "对称加密算法: 加密与解密都用 同一把密钥； 加密速度快、效率高； 适合大量数据加密（如文件、数据库、通信内容）； 缺点：密钥分发困难（如何安全地给对方密钥？）。",
      "非对称加密算法: 使用 一对密钥： 公钥 (Public Key)：可公开，用于加密； 私钥 (Private Key)：仅持有人拥有，用于解密。 不需要共享密钥； 运算复杂、速度慢； 常用于：密钥交换、数字签名、身份验证。",
      "| 场景 | 使用算法 | 说明 | | ---------- | ------------------------- | ----------- | | HTTPS | RSA/ECC + AES-GCM | 密钥交换 + 传输加密 | | JWT 签名 | HMAC-SHA256 / RSA / ECDSA | 防伪造 | | 文件加密 | AES-256-CBC | 高效安全 | | 数据库加密 | AES / ChaCha20 | 保密性 | | 区块链地址生成 | ECC (secp256k1) | 公私钥体系 | | SSH、Git 签名 | RSA / Ed25519 | 身份认证 | | 数字签名 | RSA-SHA256 / ECDSA | 不可否认性 |"
    ],
    "reference": "/myKMS/interview/index#_25-摘要和加密",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 64,
    "question": "Web 无障碍性",
    "answer": [
      "Web 无障碍性（Accessibility） 指的是：让所有用户（包括视障、听障、行动不便者等）都能平等访问网站内容和功能。",
      "就是： 屏幕阅读器（Screen Reader）能正确朗读网页； 键盘用户能操作交互； 色盲或低视力用户也能识别视觉信息",
      "ARIA（Accessible Rich Internet Applications） 是一组 HTML 属性，用于让无障碍工具（如屏幕阅读器）能理解网页中的“语义”和“状态”。",
      "| 类型 | 示例 | 说明 | | ----------------- | ----------------------- | ------------------- | | **role** | `role=\"button\"` | 定义元素角色（告诉屏幕阅读器这是什么） | | **aria-label** | `aria-label=\"关闭窗口\"` | 给无文本元素提供可读名称 | | **aria-hidden** | `aria-hidden=\"true\"` | 告诉辅助设备忽略此元素 | | **aria-disabled** | `aria-disabled=\"true\"` | 表示该元素被禁用 | | **aria-expanded** | `aria-expanded=\"true\"` | 表示菜单或折叠面板是否展开 | | **aria-checked** | `aria-checked=\"true\"` | 复选框、单选框当前选中状态 | | **aria-controls** | `aria-controls=\"menu1\"` | 指定当前元素控制的另一个元素 | | **aria-live** | `aria-live=\"polite\"` | 告诉屏幕阅读器动态区域更新方式 |",
      "**Web 无障碍性（a11y） = 语义化 HTML + 正确的 ARIA 属性 + 键盘支持 + 可感知状态。**"
    ],
    "reference": "/myKMS/interview/index#_26-web-无障碍性",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 65,
    "question": "如何实现一个模块加载器？请描述其基本原理。",
    "answer": [
      "“模块加载器”是 JavaScript 模块化体系的核心基础之一。无论是 CommonJS (Node.js)、AMD (RequireJS)、ESM (import/export)，它们的本质都是在做同一件事：**按需加载模块、解析依赖、执行模块代码、缓存结果。**",
      "模块加载器的目标: | 问题 | 说明 | | -------------- | --------------------------------------- | | **1. 模块定义** | 支持定义模块（如 `define(name, deps, factory)`） | | **2. 模块加载** | 能加载依赖模块（可能是异步或同步） | | **3. 模块执行与缓存** | 执行模块代码、导出结果，并缓存避免重复执行 |",
      "```js\n// 模块表（缓存）\nconst modules = {};      // 模块名 -> 导出对象\nconst factories = {};    // 模块名 -> 模块定义函数\nconst loading = {};      // 模块名 -> 是否正在加载中\n\n// 定义模块\nfunction define(name, deps, factory) {\n  factories[name] = { deps, factory };\n}\n\ndefine('math', [], function() {\n  return {\n    add(a, b) { return a + b; }\n  };\n});\n\n\n// 加载模块\nfunction require(name) {\n  // 已加载则直接返回\n  if (modules[name]) return modules[name];\n  if (!factories[name]) throw new Error(`${name} not found`);\n\n  const { deps, factory } = factories[name];\n\n  // 加载依赖\n  const args = deps.map(require);\n\n  // 执行工厂函数\n  const moduleExports = factory.apply(null, args);\n\n  // 缓存结果\n  modules[name] = moduleExports;\n\n  return moduleExports;\n}\n\n\ndefine('main', ['math'], function(math) {\n  console.log(math.add(1, 2)); // 3\n});\n// 使用\nrequire('main');\n\n```",
      "```scss\nrequire('main')\n   │\n   ├─▶ 检查缓存\n   │\n   ├─▶ 找到定义 (factory)\n   │\n   ├─▶ 加载依赖 ['math']\n   │        │\n   │        └─▶ 递归 require('math')\n   │\n   ├─▶ 执行 factory 函数\n   │\n   └─▶ 缓存并返回 exports\n\n```",
      "浏览器和 Node.js 都有内建的模块加载器：ESM 的核心是 静态依赖图（在编译阶段就能分析依赖），而不是像 CommonJS 那样运行时动态解析。",
      "内部流程：",
      "解析 import/export，建立依赖图",
      "递归加载依赖模块",
      "创建 Module Record（记录导出值）",
      "执行模块初始化代码",
      "缓存结果供其他模块共享",
      "模块加载器的核心思想就是：",
      "**依赖解析 → 执行工厂函数 → 导出缓存 → 共享结果。**"
    ],
    "reference": "/myKMS/interview/index#_27-如何实现一个模块加载器-请描述其基本原理。",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 66,
    "question": "前端架构和前端工程化有什么区别",
    "answer": [
      "前端架构和前端工程化是两个不同的概念，但它们之间有一些相互关联的特点。",
      "前端架构是指在前端开发中，对整个前端应用程序的组织结构、模块划分、框架选择等方面的设计和规划。前端架构的目标是为了提高代码的可维护性、可扩展性和可重用性，以及优化前端应用程序的性能和用户体验。常见的前端架构包括MVC（Model-View-Controller）、MVVM（Model-View-ViewModel）等。",
      "前端工程化是指使用各种工具、技术和流程对前端开发过程进行管理和优化，以提高开发效率、代码质量和团队协作能力。前端工程化的目标是通过规范化和自动化的方式，解决前端开发中的重复劳动、低效率、代码质量不稳定等问题。前端工程化包括代码管理、代码规范、模块化开发、构建工具、自动化测试、持续集成和部署、性能优化、文档和知识管理等方面。",
      "虽然前端架构和前端工程化是两个不同的概念，但它们之间存在一些相似的目标和方法。前端架构关注的是前端应用程序的结构和设计，而前端工程化关注的是前端开发的流程和工具的使用。前端架构可以通过前端工程化的方式实现，而前端工程化可以提供支持和保障，以实现良好的前端架构。"
    ],
    "reference": "/myKMS/interview/index#_28-前端架构和前端工程化有什么区别",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 67,
    "question": "monorepo",
    "answer": [
      "Monorepo（Mono Repository） 指的是 将多个项目（模块、包、服务）放在同一个代码仓库中进行管理，而不是每个项目单独一个仓库（Polyrepo）。",
      "核心理念：**一个仓库管理多个相关或不相关项目，统一版本控制和依赖管理。**",
      "| 优点 | 说明 | | ----------- | ------------------------- | | **统一依赖管理** | 所有项目共享依赖，避免重复安装、版本冲突 | | **跨项目协作方便** | 修改一个底层库时，可以同步更新依赖它的其他模块 | | **统一构建和测试** | 可以通过 CI/CD 一次性构建或测试多个模块 | | **代码复用** | 公共模块直接引用，不必发布到 npm/私有包管理器 | | **版本管理统一** | 可以统一发布版本策略，例如所有模块同时升级 |",
      "| 缺点 | 说明 | | ---------- | -------------------- | | **仓库体积大** | 随着项目增多，克隆和拉取时间增长 | | **构建复杂** | 需要按需构建，避免每次都构建所有项目 | | **权限管理复杂** | 有些模块可能需要不同团队权限 | | **工具要求高** | 需要工具支持依赖分析、构建优化、版本控制 |",
      "lerna:",
      "核心功能是帮助你在一个仓库里管理多个 npm 包，实现：",
      "依赖安装自动化 包版本管理 跨包引用管理 发布流程自动化",
      "Lerna 有两种主要模式：",
      "Fixed/Locked Mode（固定版本模式）",
      "所有包使用统一版本号 发布时，所有包版本同时更新 适合 tightly coupled 的包集合",
      "Independent Mode（独立版本模式）",
      "每个包可以独立版本 修改哪个包就只发布那个包 适合 loosely coupled 的包集合",
      "Lerna 的主要功能:",
      "| 功能 | 描述 | | ------------- | --------------------------------------------- | | **Bootstrap** | 自动安装包依赖，并建立跨包链接（link） | | **Publish** | 发布包到 npm（支持固定或独立模式） | | **Version** | 管理版本号更新（支持语义化版本 SemVer） | | **Exec** | 在所有包里执行命令，例如 `npm test` | | **Run** | 在指定包中运行脚本，例如 `lerna run build --scope ui-lib` | | **Diff** | 显示自上次发布以来修改过的包 |"
    ],
    "reference": "/myKMS/interview/index#_29-monorepo",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 68,
    "question": "很多web前端框架里面会有约定式路由， 他们是如何实现的",
    "answer": [
      "约定式路由（Convention over Configuration，CoC）是现代前端框架（如 Next.js、Nuxt.js、VitePress 等）广泛采用的路由实现方式，其核心思想是**根据文件目录结构自动生成路由配置，无需手动编写冗长的路由表**。",
      "核心原理: 约定式路由通过以下步骤工作：",
      "文件系统扫描：框架在构建或运行时遍历指定目录（如pages/），获取所有文件和文件夹结构。 路径映射规则：将文件路径转换为路由路径，例如： pages/index.js → / pages/posts/[id].js → /posts/:id（动态路由） 路由配置生成：根据映射规则生成路由配置对象（如 React Router 或 Vue Router 所需的格式）。 运行时匹配：在用户访问时，根据 URL 匹配对应的组件。"
    ],
    "reference": "/myKMS/interview/index#_30-很多web前端框架里面会有约定式路由-他们是如何实现的",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 69,
    "question": "前端代码中有太多的if 如何处理?",
    "answer": [
      "使用 映射表（对象字典） 用对象代替多层 if/else，让类型和行为解耦。",
      "使用 策略模式（Strategy Pattern） 当每种类型逻辑复杂，不仅仅是组件时，就可以用策略模式。",
      "多态（Class继承）+ 工厂模式 当类型之间有共性逻辑时，使用继承比 if 更优雅。",
      "状态机（State Machine） 如果 if 是基于“状态流转”的, 可以改为状态机"
    ],
    "reference": "/myKMS/interview/index#_31-前端代码中有太多的if-如何处理",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 70,
    "question": "大图片瓦片机制",
    "answer": [
      "「大图片瓦片机制」（Image Tiling System）是前端中处理 超高分辨率图片（例如病理切片、卫星地图、天文影像、艺术画高清扫描）的关键技术。",
      "直接加载一张图片会网络过大,内存不够,渲染慢,体验查",
      "瓦片机制的目标：**“只加载并渲染当前视口内需要的部分图像。”**",
      "核心思想：把超大图片预处理成**分层（多分辨率）+ 分块（瓦片）**的小图像块。浏览器只按需加载这些小块（tile），在画布上拼接显示。",
      "核心原理：金字塔多分辨率结构（Image Pyramid）和地图瓦片完全一样，只是坐标不再是经纬度，而是像素坐标。",
      "假设原始图片是 16384 × 16384：每层都是一个缩放版本的图片，每层都切割成若干瓦片（tile）。",
      "| 层级 | 缩放比例 | 尺寸 | 瓦片数 (256px 一块) | | -- | ---- | ------------- | -------------- | | L0 | 1/16 | 1024 × 1024 | 4×4 | | L1 | 1/8 | 2048 × 2048 | 8×8 | | L2 | 1/4 | 4096 × 4096 | 16×16 | | L3 | 1/2 | 8192 × 8192 | 32×32 | | L4 | 1 | 16384 × 16384 | 64×64 |",
      "瓦片命名与存储规则:`/tiles/{level}/{row}_{col}.jpg` 如: `/tiles/4/12_22.jpg` 表示：第 4 层（最高分辨率）;第 12 行、第 22 列 的瓦片。",
      "前端加载逻辑（核心算法）",
      "1. 根据缩放层级选择图层 根据当前 zoom（或 scale）选择最合适的分辨率层级。zoom 越大 → 层级越高 → 图片越清晰。",
      "2. 根据视窗范围计算需要的瓦片索引 -",
      "异步加载 + 合成渲染",
      "缩放/平移/旋转处理 img 渲染再 canvas 上, 结合矩阵变换实现平滑交互",
      "| 优化方向 | 技术点 | | ---- | ------------------------------- | | 网络优化 | 延迟加载 + LRU 缓存 + 并发控制 | | 渲染优化 | OffscreenCanvas 或 WebGL 纹理合成 | | 内存控制 | 限制在屏瓦片数量（例如 9×9 可见区域） | | 模糊预览 | 先加载低分辨率层，再加载高分辨率瓦片 | | 分帧渲染 | 使用 `requestAnimationFrame` 批次绘制 | | 旋转优化 | 旋转矩阵缓存，避免全图重绘 |",
      "实践中采用 OpenSeadragon 库",
      "```\n ┌─────────────────────────────┐\n │         大图瓦片浏览器         │\n │                             │\n │  ┌──────────────┐            │\n │  │视窗视口(Viewport)│  ← 仅渲染屏幕内的瓦片 │\n │  └──────┬──────┘            │\n │         │计算可见区域           │\n │         ▼                     │\n │  ┌────────────────────┐       │\n │  │   瓦片管理器(TileManager)│← 负责加载/缓存 |\n │  └──────┬────────────┘       │\n │         │网络请求             │\n │         ▼                     │\n │  ┌────────────────────┐       │\n │  │   瓦片缓存(TileCache) │← LRU 缓存机制 |\n │  └────────────────────┘       │\n └─────────────────────────────┘\n\n```"
    ],
    "reference": "/myKMS/interview/index#_32-大图片瓦片机制",
    "source": "/myKMS/interview/index"
  },
  {
    "id": 71,
    "question": "vue 编译到小程序等原理",
    "answer": [
      "Vue 本身是一个 前端框架，它的运行环境是浏览器，依赖 DOM API。小程序环境（如微信小程序）是 非浏览器环境，没有 DOM，取而代之的是 小程序的组件体系（如 view, text, image 等）和 小程序 JS 运行环境（WXML + WXSS + JS）。",
      "核心原理:",
      "1. 模板编译 Vue 的模板（`<template>`）最终会被编译成 渲染函数。 在小程序环境下： Vue 模板会被转换成 小程序的 WXML。 Vue 的指令（v-if, v-for, v-bind 等）会被转换成对应的小程序指令： v-for → wx:for v-if → wx:if v-bind:xxx → 对应绑定写法 这个过程就是 模板转换器（template compiler）",
      "2. 组件映射",
      "Vue 组件 → 小程序自定义组件",
      "需要做的事情：",
      "生成 JSON 配置文件（小程序每个组件/页面需要 component.json 或 page.json） 生成 WXML 模板 生成 JS 逻辑文件，小程序的 JS 运行环境有限，所以需要把 Vue 的响应式、事件等改写成小程序的方式。",
      "3. 响应式系统适配",
      "Vue 通过 Proxy/Observer 做响应式，渲染到 DOM。",
      "小程序没有 DOM，需要手动触发更新。",
      "所以 Vue-to-mini-program 框架通常会： 在数据变动时调用 setData（小程序的状态更新 API） setData 是小程序的核心，更新 WXML Vue 响应式的数据变动 → 自动映射到 setData 调用",
      "注意：setData 有性能限制（不要更新太大对象），所以很多框架会 做脏检查或数据扁平化。",
      "4. 生命周期映射",
      "编译流程概览:",
      "1. 解析 SFC（Single File Component） template → AST script → JS style → CSS / WXSS",
      "2. 模板编译 AST → WXML 指令和事件转换（v-on → bindtap）",
      "3. 逻辑处理 Vue 响应式系统 → 小程序 data + setData 方法 → 小程序 JS 方法绑定",
      "4. 样式转换 CSS → WXSS Scoping / 样式命名空间处理",
      "5. 输出小程序目录",
      "page.js, page.wxml, page.wxss, page.json component.js, component.wxml, component.wxss, component.json",
      "6. 打包",
      "工具（webpack / vite / cli）打包 JS 输出小程序可识别的目录结构",
      "| 框架 | 原理与特点 | | --------- | -------------------------------------------- | | mpvue | Vue 2 → 小程序，用 Vue 的 render + setData | | uni-app | 支持 Vue 2/3，跨端输出（小程序、H5、App），模板和指令转换 + API 封装 | | Taro | React 风格 → 多端小程序，核心是抽象组件 + 生命周期 + API 适配 | | Vue3-mini | Vue3 composition API + 响应式 → setData |",
      "核心就是三件事：",
      "模板编译 → Vue template → WXML",
      "响应式适配 → Vue 响应式 → 小程序 setData",
      "-生命周期和 API 映射 → Vue 生命周期 +事件 → 小程序生命周期+事件",
      "⚡ 核心瓶颈：",
      "setData 性能",
      "样式隔离",
      "组件递归 / 动态组件"
    ],
    "reference": "/myKMS/knowledge/base/app#_1-vue-编译到小程序等原理",
    "source": "/myKMS/knowledge/base/app"
  },
  {
    "id": 72,
    "question": "CSS怎么隐藏一个元素，对回流和重绘的隐藏，对事件响应机制的影响",
    "answer": [
      "| 隐藏方式 | 是否占位 | 回流 | 重绘 | 事件响应 | 性能特点 | 推荐使用场景 | | ----------------------------------- | ---- | -- | -- | ------- | ------------ | ------------------ | | `display: none` 元素彻底从渲染树中移除。 | ❌ | ✅ | ✅ | ❌ | 删除渲染树节点，性能稍重 | 元素彻底移除（如 Tab 切换） | | `visibility: hidden` 元素依然在文档流中，只是视觉上“不可见”。 | ✅ | ❌ | ✅ | ❌ | 保留布局结构 | 占位但不可见（如占位动画） | | `opacity: 0` 仅透明度为 0，但仍在渲染树中。 | ✅ | ❌ | ✅ | ✅ | 仅重绘 | 视觉隐藏但仍可交互（如淡入淡出动画） | | `position: absolute; left: -9999px` 通过把元素移出可视区域达到隐藏效果。 | ❌ | ✅ | ✅ | ❌ | 性能中等 | 屏幕外隐藏（SEO / 辅助阅读） | | `pointer-events: none` | ✅ | ❌ | ❌ | ❌ | 无重绘 | 禁用交互，常与 opacity 结合 | | `transform: scale(0)` 图形级裁剪或缩放。 | ✅ | ❌ | ✅ | ⚠️ 可能响应 | GPU 加速 | 动画过渡中隐藏 |"
    ],
    "reference": "/myKMS/knowledge/base/css#_5-css怎么隐藏一个元素-对回流和重绘的隐藏-对事件响应机制的影响",
    "source": "/myKMS/knowledge/base/css"
  },
  {
    "id": 73,
    "question": "href 和 src",
    "answer": [
      "| 维度 | href | src | | -------- | -------------------------------------- | ------------------------------------------------- | | **核心作用** | 表示资源的“引用”或目标地址 | 表示资源的“来源”，立即下载和渲染 | | **立即加载** | 不会立即加载资源（除非 `<link rel=\"stylesheet\">`） | 浏览器会立即请求资源 | | **典型元素** | `<a>`、`<link>`、`<area>` | `<img>`、`<script>`、`<iframe>`、`<audio>`、`<video>` | | **渲染阻塞** | 不阻塞页面渲染（普通 `<a>`） | `<script>` 会阻塞渲染（同步） | | **导航作用** | 用于跳转或引用外部文档 | 用于插入资源，页面不跳转 | | **事件触发** | 点击 `<a>` 才触发请求 | 插入 DOM 元素时就触发请求 | | **可重用性** | 可用于预加载（如 `<link rel=\"preload\">`） | 每个 `src` 元素只用于一个资源 |"
    ],
    "reference": "/myKMS/knowledge/base/css#_6-href-和-src",
    "source": "/myKMS/knowledge/base/css"
  },
  {
    "id": 74,
    "question": "JS 闭包，如何理解",
    "answer": [
      "什么是闭包？ **闭包是指一个函数能够记住并访问其词法作用域中的变量，即使该函数在其词法作用域之外执行。**",
      "简单来说：**当一个函数内部定义了另一个函数，并且内部函数引用了外部函数的变量，就创建了一个闭包。**",
      "闭包的实际应用",
      "创建私有变量 在循环中使用闭包(解决引用问题) 模块模式",
      "闭包的工作原理 JavaScript 的作用域链机制使得闭包成为可能：",
      "每个函数在创建时都会保存对其词法环境的引用 当函数执行时，它会沿着作用域链查找变量 即使外部函数执行完毕，只要内部函数仍然存在，外部函数的变量就不会被垃圾回收",
      "闭包风险",
      "内存泄漏风险 ( 在不需要时手动解除引用) 性能考虑 过度使用闭包可能会影响性能，因为：需要维护额外的作用域链;变量查找时间可能增加;",
      "闭包本质上是：**函数 + 其定义时的词法作用域（作用域链的引用）**"
    ],
    "reference": "/myKMS/knowledge/base/js#_1-js-闭包-如何理解",
    "source": "/myKMS/knowledge/base/js"
  },
  {
    "id": 75,
    "question": "描述 Event Loop 运行机制",
    "answer": [
      "1. 背景 JavaScript 是 单线程 的：同一时刻只能执行一个任务。但浏览器/Node 需要同时处理用户输入、网络请求、定时器、渲染等。 👉 为了解决“同时处理多任务”的需求，JS 引入了 事件循环（Event Loop） 机制。",
      "Event Loop（事件循环）是 JavaScript 处理 异步操作 的核心机制。它允许 JavaScript 以 非阻塞 的方式执行代码，即使遇到 I/O 操作（如网络请求、定时器），也不会影响主线程继续执行其他任务。",
      "三个核心关键概念",
      "Call Stack（调用栈） JS 引擎执行代码时，按照函数调用的嵌套关系入栈/出栈。同步代码按顺序直接在栈中运行。 Task Queue（任务队列） 异步任务完成后，将回调放入队列，等待主线程空闲时取出执行。 Event Loop（事件循环） 事件循环不断检查调用栈是否为空，如果为空，就从队列取出一个任务放入栈中执行。这个过程周而复始。",
      "JS 中的任务按优先级分为 宏任务（Macrotask） 和 微任务（Microtask）。",
      "宏任务（Macrotask） 整体脚本 script setTimeout / setInterval setImmediate（Node） I/O 回调 UI 渲染 JS 中用户输入（如 click、input、keydown 等 DOM 事件的回调）",
      "微任务（Microtask） Promise.then / catch / finally queueMicrotask MutationObserver（浏览器） process.nextTick（Node）",
      "规则： 每轮事件循环：",
      "执行一个宏任务 执行所有微任务（直到清空微任务队列） 渲染（浏览器） 开始下一轮循环",
      "**同步先执行，异步分队列；先宏后微，再渲染。**",
      "Node.js：",
      "**process.nextTick 优先级高于 Promise 微任务**"
    ],
    "reference": "/myKMS/knowledge/base/js#_2-描述-event-loop-运行机制",
    "source": "/myKMS/knowledge/base/js"
  },
  {
    "id": 76,
    "question": "网页多标签页之间如何通讯？和 iframe 如何通讯？",
    "answer": [
      "| 特性 | `BroadcastChannel` | `localStorage` + `storage` 事件 | `postMessage` + iframe / worker | | --------- | ------------------ | ----------------------------- | ------------------------------- | | 是否需要刷新 | 否 | 否 | 否 | | 是否支持多 Tab | ✅ | ✅ | 部分（需要 iframe/worker） | | 是否易用 | ✅（直接发送消息） | 中等（需要 JSON 序列化） | 较复杂（需建立通道） | | 是否跨域 | ❌（只能同源） | ❌ | 可跨域（需正确设置 targetOrigin） | | 性能 | 较好 | 一般（依赖 storage 事件） | 较好 |"
    ],
    "reference": "/myKMS/knowledge/base/js#_3-网页多标签页之间如何通讯-和-iframe-如何通讯",
    "source": "/myKMS/knowledge/base/js"
  },
  {
    "id": 77,
    "question": "前端常见的设计模式有哪些？以及应用场景",
    "answer": [
      "| 模式类型 | 设计模式 | 定义 / 核心思想 | 前端典型应用场景 | | -------- | ----------------- | ------------------------ | -------------------------------------- | | **创建型** | 工厂模式（Factory） | 用一个工厂方法创建对象，解耦对象创建和使用 | 组件库动态创建组件（ButtonFactory）、Axios 不同配置实例 | | | 单例模式（Singleton） | 保证类只有一个实例，并提供全局访问 | 全局 Store（Redux/Pinia）、全局弹窗/通知、全局缓存 | | **结构型** | 装饰器模式（Decorator） | 不改变对象本身，动态给对象添加功能 | React 高阶组件（HOC）、TS 装饰器、函数增强（日志、权限） | | | 代理模式（Proxy） | 通过代理对象控制对目标对象访问 | Vue3 响应式、请求缓存、防抖/节流、懒加载 | | | 适配器模式（Adapter） | 将不兼容接口转换为可用接口 | 封装第三方 SDK、统一后端接口格式、浏览器 API 兼容 | | **行为型** | 观察者模式（Observer） | 对象状态改变时通知所有订阅者 | DOM 事件监听、Vue2 响应式依赖收集 | | | 发布订阅模式（Pub/Sub） | 将事件和回调解耦，发布者触发事件，订阅者响应事件 | Redux / Vuex 的状态更新订阅、EventBus、跨组件通信/pinia | | | 策略模式（Strategy） | 封装一系列算法，可互换 | 表单验证策略、支付方式选择、动画策略 | | | 命令模式（Command） | 将请求封装为对象，便于参数化和管理 | 富文本编辑器命令、Undo/Redo、Canvas 绘图命令 | | **前端特有** | 组合模式（Composition） | 通过组合而非继承实现功能复用 | React children、Vue 插槽（Slot）、Hooks 组合逻辑 | | | MVVM / 单向数据流 | 数据驱动视图，状态单向流动 | Vue / Angular MVVM、React + Redux |"
    ],
    "reference": "/myKMS/knowledge/base/js#_4-前端常见的设计模式有哪些-以及应用场景",
    "source": "/myKMS/knowledge/base/js"
  },
  {
    "id": 78,
    "question": "从 0 搭建一个前端项目，需要考虑哪些方面",
    "answer": [
      "主要是框架/库, 工具链 和cicd 选择",
      "技术选型：框架、状态管理、工具链、UI 组件库 项目架构：目录结构、模块化、路由、状态管理、接口管理 开发与运维：构建优化、测试、性能、安全、CI/CD"
    ],
    "reference": "/myKMS/knowledge/base/js#_6-从-0-搭建一个前端项目-需要考虑哪些方面",
    "source": "/myKMS/knowledge/base/js"
  },
  {
    "id": 79,
    "question": "ajax 并发请求控制",
    "answer": [
      "```\nasync function batchRequestAllSettled(tasks, batchSize = 5) {\n  const results = []\n\n  for (let i = 0; i < tasks.length; i += batchSize) {\n    const batch = tasks.slice(i, i + batchSize).map(fn => fn())\n    // 等待当前批次所有请求完成（成功或失败）\n    const batchResults = await Promise.allSettled(batch)\n    results.push(...batchResults)\n  }\n\n  return results\n}\n\n// 使用示例\nconst urls = Array.from({ length: 30 }, (_, i) => `https://api.example.com/data/${i}`)\nconst tasks = urls.map(url => () => fetch(url).then(res => res.json()))\n\nbatchRequestAllSettled(tasks, 5).then(results => {\n  results.forEach((res, idx) => {\n    if (res.status === 'fulfilled') console.log(`任务 ${idx} 成功`, res.value)\n    else console.log(`任务 ${idx} 失败`, res.reason)\n  })\n})\n\n```"
    ],
    "reference": "/myKMS/knowledge/base/js#_7-ajax-并发请求控制",
    "source": "/myKMS/knowledge/base/js"
  },
  {
    "id": 80,
    "question": "线上出了严重 bug 你该如何解决？",
    "answer": [
      "**先止损 → 再排查 → 然后修复 → 最后复盘防再发**",
      "第一要务: **回滚，及时止损** 通知项目组成员，看谁最近有过上线—— 线上 bug 一般是最近一次上线导致的 在本地或测试环境浮现 bug，查找原因 修复，测试，重新上线 开**复盘会议**，以后如何规避此类问题 —— 总结经验教训"
    ],
    "reference": "/myKMS/knowledge/base/js#_8-线上出了严重-bug-你该如何解决",
    "source": "/myKMS/knowledge/base/js"
  },
  {
    "id": 81,
    "question": "你如何保障代码质量？",
    "answer": [
      "配置统一的 eslint 和 prettier 规则，规范代码格式 尽量组织 code review 使用 Sentry 等平台进行线上错误报警，并及时修复问题"
    ],
    "reference": "/myKMS/knowledge/base/js#_9-你如何保障代码质量",
    "source": "/myKMS/knowledge/base/js"
  },
  {
    "id": 82,
    "question": "esm 与 CommonJS 的循环引用",
    "answer": [
      "CommonJS 模块规范在遇到循环引用时,Node 会返回当前已执行部分的 exports 对象.(Node 通过 require.cache 缓存机制避免了无限递归) ES Module（ESM）在循环引用时有“实时绑定（live binding）”机制, (静态分析 esm编译阶段就确定依赖关系，不是在运行时动态执行; 单例缓存：同一个模块只会被执行一次，并缓存结果; 实时绑定 (live binding)：import 的变量不是值拷贝，而是一个引用，对应 export 的内存位置。所以即使 export 后续被修改，import 端也能拿到最新的值。)"
    ],
    "reference": "/myKMS/knowledge/base/js#_10-esm-与-commonjs-的循环引用",
    "source": "/myKMS/knowledge/base/js"
  },
  {
    "id": 83,
    "question": "esm 中 import 会发生什么?",
    "answer": [
      "ES Module (ESM) 的 import 是编译期就确定依赖关系;ESM 默认是 严格模式，并且是 异步加载",
      "**解析阶段（Parsing）=> 加载阶段 => 实例化阶段 => 执行阶段 => 缓存** 为每个模块创建 模块环境记录（Module Environment Record），里面存放变量绑定, 实时绑定:如果 export 的值后来被修改， import 端也能感知。ESM 的缓存机制是基于 URL/路径唯一性，并且在 异步上下文中生效。 esm缓存生效场景: 同一个模块被多次 import; 循环依赖(缓存的“半成品”也会存起来，这样可以避免死循环);动态 import 多次;"
    ],
    "reference": "/myKMS/knowledge/base/js#_11-esm-中-import-会发生什么",
    "source": "/myKMS/knowledge/base/js"
  },
  {
    "id": 84,
    "question": "在 JS 代码中避免内存泄漏的方法?",
    "answer": [
      "1. 释放不再需要的引用(把对象置 null 或者移除属性，就能让 GC 正常回收。) 2. 避免全局变量 3. 小心闭包(闭包会一直保持引用,导致无法回收对象) 4. 定时器 / 事件监听要清理 5. 使用 WeakMap / WeakSet 存放临时对象 6. 避免 JSON.stringify 大对象 7. 复用对象 / 数组 8. 按需加载数据 9. 及时释放 DOM 引用"
    ],
    "reference": "/myKMS/knowledge/base/js#_12-在-js-代码中避免内存泄漏的方法",
    "source": "/myKMS/knowledge/base/js"
  },
  {
    "id": 85,
    "question": "es6 “继承在前，实例在后”?",
    "answer": [
      "new 子类发生什么: 创建子类实例对象 => 设置原型 => 父类构造函数执行 => 调用子类构造函数 => 子类构造函数继续执行 先创建空实例 → 调用子类 constructor → super() 调用父类 constructor → 父类属性挂载 → 回到子类挂载属性 → 实例返回。 ES6 的 class extends 就是对寄生组合继承的语法封装"
    ],
    "reference": "/myKMS/knowledge/base/js#_13-es6-继承在前-实例在后",
    "source": "/myKMS/knowledge/base/js"
  },
  {
    "id": 86,
    "question": "script type=\"module\" 是什么效果?",
    "answer": [
      "`<script type=\"module\">` 会 异步下载和解析，等 HTML 解析完成后执行，按依赖顺序执行模块代码，类似加了 defer 的普通脚本，但支持模块化特性。 `<script type=\"module\" async>` 异步,下载完成立即执行,不保证顺序 (适合独立模块，不依赖 DOM，也不依赖其他模块执行顺序，比如统计脚本或广告脚本。)"
    ],
    "reference": "/myKMS/knowledge/base/js#_14-script-type-module-是什么效果",
    "source": "/myKMS/knowledge/base/js"
  },
  {
    "id": 87,
    "question": "文件的软链接与硬链接?",
    "answer": [
      "硬链接 = 同一份文件的不同名字, 删除源文件,不影响数据，数据依然可访问, 软链接 = 指向另一个文件路径的快捷方式, 删除源文件,软链接链接失效",
      "文件系统中使用一个叫做 inode（索引节点） 的结构来记录文件的真实内容。",
      "硬链接: 多个文件名共享同一个 inode。 软链接: 一个独立的文件，里面保存着目标文件的路径。(更像是 Windows 的快捷方式)"
    ],
    "reference": "/myKMS/knowledge/base/js#_15-文件的软链接与硬链接",
    "source": "/myKMS/knowledge/base/js"
  },
  {
    "id": 88,
    "question": "js 原型链, 作用是什么?",
    "answer": [
      "原型链？ 在 JavaScript 里，每个对象都有一个隐藏属性 [[Prototype]]（通常通过 __proto__ 访问）。当我们访问一个对象的属性/方法时，如果对象本身没有，JS 引擎就会顺着 [[Prototype]] 向上找。这条由 [[Prototype]] 串起来的链路，就叫 原型链。",
      "原型链的作用 核心作用就是实现继承和共享属性/方法。 继承机制：子对象可以通过原型链继承父对象的方法/属性。 方法复用：所有实例共享同一个方法定义，避免每次 new 都复制一份。 动态扩展：可以在运行时给 prototype 添加方法，所有实例立刻可用",
      "原型链是 JS 实现继承的机制，通过逐层查找 [[Prototype]] 来实现属性/方法共享和复用。"
    ],
    "reference": "/myKMS/knowledge/base/js#_16-js-原型链-作用是什么",
    "source": "/myKMS/knowledge/base/js"
  },
  {
    "id": 89,
    "question": "web components",
    "answer": [
      "Web Components 是一套 浏览器原生的前端组件技术标准，让开发者能创建可复用、封装、独立于框架的组件 Custom Elements;Shadow DOM;HTML Templates; 继承 HTMLElement , 使用 customElements",
      "生命周期 constructor → 元素实例化 connectedCallback → 添加到 DOM disconnectedCallback → 从 DOM 移除 attributeChangedCallback → 被观察属性变化",
      "属性 HTML 属性与 JS 属性双向绑定 使用 observedAttributes + attributeChangedCallback 可以通过 getter/setter 做同步映射",
      "自定义事件 使用 dispatchEvent(new CustomEvent(...)) 穿透 Shadow DOM → composed: true 冒泡 → bubbles: true 建议只传小对象或数据引用",
      "插槽 提供组件可插入自定义内容的能力 `<slot>` 默认内容，外部可用 slot=\"name\" 覆盖",
      "属性/事件/插槽封装模式（常用技巧） formatProps → 统一解析属性 emit → 封装 dispatchEvent，像 Vue emit BaseComponent → 封装生命周期、属性监听、事件分发、props 解析",
      "优点: 原生支持;真正的封装;可复用性;互操作性;长期可用性 缺点: 生态和工具链;样式主题化困难;基础功能;SEO;",
      "优化: 使用 requestAnimationFrame 节流渲染 维护虚拟 DOM / shadow DOM patch 避免深度 DOM 查询，每次 render 只更新变化部分"
    ],
    "reference": "/myKMS/knowledge/base/js#_17-web-components",
    "source": "/myKMS/knowledge/base/js"
  },
  {
    "id": 90,
    "question": "ts 类型推断原理？",
    "answer": [
      "类型推断（Type Inference）指的是 —— 当开发者没有显式标注类型时，TypeScript 编译器自动根据上下文推导变量、参数、函数返回值的类型",
      "TypeScript 在编译阶段会： 扫描变量声明、赋值、函数签名、返回值； 根据上下文建立一个“类型约束图”（constraint graph）； 利用**控制流分析（Control Flow Analysis）**更新类型的可变性； 最终在不声明类型的情况下，自动推导出最合理的类型",
      "当函数使用泛型时，TS 会从调用时的实参反向推导类型参数： TS 类型系统支持从上下文反推表达式的类型，即“类型从左到右流动”： TS 会在 if、switch、typeof、in、instanceof 等控制流语句中自动缩小类型：",
      "ts 适合: 大型多人协作项目 SDK、组件库、Hooks 封装 安全重构 / 版本演进 智能提示和自文档化"
    ],
    "reference": "/myKMS/knowledge/base/js#_18-ts-类型推断原理",
    "source": "/myKMS/knowledge/base/js"
  },
  {
    "id": 91,
    "question": "Canvas 与 SVG",
    "answer": [
      "| 特性 | Canvas | SVG | | ---------- | --------------------------------------------- | ----------------------------------- | | **渲染方式** | 位图（Bitmap），直接绘制到画布像素上 | 矢量图形（Vector），每个元素是 DOM 节点 | | **核心原理** | JS 调用 Canvas API 绘制，结果写入画布缓冲区；渲染完成后无法直接操作已画元素 | XML 描述图形，浏览器解析为 DOM 节点；元素可直接操作和绑定事件 | | **交互性** | 需要手动管理元素状态和事件，复杂 | 高，可直接绑定事件、样式和动画 | | **性能** | 高性能，适合大量元素和频繁重绘 | 元素数量多时性能下降，不适合上万级节点 | | **缩放** | 放大可能模糊，需要重绘 | 矢量缩放无损失 | | **典型应用场景** | 游戏、实时数据图表、粒子动画、图像处理 | 数据可视化中等规模图表、流程图、拓扑图、矢量图标、地图 | | **优点** | 高性能、适合实时渲染和复杂动画 | 高可交互性、开发简单、支持矢量缩放 | | **缺点** | 不可直接操作已绘制元素、事件管理复杂 | 渲染大量元素性能下降、不适合高频更新 |"
    ],
    "reference": "/myKMS/knowledge/base/js#_19-canvas-与-svg",
    "source": "/myKMS/knowledge/base/js"
  },
  {
    "id": 92,
    "question": "git pull 与 git fetch",
    "answer": [
      "| 对比项 | `git fetch` | `git pull` | | -------------- | ---------------------------------------------------- | ------------------------------------ | | **作用** | 只从远程仓库拉取最新的提交记录和分支信息，不合并 | 从远程仓库拉取后，自动与本地分支进行合并（或 rebase） | | **是否修改本地代码** | ❌ 不会修改当前工作区或本地分支 | ✅ 会修改当前分支（触发 merge 或 rebase） | | **是否更新远程追踪分支** | ✅ 更新（如 `origin/main`） | ✅ 更新（并合并到当前分支） | | **安全性** | ✅ 安全（不会改变当前代码） | ⚠️ 有风险（可能产生冲突） | | **命令形式** | `git fetch [remote] [branch]` | `git pull [remote] [branch]` | | **实际等价操作** | — | `git fetch` + `git merge FETCH_HEAD` | | **适用场景** | 想先查看远程更新，不立即合并；或用于手动合并策略 | 想直接更新到最新版本（自动合并） | | **可见效果** | 更新 `.git` 内部的远程分支信息 | 同时更新远程信息并更新工作区 | | **是否可能冲突** | ❌ 不会冲突 | ⚠️ 可能发生合并冲突 | | **常用组合命令** | `git fetch origin main && git log HEAD..origin/main` | `git pull origin main` |"
    ],
    "reference": "/myKMS/knowledge/base/js#_20-git-pull-与-git-fetch",
    "source": "/myKMS/knowledge/base/js"
  },
  {
    "id": 93,
    "question": "git merge 与 git rebase",
    "answer": [
      "| 对比项 | `git merge` | `git rebase` | | ------------ | ------------------------ | ----------------------------- | | **主要作用** | 合并两个分支的历史记录，生成一个新的“合并提交” | 将一个分支的提交重新“嫁接”到另一个分支上 | | **历史结构** | 保留分叉历史（产生合并节点） | 线性化历史（重写提交） | | **是否生成新提交** | ✅ 会生成一个新的 *merge commit* | ⚠️ 重新生成一批新的提交（commit hash 改变） | | **提交历史结果** | 历史复杂，但真实反映开发过程 | 历史干净，像一条直线 | | **是否修改提交哈希** | ❌ 不会改变已有提交的哈希 | ✅ 所有 rebase 的提交哈希都会改变 | | **是否易冲突** | ⚠️ 可能在合并时冲突一次 | ⚠️ 每个提交应用时都可能冲突 | | **安全性** | ✅ 安全（不会重写历史） | ⚠️ 可能破坏共享历史（不建议在公共分支上用） | | **适用场景** | 保留真实开发分支结构（例如多人合作） | 自己分支上整理历史，让日志更清晰 | | **常见命令** | `git merge feature` | `git rebase main` | | **结果历史示意** | 分叉 + 合并节点 🪵 | 一条直线 🚀 | | **是否影响他人** | ❌ 不会（提交哈希不变） | ⚠️ 若已推送，会影响他人分支同步 |"
    ],
    "reference": "/myKMS/knowledge/base/js#_21-git-merge-与-git-rebase",
    "source": "/myKMS/knowledge/base/js"
  },
  {
    "id": 94,
    "question": "Node 中 require 时发生了什么?",
    "answer": [
      "路径解析 => 缓存检查 => 创建模块对象 => 读取与编译 => 执行模块代码 => 标记完成并返回",
      "require() 缓存检查顺序： 1. 检查原生模块缓存; 2. 检查 require.cache（路径解析后的绝对路径作为 key）。 3. 如果缓存未命中 → 走模块解析; 4. 执行模块，填充 require.cache，返回 module.exports。"
    ],
    "reference": "/myKMS/knowledge/base/nodejs#_1-node-中-require-时发生了什么",
    "source": "/myKMS/knowledge/base/nodejs"
  },
  {
    "id": 95,
    "question": "Node.js 事件循环机制",
    "answer": [
      "六个阶段: 1. Timers（计时器阶段）执行 setTimeout() 和 setInterval() 的回调 2. Pending callbacks（待定回调阶段）执行系统操作的回调，如 TCP 错误 3. Idle, prepare（闲置准备阶段）内部使用阶段 4. Poll（轮询阶段） - 最重要的阶段 检索新的 I/O 事件，执行 I/O 相关回调 5. Check（检查阶段）执行 setImmediate() 的回调 6. Close callbacks（关闭回调阶段）执行关闭事件的回调，如 socket.on('close', ...)",
      "```\n每个阶段的宏任务执行完 →\n    执行所有 nextTick 回调 →\n    执行所有微任务 (Promise)\n→ 进入下一个阶段\n```",
      "注意: 滥用 process.nextTick：会阻塞后续阶段（饿死循环）。",
      "**优先级关系** **process.nextTick() > Promise.then() > setTimeout() > setImmediate()**",
      "Node 的事件循环由 libuv 实现，循环有 timers → pending → poll → check → close 等阶段。 微任务： process.nextTick（最高优先）→ Promise.then（微任务）。 setImmediate 与 setTimeout(0) 的先后取决于上下文（在 I/O 回调中 setImmediate 会优先）。 线程池 用于无法立即非阻塞完成的工作（默认线程数 ≈4，可通过 UV_THREADPOOL_SIZE 设置）。 不要阻塞 主线程，必要时用 worker_threads 或外部服务/进程。"
    ],
    "reference": "/myKMS/knowledge/base/nodejs#_2-node-js-事件循环机制",
    "source": "/myKMS/knowledge/base/nodejs"
  },
  {
    "id": 96,
    "question": "process.nextTick 与 setTimeout 的区别",
    "answer": [
      "process.nextTick 在当前事件循环结束时执行 setTimeout(fn, 0) 在下一个事件循环开始时执行 nextTick 优先级更高"
    ],
    "reference": "/myKMS/knowledge/base/nodejs#_3-process-nexttick-与-settimeout-的区别",
    "source": "/myKMS/knowledge/base/nodejs"
  },
  {
    "id": 97,
    "question": "Koa 与 Express 的区别",
    "answer": [
      "1. 中间件机制",
      "Express：单向流动，中间件通过 next() 线性执行，一旦响应结束就不能修改 Koa：洋葱模型，中间件既可以处理请求也可以处理响应，支持统一的错误处理",
      "2. 异步处理",
      "Express：基于回调函数，容易陷入回调地狱，异步错误处理相对复杂 Koa：基于 Promise 和 async/await，代码更简洁，异步流程控制更直观",
      "3. 上下文对象",
      "Express：req 和 res 是分离的对象，功能相对分散 Koa：ctx 统一上下文，封装了 request 和 response，API 设计更简洁优雅",
      "4. 功能内置",
      "Express：内置了很多中间件，功能齐全，开箱即用 Koa：核心功能精简，需要通过第三方中间件扩展，更加灵活",
      "5. 路由系统",
      "Express：内置了强大的路由系统，支持链式调用 Koa：路由需要通过第三方中间件实现（如 koa-router）",
      "6.社区生态",
      "Express：历史更悠久，社区更成熟，资源更丰富 Koa：较新但发展迅速，设计更现代，适合新项目",
      "7. 错误处理",
      "Express：通过特殊的错误处理中间件，需要手动传递错误 Koa：通过 try/catch 优雅地处理错误，统一的错误处理更方便",
      "8. 适用场景",
      "Express：适合快速开发，现有项目迁移，团队熟悉度高 Koa：适合追求优雅代码，需要更好的异步流程控制的场景"
    ],
    "reference": "/myKMS/knowledge/base/nodejs#_4-koa-与-express-的区别",
    "source": "/myKMS/knowledge/base/nodejs"
  },
  {
    "id": 98,
    "question": "JWT 如何自动更新 token",
    "answer": [
      "采用JWT 双 Token 模式：Access Token + Refresh Token | 类型 | 作用 | 有效期 | 存储位置 | | ----------------- | ------------------- | ------------ | ----------------------------- | | **Access Token** | 每次请求携带，用于认证用户身份 | 短（几分钟 ~ 几小时） | 浏览器内存 / localStorage / cookie | | **Refresh Token** | 用于申请新的 Access Token | 长（几天 ~ 几周） | 安全 Cookie / HttpOnly 存储 |",
      "当前端收到 401 且检测到是 “Access Token 过期”时, 用Refresh Token 获取新的Access Token",
      "前端思路:",
      "封装请求拦截器； 如果请求返回 401，且不是刷新请求； 尝试调用 /auth/refresh； 刷新成功 → 重试原请求； 刷新失败 → 跳转登录。",
      "1. 滑动过期（Sliding Expiration） 每次用户请求时，如果 Access Token 快过期，自动签发新 Token(playload 可以加过期时间)",
      "2. 令牌版本号机制 每个用户在数据库中维护一个 tokenVersion；当刷新或登出时，更新版本号；旧的 Refresh Token 因版本号不匹配立即失效。",
      "3. JWT 自动续期时的“并发刷新冲突问题” 同一时间只允许一次刷新操作,其他请求等待刷新完成后再继续。 请求队列 + 刷新锁 当第一个请求检测到 token 过期时： 标记一个全局变量 isRefreshing = true 发起 /auth/refresh 请求 其他同时失败的请求 不要立即刷新，而是放进一个队列 pendingRequests 刷新成功后： 更新新的 token； 依次重放（retry）队列中的请求； 清空队列； 重置 isRefreshing = false。 刷新令牌幂等化 若在短时间内多次使用同一个 refresh token,后端可以检测并返回同一个新 token（或最新有效 token），而不是直接报错“refresh token 已被使用”。 刷新限流 对同一个用户的刷新操作设置时间间隔限制（例如 5 秒内只允许一次刷新）"
    ],
    "reference": "/myKMS/knowledge/base/nodejs#_5-jwt-如何自动更新-token",
    "source": "/myKMS/knowledge/base/nodejs"
  },
  {
    "id": 99,
    "question": "扫描登录如何实现?",
    "answer": [
      "PC浏览器 <———> 服务器 <———> 手机App",
      "浏览器打开登录页 前端请求后端生成一个 唯一的登录二维码 二维码内容通常是一个 临时 login_token（或UUID） 二维码展示给用户",
      "用户用手机App扫码 App 扫描二维码，得到 login_token App 发请求到服务器，验证该二维码是否合法 如果合法，App 显示提示「是否允许登录该网页？」",
      "用户在手机上点击「确认登录」 App 带着登录状态的用户信息，调用后端接口 服务端保存：该 login_token 对应的登录状态",
      "网页端轮询或WebSocket等待登录结果 网页端每隔1-2秒查询登录结果 如果发现 login_token 已被确认绑定用户，则返回成功状态 + 用户信息",
      "浏览器登录成功 前端拿到 token（如JWT），存入 Cookie / LocalStorage 重定向到首页，登录完成"
    ],
    "reference": "/myKMS/knowledge/base/nodejs#_6-扫描登录如何实现",
    "source": "/myKMS/knowledge/base/nodejs"
  },
  {
    "id": 100,
    "question": "http2的首部压缩",
    "answer": [
      "为什么要压缩首部？ HTTP/1.1 的每个请求都会携带大量重复的首部. 这些头部在同一个连接中 几乎每次都一样，比如 User-Agent、Cookie、Accept。HTTP/2 引入 首部压缩（Header Compression） 来减少这种重复，提高传输效率。",
      "HTTP/2 首部压缩机制：HPACK",
      "| 机制 | 说明 | | --------------------------- | ---------------------------------------------------- | | **静态表（Static Table）** | 内置常见头部字段，如 `:method`, `:path`, `:status` 等；用索引代替字符串。 | | **动态表（Dynamic Table）** | 在连接中缓存已发送的头部；后续请求只需引用索引。 | | **霍夫曼编码（Huffman Encoding）** | 对字符串部分再进行霍夫曼编码，进一步压缩体积。 |",
      "HPACK 的压缩原理图",
      "| 步骤 | 动作 | 效果 | | -- | ------ | -------------------------------- | | 1 | 查静态表 | 常用字段直接用编号（如 `:method: GET` = #2） | | 2 | 查动态表 | 最近请求过的头字段从表中引用 | | 3 | 发送差异数据 | 只发送新字段或变化部分 | | 4 | 霍夫曼编码 | 对字符串再压缩 | | ✅ | 结果 | 头部数据量可减少 60–90% |",
      "**HTTP/2 的首部压缩机制（HPACK）通过静态表、动态表和霍夫曼编码三种方式，实现头部字段的高效压缩与重用，大幅减少网络传输开销。**",
      "HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为\"帧\"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。"
    ],
    "reference": "/myKMS/knowledge/browser/http#_1-http2的首部压缩",
    "source": "/myKMS/knowledge/browser/http"
  },
  {
    "id": 101,
    "question": "tcp 断开4次挥手",
    "answer": [
      "TCP 是全双工的. 全双工（Full-duplex）：",
      "即双方可以同时发送和接收数据。 所以连接断开时，双方都要单独关闭各自的发送方向。",
      "假设：客户端（主动关闭连接）服务器（被动关闭连接）",
      "通信结束时，断开过程如下：",
      "| 步骤 | 方向 | 报文标志位 | 说明 | | -- | --------- | ------- | -------------------- | | ① | 客户端 → 服务器 | `FIN=1` | 客户端请求关闭发送通道 | | ② | 服务器 → 客户端 | `ACK=1` | 服务器确认接收 | | ③ | 服务器 → 客户端 | `FIN=1` | 服务器也关闭发送通道 | | ④ | 客户端 → 服务器 | `ACK=1` | 客户端确认接收，进入 TIME_WAIT |",
      "```\n客户端 (Client)                             服务器 (Server)\n------------------                          ------------------\n\n   ESTABLISHED                                  ESTABLISHED\n        |                                              |\n        | ① FIN=1, seq=u                              |\n        |--------------------------------------------->|\n        |                                              |\n        |                           收到 FIN, 发 ACK=1, ack=u+1\n        | ②                                            |\n        |<---------------------------------------------|\n        |                                              |\n        |                           服务器继续处理剩余数据\n        |                                              |\n        |                           ③ FIN=1, seq=v    |\n        |<---------------------------------------------|\n        | ④ ACK=1, ack=v+1                             |\n        |--------------------------------------------->|\n        |                                              |\n   TIME_WAIT(等待2MSL)                          CLOSED\n        |\n   连接彻底关闭\n```",
      "客户端最后要 等待 2×MSL（Maximum Segment Lifetime） 时间，约几十秒。",
      "作用：",
      "确保服务器收到最终 ACK 若 ACK 丢失，服务器会重发 FIN。 客户端在 TIME_WAIT 状态还能重发 ACK。",
      "防止旧连接残余报文影响新连接 等待 MSL 确保网络中旧包都过期。",
      "1. 为什么关闭要四次，而不是三次？ 因为 TCP 是全双工：",
      "一方关闭发送，不代表另一方也关闭； 必须双方都各自发送 FIN，确认关闭。",
      "2. 为什么客户端要 TIME_WAIT？",
      "防止最后的 ACK 丢失，确保连接彻底关闭。 另外，避免旧连接的数据干扰新连接。",
      "3. 为什么是 “2MSL”？",
      "因为： 一个 MSL 是一个报文在网络中能存活的最长时间； 等 2×MSL，确保往返的所有旧报文都消失。",
      "4. 如果服务器先关闭会怎样？",
      "流程相同，只是角色对调。 谁主动关闭，谁就经历 TIME_WAIT。"
    ],
    "reference": "/myKMS/knowledge/browser/http#_2-tcp-断开4次挥手",
    "source": "/myKMS/knowledge/browser/http"
  },
  {
    "id": 102,
    "question": "什么是队头阻塞",
    "answer": [
      "队头阻塞就是“队列第一个请求卡住，后面全被拖延”。HTTP/3 通过 QUIC 彻底缓解了这个问题。"
    ],
    "reference": "/myKMS/knowledge/browser/http#_3-什么是队头阻塞",
    "source": "/myKMS/knowledge/browser/http"
  },
  {
    "id": 103,
    "question": "http 2 多路复用",
    "answer": [
      "HTTP/1.1 每个请求都必须建立在一个 TCP 连接上。虽然它支持“Keep-Alive”长连接，但仍然有两个性能瓶颈：",
      "队头阻塞（Head-of-Line Blocking）: 一个连接中，请求是串行执行的。前一个响应没回来，后面的请求必须等。 多连接并发受限: 浏览器为同一域名通常只能同时开 6 个 TCP 连接，多了也被限制。 📦 头部重复传输: 每次请求都要携带大量相同的 Header（如 cookie、user-agent）。",
      "在一个 TCP 连接上，同时并发多个 HTTP 请求与响应。",
      "工作方式：",
      "1. 所有请求和响应都被拆分成小块（frame）。 2. 每个请求分配一个唯一的 Stream ID。 3. 这些 frame 被交错（交织）发送，在同一个 TCP 连接中同时传输。 4. 接收端再根据 Stream ID 把它们拼回原样。",
      "举个例子： 假设浏览器要加载三个资源：",
      "```\nindex.html\nstyle.css\nmain.js\n\n```",
      "HTTP/1.1：",
      "3 个请求需要占用 3 个 TCP 连接； 或者 1 个连接按顺序：html → css → js； 前面的慢了，后面的全卡住（队头阻塞）。",
      "HTTP/2：",
      "所有请求共用 1 个 TCP 连接； 三个请求的 frame 被交错发送； 谁先返回数据就先解析，完全并行。",
      "多路复用消除了 HTTP 层阻塞，但 TCP 层仍可能受丢包影响。",
      "**HTTP/2 多路复用 = 一个连接里同时传多条请求流，互不阻塞，性能飞升。**"
    ],
    "reference": "/myKMS/knowledge/browser/http#_4-http-2-多路复用",
    "source": "/myKMS/knowledge/browser/http"
  },
  {
    "id": 104,
    "question": "DNS 协议",
    "answer": [
      "DNS（Domain Name System） 是一个将 域名 ↔ IP 地址 相互映射的分布式系统。",
      "因为：用户容易记住 www.example.com;计算机只能识别 93.184.216.34;DNS 让我们可以使用域名访问网站，系统自动帮你找到正确的 IP。",
      "DNS 解析的完整流程:",
      "浏览器缓存: 先查本地 DNS 缓存（比如上次访问过) 操作系统缓存: 如果浏览器里没有，就问操作系统的 DNS 缓存。 hosts 文件: 操作系统先查 hosts 文件，看看是否有手动配置。 本地 DNS 服务器（递归解析器）: 一般由 ISP（网络运营商）提供，比如 8.8.8.8（Google）、114.114.114.114（中国电信）。 递归查询（DNS 服务器帮你查到底）",
      "DNS 通常使用 UDP 53 端口（查询），TCP 用于传输大数据量（如区域传送）。",
      "每条 DNS 记录都有一个 TTL（Time To Live） 值，比如 300 秒。"
    ],
    "reference": "/myKMS/knowledge/browser/http#_5-dns-协议",
    "source": "/myKMS/knowledge/browser/http"
  },
  {
    "id": 105,
    "question": "html script defer 与async",
    "answer": [
      "| 特性 | `<script async> ` | `<script defer>` | | ---------------- | -------------------------------------------------------- | ------------------------------------------------------------------ | | 加载时机 (Loading) | 立即加载（与 HTML 解析并行） | 立即加载（与 HTML 解析并行） | | 执行时机 (Execution) | 文件下载完成后立即执行 | 等待整个 HTML 文档解析完成后再执行 | | 执行顺序 | 不保证顺序。哪个文件先下载完，哪个先执行。 | 保证顺序。按在文档中出现的顺序依次执行。 | | 是否阻塞 HTML | 会。文件执行时会暂停 HTML 解析。 | 不会。保证在 HTML 解析完成后才执行。 | | 适用场景 | 适用于独立脚本，不依赖 DOM，也不被其他脚本依赖（如统计脚本）。 | 适用于依赖 DOM 或被其他 defer 脚本依赖的脚本（如应用主逻辑脚本）。 |"
    ],
    "reference": "/myKMS/knowledge/browser/http#_6-html-script-defer-与async",
    "source": "/myKMS/knowledge/browser/http"
  },
  {
    "id": 106,
    "question": "HTTP/3",
    "answer": [
      "**HTTP/3 = HTTP/2 + QUIC(UDP)**",
      "HTTP/3 是继 HTTP/2 之后的下一代超文本传输协议。它的核心变化是：**不再基于 TCP，而是基于 QUIC（UDP 之上的新协议）。**",
      "| 协议 | 传输层 | 特点 | 存在问题 | | ------------ | ------------- | ------------- | -------------- | | **HTTP/1.1** | TCP | 简单、可靠 | 多连接、阻塞严重 | | **HTTP/2** | TCP | 多路复用、头部压缩 | TCP 队头阻塞无法彻底解决 | | **HTTP/3** | **UDP（QUIC）** | 多路复用、内置加密、低延迟 | 部分老设备不兼容 UDP |",
      "QUIC（UDP）的优势",
      "QUIC 直接运行在 UDP 之上，自己实现可靠传输 + 拥塞控制 + 加密： 消除队头阻塞：每个流独立传输，不互相影响 1-RTT 握手（甚至 0-RTT） 连接可迁移（基于 Connection ID） 内置 TLS 1.3 加密（强制 HTTPS）",
      "```\n// HTTP/2\nHTTP/2\n  ↓\n  TLS\n  ↓\n  TCP\n  ↓\n  IP\n\n// HTTP/3\nHTTP/3\n  ↓\n  QUIC (内含TLS 1.3 + 可靠传输)\n  ↓\n  UDP\n  ↓\n  IP\n\n```"
    ],
    "reference": "/myKMS/knowledge/browser/http#_7-http-3",
    "source": "/myKMS/knowledge/browser/http"
  },
  {
    "id": 107,
    "question": "nginx proxy_pass 与location 结尾加不加 / 对路径的影响",
    "answer": [
      "**尾斜杠“决定路径拼接规则”** ,location 和 proxy_pass 的结尾 是否带 /，直接决定了 Nginx 如何拼接请求路径。",
      "proxy_pass 加不加 /:",
      "不加 /：location 匹配的路径会被完整拼接到 proxy_pass 地址后（适合后端接口路径与前端请求路径完全一致的场景）。 加 /：location 匹配的路径会被替换为 /，仅将剩余路径拼接到 proxy_pass 地址后（适合需要简化后端接口路径的场景）。",
      "参考: | 情形 | `location` 配置 | `proxy_pass` 配置 | 请求示例 | 转发给上游的路径 | 说明 | | :-: | :------------ | :--------------------- | :--------- | :----------------------- | :-------------------------- | | 1 | `/api`（不带斜杠） | `http://backend`（不带斜杠） | `/api/foo` | `http://backend/api/foo` | 保留原始路径 `/api/foo`。 | | 2 | `/api`（不带斜杠） | `http://backend/`（带斜杠） | `/api/foo` | `http://backend//foo` | 去除 `/api` 前缀后拼接，产生双斜杠。 | | 3 | `/api/`（带斜杠） | `http://backend`（不带斜杠） | `/api/foo` | `http://backend/api/foo` | 保留 `/api/` 前缀。 | | 4 | `/api/`（带斜杠） | `http://backend/`（带斜杠） | `/api/foo` | `http://backend/foo` | 去除 `/api/` 前缀后拼接，结果 `/foo`。 |"
    ],
    "reference": "/myKMS/knowledge/browser/http#_8-nginx-proxy-pass-与location-结尾加不加-对路径的影响",
    "source": "/myKMS/knowledge/browser/http"
  },
  {
    "id": 108,
    "question": "nginx多域名隔离, 同域名不同路径映射",
    "answer": [
      "Nginx 可以通过 include 指令或虚拟主机（vhost）实现前端多环境（如开发、测试、生产）的隔离部署，同时针对同域名不同路径的映射场景，需要处理路径重写和资源引用问题",
      "多环境隔离的核心是为不同环境（如 dev、test、prod）配置独立的 Nginx 规则，避免互相干扰。 1. 基于 include 指令的多环境配置（推荐） 适合单服务器部署多个环境，通过拆分配置文件实现隔离，便于维护。 也适合单服务部署多域名环境",
      "2. 基于虚拟主机（vhost）的多环境配置",
      "```nginx\nhttp {\n    # 开发环境（域名区分）\n    server {\n        listen 80;\n        server_name dev.example.com;  # 开发环境域名\n        root /path/to/frontend/dev;\n        # ... 其他配置（路由、代理等）\n    }\n\n    # 测试环境（端口区分）\n    server {\n        listen 8081;  # 测试环境端口\n        server_name localhost;\n        root /path/to/frontend/test;\n        # ... 其他配置\n    }\n\n    # 生产环境（HTTPS）\n    server {\n        listen 443 ssl;\n        server_name example.com;  # 生产环境域名\n        root /path/to/frontend/prod;\n        # ... SSL 配置和其他生产环境特有的规则\n    }\n}\n```",
      "同域名不同路径映射的重写问题及解决方案",
      "当多个前端应用部署在同一域名的不同路径下（如 example.com/app1、example.com/app2），需要解决路径映射和资源引用的问题。",
      "```nginx\nserver {\n    listen 80;\n    server_name example.com;\n    root /var/www;  # 父目录\n\n    # 应用 A：匹配 /app1 路径\n    location /app1 {\n        # 实际文件目录为 /var/www/app1\n        alias /var/www/app1;  # 注意：这里用 alias 而非 root（关键区别）\n        index index.html;\n\n        # 解决 History 路由刷新 404\n        try_files $uri $uri/ /app1/index.html;\n    }\n\n    # 应用 B：匹配 /app2 路径\n    location /app2 {\n        alias /var/www/app2;\n        index index.html;\n        try_files $uri $uri/ /app2/index.html;\n    }\n}\n```",
      "关键区别：alias vs root",
      "root /var/www：请求 /app1/static/css.css 会映射到 /var/www/app1/static/css.css（拼接完整路径）。 alias /var/www/app1：请求 /app1/static/css.css 会直接映射到 /var/www/app1/static/css.css（替换 /app1 为实际目录），更适合子路径部署。"
    ],
    "reference": "/myKMS/knowledge/browser/http#_9-nginx多域名隔离-同域名不同路径映射",
    "source": "/myKMS/knowledge/browser/http"
  },
  {
    "id": 109,
    "question": "WebSocket",
    "answer": [
      "WebSocket是HTML5提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。",
      "WebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：**服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。**",
      "WebSocket 特点的如下：",
      "支持双向通信，实时性更强 可以发送文本，也可以发送二进制数据‘’ 建立在TCP协议之上，服务端的实现比较容易 数据格式比较轻量，性能开销小，通信高效 没有同源限制，客户端可以与任意服务器通信 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 连接通过 HTTP Upgrade 握手升级而来。"
    ],
    "reference": "/myKMS/knowledge/browser/http#_10-websocket",
    "source": "/myKMS/knowledge/browser/http"
  },
  {
    "id": 110,
    "question": "短轮询、长轮询、SSE 和 WebSocket",
    "answer": [
      "| 特性 | 短轮询 | 长轮询 | SSE | WebSocket | | ---- | ------ | -------- | ----------------------- | ---------------- | | 协议 | HTTP | HTTP | HTTP（text/event-stream） | 专用 WS 协议（基于 TCP） | | 实时性 | ⏱ 延迟高 | ⚡ 中等 | ⚡ 高 | 🚀 最高 | | 方向 | 客户端拉取 | 客户端拉取 | 服务端推送 | 双向 | | 兼容性 | ✅ 最好 | ✅ 好 | ⚠️ IE 不支持 | ⚠️ 需服务器支持 | | 连接数量 | 多 | 多（长时间挂起） | 少（单连接） | 少（持久连接） | | 复杂度 | ⭐ 简单 | ⭐⭐ 中等 | ⭐⭐ 中等 | ⭐⭐⭐ 高 | | 常见场景 | 定时刷新数据 | 即时消息、通知 | 日志推送、股票行情 | 聊天、游戏、协同编辑 |",
      "| 场景 | 推荐方式 | 理由 | | ---------- | --------- | --------- | | 定时刷新、后台任务 | 短轮询 | 简单可靠 | | 实时通知、消息提醒 | 长轮询 / SSE | 实时性高，易于部署 | | 实时图表、日志流 | SSE | 单向推送、易实现 | | 聊天、多人协作、游戏, 消息 | WebSocket | 双向实时通信能力强 |",
      "短轮询: 每隔短时间询问服务器 长轮询: 浏览器发送请求后，服务器不立即返回，而是等到有新数据再响应，或者超时（例如 30s）。浏览器收到响应后立即发起下一次请求，保持“几乎实时”。 SSE: 服务器通过 HTTP 长连接 向浏览器“持续推送”数据（单向）。('Content-Type': 'text/event-stream') WebSocket 是 全双工通信协议，一旦连接建立，客户端和服务器都可以主动发送消息。"
    ],
    "reference": "/myKMS/knowledge/browser/http#_11-短轮询、长轮询、sse-和-websocket",
    "source": "/myKMS/knowledge/browser/http"
  },
  {
    "id": 111,
    "question": "常见的性能指标",
    "answer": [
      "Performance API 是浏览器提供的内置接口，用于测量网页的加载时间、资源性能和用户体验。",
      "常见性能指标",
      "FP (First Paint)首次绘制 ，指用户第一次看到页面内容时的时间点（通常是背景颜色）。 FCP (First Contentful Paint)首次内容绘制 ，页面中首个内容（如文字、图片）被绘制的时间点。 优化思路 ：减少 CSS 阻塞、优化首屏加载内容。 LCP (Largest Contentful Paint)最大内容绘制 ，页面中最大内容元素（如主标题、图片）绘制完成的时间点。 优化思路 ：使用延迟加载策略、优化图像加载。 CLS (Cumulative Layout Shift)累积布局偏移 ，页面加载过程中视觉内容意外变化的总量。 优化思路 ：设置明确的宽高，避免懒加载导致布局移动。 FID (First Input Delay)首次输入延迟 ，用户第一次交互（如点击按钮）与浏览器响应之间的时间间隔。 优化思路 ：减少主线程阻塞。 TTI (Time to Interactive)可交互时间 ，页面完成加载并能够快速响应用户交互的时间"
    ],
    "reference": "/myKMS/knowledge/browser/index#_1-常见的性能指标",
    "source": "/myKMS/knowledge/browser/index"
  },
  {
    "id": 112,
    "question": "sourcemap 有何作用",
    "answer": [
      "Source Map 是一种将压缩、混淆后的代码映射回源代码的文件，用于调试和定位错误。它的主要作用如下：",
      "调试优化 ：在开发者工具中看到源代码而非压缩后的代码。 错误定位 ：在生产环境中准确定位代码错误。 性能分析 ：配合性能工具对源代码进行优化分析。"
    ],
    "reference": "/myKMS/knowledge/browser/index#_2-sourcemap-有何作用",
    "source": "/myKMS/knowledge/browser/index"
  },
  {
    "id": 113,
    "question": "什么是 HTTPS 中间人攻击，如何预防",
    "answer": [
      "中间人攻击（MITM, Man-In-The-Middle） 是指攻击者拦截客户端与服务器之间的通信，获取敏感信息或篡改数据。",
      "攻击原理",
      "攻击者通过伪造证书或劫持网络流量，冒充服务器或客户端，使通信双方无法察觉中间人的存在。",
      "常见攻击手段",
      "| 攻击方式 | 描述 | | --------------------- | --------------------------- | | **伪造 CA 证书** | 诱导用户安装恶意根证书，使浏览器信任攻击者签发的假证书 | | **DNS 劫持** | 篡改 DNS 解析，将域名指向攻击者的服务器 | | **ARP 欺骗 / Wi-Fi 劫持** | 局域网或公共 Wi-Fi 中间人篡改流量 | | **SSL Strip（降级攻击）** | 强制将 HTTPS 降级为 HTTP，窃取明文数据 |",
      "预防措施 1. 启用 HTTPS 和强证书验证 配置 TLS 并购买可信的 SSL 证书。 使用 HSTS（HTTP Strict Transport Security）强制 HTTPS 访问。 2. 证书固定（Certificate Pinning） 确保客户端只接受特定 CA 签发的证书。 3. 开启 CORS 配置 配置严格的跨域策略，减少不必要的网络暴露。 4. 安全头部配置 设置 Content-Security-Policy 防止资源篡改。 设置 Strict-Transport-Security 强制使用 HTTPS。 5. 客户端验证 通过双向 TLS（Mutual TLS）验证客户端身份。"
    ],
    "reference": "/myKMS/knowledge/browser/index#_3-什么是-https-中间人攻击-如何预防",
    "source": "/myKMS/knowledge/browser/index"
  },
  {
    "id": 114,
    "question": "CSP 是什么",
    "answer": [
      "CSP 内容安全策略(白名单制度) 告诉浏览器：哪些资源可以加载和执行，哪些不允许,用来 防御 XSS、点击劫持、数据注入 等攻击. HTTP 响应头: Content-Security-Policy",
      "CSP 就像是网站的“白名单防火墙” 明确允许的脚本、样式、图片、字体等来源，其他一律拒绝。",
      "CSP 常用指令 | 指令 | 控制的内容 | 示例 | | ----------------------------- | ------------------- | --------------------------------------- | | **default-src** | 默认资源加载策略 | `'self'`、`https:` | | **script-src** | JavaScript 来源 | `'self'`、`https://cdn.example.com` | | **style-src** | CSS 样式来源 | `'self'` `'unsafe-inline'` | | **img-src** | 图片来源 | `data:`、`https://images.example.com` | | **font-src** | 字体来源 | `'self'`、`https://fonts.googleapis.com` | | **connect-src** | AJAX / WebSocket 来源 | `'self'`、`https://api.example.com` | | **frame-src** | `<iframe>` 来源 | `'self'`、`https://youtube.com` | | **object-src** | Flash / 插件来源 | `'none'`（推荐禁用） | | **report-uri** | 报告 CSP 违规 | `/csp-violation-report-endpoint/` | | **upgrade-insecure-requests** | 自动将 HTTP 升级为 HTTPS | 无值 |"
    ],
    "reference": "/myKMS/knowledge/browser/index#_4-csp-是什么",
    "source": "/myKMS/knowledge/browser/index"
  },
  {
    "id": 115,
    "question": "webworker 可以调用 sessionStorage localStorage吗??",
    "answer": [
      "**不可以**",
      "Web Worker 的运行环境",
      "**Web Worker 是在 独立线程（Worker thread）中运行的。**",
      "**没有 DOM、没有 window 对象。**",
      "只有少数全局对象可用",
      "```self, postMessage, importScripts, fetch, XMLHttpRequest, IndexedDB, caches, crypto, setTimeout/setInterval, ...```\n\nwindow.localStorage / window.sessionStorage 是 DOM API，属于主线程对象，因此 Worker 里不可访问。"
    ],
    "reference": "/myKMS/knowledge/browser/index#_5-webworker-可以调用-sessionstorage-localstorage吗",
    "source": "/myKMS/knowledge/browser/index"
  },
  {
    "id": 116,
    "question": "IndexedDB 可以存什么类型的数据",
    "answer": [
      "IndexedDB 是一个“小型对象数据库”,它不像传统数据库那样只能存文本或 JSON，它可以直接存放 复杂 JS 对象、二进制资源、文件流。",
      "| 类别 | 支持 | 示例 | | ------ | -- | ----------------------------------- | | 基础类型 | ✅ | Number, String, Boolean, null | | 对象 | ✅ | Object, Array | | 日期 | ✅ | Date | | 正则 | ✅ | /abc/ | | 二进制 | ✅ | Blob, File, ArrayBuffer, TypedArray | | 集合 | ✅ | Map, Set | | 函数 | ❌ | function(){} | | DOM 节点 | ❌ | document.body | | Symbol | ❌ | Symbol(\"x\") |",
      "cookies, sessionStorage, localStorage, 只能存字符串"
    ],
    "reference": "/myKMS/knowledge/browser/index#_6-indexeddb-可以存什么类型的数据",
    "source": "/myKMS/knowledge/browser/index"
  },
  {
    "id": 117,
    "question": "常见的图片格式 和特点",
    "answer": [
      "| 类型 | 定义 | | ----------------------- | ------------------------------------ | | **位图（Bitmap / Raster）** | 图像由 **像素（Pixel）** 构成，每个像素有颜色信息。 | | **矢量（Vector）** | 图像由 **数学公式描述的几何形状** 构成，如线条、曲线、圆、多边形。 |",
      "| 格式 | 类型 | 压缩 | 透明度 | 动图 | 主要用途 | 特点 | | --------------- | -- | -------- | ------ | ----- | ------------ | -------------- | | **JPEG / JPG** | 位图 | 有损 | ❌ 不支持 | ❌ | 照片类图片 | 体积小、色彩丰富、模糊边缘 | | **PNG** | 位图 | 无损 | ✅ 支持 | ❌ | 图标、Logo、UI元素 | 支持透明、清晰但体积大 | | **GIF** | 位图 | 无损（256色） | ✅ 简单透明 | ✅ | 简单动图、表情包 | 仅256色、支持动画 | | **WebP** | 位图 | 有损 / 无损 | ✅ 支持 | ✅ | Web图片优化 | 压缩高效、现代浏览器支持 | | **SVG** | 矢量 | 无损 | ✅ 支持 | ✅（有限） | 图标、Logo、图形 | 矢量可缩放、不失真、代码形式 | | **AVIF** | 位图 | 有损 / 无损 | ✅ 支持 | ✅ | 高清图像、Web优化 | 压缩更优于 WebP | | **HEIF / HEIC** | 位图 | 有损 | ✅ 支持 | ✅ | 手机拍摄图像（iOS） | 高效压缩、兼容性差 | | **BMP** | 位图 | 无压缩 | ❌ 不支持 | ❌ | 老旧格式、仅限特定系统 | 文件大、几乎不用 | | **TIFF** | 位图 | 无损 | ✅ 支持 | ✅（多页） | 专业印刷、扫描、医学图像 | 高质量、大体积 |",
      "医学常用图片格式 | 格式 | 类型 | 特点 | 场景 | | ----------------------- | -------- | ----------------------------------------------------- | ----------------------------- | | **DICOM (.dcm)** | 专业医学格式 | - 图像 + 元数据（患者信息、扫描参数）<br>- 支持多维图像（CT/MRI序列）<br>- 支持压缩 | CT、MRI、超声、放射影像 | | **TIFF (.tif / .tiff)** | 位图 | 高精度无损，支持多页 | 病理切片扫描、显微镜图像 | | **PNG** | 位图 | 无损、支持灰度和透明 | 简单病理图像、病灶标注 | | **JPEG / JPEG2000** | 位图 | 有损/无损压缩，高压缩比 | PACS 存储病理切片（JPEG2000 优于 JPEG） | | **SVS / NDPI** | 专用病理切片格式 | 多分辨率金字塔图像 | 数字病理全切片扫描 |"
    ],
    "reference": "/myKMS/knowledge/browser/index#_7-常见的图片格式-和特点",
    "source": "/myKMS/knowledge/browser/index"
  },
  {
    "id": 118,
    "question": "文件上传漏洞",
    "answer": [
      "文件上传漏洞会导致: 远程代码执行（RCE）：上传可执行脚本（.php/.jsp/.asp/.jspx/.aspx）并触发执行。 任意文件覆盖 / 覆盖重要文件：上传的文件覆盖现有文件导致服务异常或后门。 敏感数据泄露：上传包含敏感信息或把上传目录暴露到外网。 恶意文件分发 / 恶意二进制：传播木马、挖矿程序、恶意图片等给其他用户。 存储耗尽 / DoS：大量大文件上传耗尽磁盘或带宽。 安全绕过（MIME/扩展绕过）",
      "常见攻击向量（列举）: 上传 .php 并通过 /uploads/shell.php 访问 -> RCE。 上传 .jpg 文件但实际是 PHP（混淆扩展或双扩展 like shell.jpg.php）并被服务器当作脚本执行。 在 filename 中使用 ../ 路径穿越覆盖关键文件（若服务端未规范化路径）。 通过大文件或并发上传耗尽磁盘 / 触发资源耗尽。 利用上传的 SVG（包含 JS）进行 XSS。 上传带有恶意 EXIF 的图片或特殊格式触发后端解析库漏洞。",
      "防御原则: 最小信任：客户端输入（文件名、MIME、大小、扩展）均不可信。 白名单策略：只允许明确需要的一小部分扩展与 MIME（优于黑名单）。 多层检测：扩展名 + MIME 类型 + 文件头/魔数（magic bytes） + 内容扫描（AV/沙箱） + 元数据检查。 隔离存储：上传存储在不可执行、非 web 根目录的位置，或使用对象存储（S3）并通过后端签名/代理访问。 最小权限与不可执行：上传目录不可执行（noexec），文件系统权限最小化。 签名/校验与短期 URL：采用 signed URLs / presigned upload + 后端审核或触发异步扫描。 流式处理 + 限制：限制最大文件大小、文件类型、并发上传数、速率。 后续处理：异步病毒扫描、图像重编码（重新生成缩略图），移除可执行元数据。 日志与告警：所有上传活动审计、异常触发报警。"
    ],
    "reference": "/myKMS/knowledge/browser/webSecurity#_7-文件上传漏洞",
    "source": "/myKMS/knowledge/browser/webSecurity"
  },
  {
    "id": 119,
    "question": "中间人攻击",
    "answer": [
      "定义：攻击者在通信双方之间拦截、篡改或监听网络流量，使双方以为是在直接通信，但实际上流量被中间人读取或修改。",
      "危害：窃取凭证、会话劫持、注入恶意脚本/内容、篡改数据、绕过认证、下发恶意资源等。",
      "常见的中间人攻击( MITM 变种) 被动监听 主动中间人 ARP Spoofing / L2 欺骗 DNS 欺骗 / 劫持 SSL/TLS 中间人（伪造证书 / 不安全降级) 恶意代理 / 透明代理 / 企业中间人 边缘 CDN / 插件污染",
      "防御与缓解措施: 始终使用 HTTPS（TLS） 启用 TLS1.3，关闭过时协议/算法 HSTS（HTTP Strict Transport Security） 启用 HTTP/2 或 HTTP/3（QUIC） Content Security Policy (CSP) — 防止被注入的脚本执行 安全 Cookie 配置 禁止混合内容（Mixed Content） — 所有资源必须通过 HTTPS 加载 减少在客户端存储敏感信息"
    ],
    "reference": "/myKMS/knowledge/browser/webSecurity#_8-中间人攻击",
    "source": "/myKMS/knowledge/browser/webSecurity"
  },
  {
    "id": 120,
    "question": "react尽量不要再内部定义组件",
    "answer": [
      "```jsx\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  const Child = () => {\n    useEffect(() => {\n      console.log('Child mounted');\n    }, []);\n    return <div>child</div>;\n  };\n  const Child2 = useCallback(() => {\n    useEffect(() => {\n      console.log(\"Child mounted\");\n    }, []);\n    return <div>child2</div>;\n  }, []);\n\n  return (\n    <>\n      <button onClick={() => setCount(c => c + 1)}>+</button>\n      <Child />\n      <Child2 />\n    </>\n  );\n}\n\n```",
      "🔴 每次点击按钮，Child 都会重新挂载，副作用也会重新执行。",
      "当父组件内部定义子组件时，每次父组件 render 都会创建一个新的函数对象。React 看到“类型变了”，认为它是一个全新的组件。结果：子组件每次都会被卸载并重新挂载。**可以使用 useCallback 优化**",
      "什么时候可以在内部定义组件? 组件依赖父组件的闭包变量 性能无关的小组件 需要动态生成组件类型"
    ],
    "reference": "/myKMS/knowledge/framework/react#_1-react尽量不要再内部定义组件",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 121,
    "question": "为什么修改 Context 后, 只有useContext 的组件才会重新渲染",
    "answer": [
      "**React 内部是 精确追踪哪些 Fiber 消费了 Context。**",
      "**React 的 Context 依赖 Fiber 树 + 依赖收集机制：** 1. Provider 提供 value。 2. useContext / Consumer 注册依赖。当一个组件调用 `useContext(MyContext)` 时：React 在 Fiber 构建阶段找到最近的 Provider，读取当前 Context value，同时把这个 Fiber 注册到 Context 的依赖列表，标记它依赖这个 Context。 3. Provider value 更新：React 调用 `scheduleUpdateOnFiber(providerFiber)` 更新 Provider，遍历 Fiber 树，只更新依赖该 Context 的 Fiber；没有调用 `useContext` / `Consumer` 的组件不会在依赖列表里 → 不触发重新渲染。",
      "扩展",
      "如果 Context value 对象每次都创建新引用, 即使 count 没变化，所有依赖 useContext 的组件也会渲染，因为对象引用变化。(优化使用 useMemo 缓存) 拆分 Context,将不同状态拆分成多个 Context，减少不必要更新。",
      "再拓展: react Context 的原理",
      "React Context 用于跨组件共享数据，避免多层嵌套的 props 传递。",
      "**React Context 核心依赖 Fiber 树 和 依赖收集机制：**",
      "React Context 的原理核心是 发布-订阅模式，它通过 createContext 创建通信频道，Provider 负责发布数据，Consumer 或 useContext 负责订阅数据。其更新机制绕过父组件的渲染优化，直接通知所有订阅者。",
      "React Context 用于跨组件共享数据，避免 props 层层传递。其底层依赖 Fiber 树和依赖收集： 创建 Context 后，Provider 会把 value 写入 Context 对象；组件调用 useContext 时，Fiber 会读取最近的 Provider 的值，并在 Fiber 上记录对该 Context 的依赖。当 Provider 的 value 变化时，React 会标记并调度所有依赖该 Context 的 Fiber 重新渲染，其它未使用 useContext 的组件不会更新。 这种机制保证了 按需更新：只重渲染真正消费 Context 的组件，提高性能。在并发模式下，React 还为每个渲染器维护独立的 currentValue，确保多根树或并发渲染时 Context 值一致。为了避免无效更新，应尽量拆分 Context、用 useMemo 缓存 value，并让消费组件保持细粒度。"
    ],
    "reference": "/myKMS/knowledge/framework/react#_2-为什么修改-context-后-只有usecontext-的组件才会重新渲染",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 122,
    "question": "React.memo 原理是啥",
    "answer": [
      "**React.memo 是一个高阶组件（HOC），用于优化函数组件的渲染性能。它的核心原理是通过记忆（Memoization）组件的渲染结果，在 props 未变化时跳过重新渲染，直接返回上一次的渲染结果。**",
      "```jsx\n// React.memo 的简化实现逻辑\nfunction memo(Component, arePropsEqual) {\n  let lastProps = null;\n  let lastResult = null;\n  \n  return function MemoizedComponent(nextProps) {\n    // 使用默认的浅比较或自定义比较函数\n    const propsEqual = arePropsEqual \n      ? arePropsEqual(lastProps, nextProps)\n      : shallowEqual(lastProps, nextProps);\n    \n    if (propsEqual && lastResult !== null) {\n      // props 未变化，返回缓存的结果\n      return lastResult;\n    }\n    \n    // props 变化了，重新渲染\n    lastProps = nextProps;\n    lastResult = Component(nextProps);\n    return lastResult;\n  };\n}\n```",
      "React.memo 的核心原理是：",
      "记忆化渲染结果，缓存上一次的渲染输出 浅比较 props，通过 Object.is 比较每个 prop 跳过不必要的渲染，当 props 未变化时直接返回缓存结果 支持自定义比较，通过第二个参数实现更精细的控制"
    ],
    "reference": "/myKMS/knowledge/framework/react#_3-react-memo-原理是啥",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 123,
    "question": "useMemo 原理是啥",
    "answer": [
      "**在 Fiber 上保存一份“上次计算的值和依赖项”，如果依赖没有变化，就直接返回上一次的值，而不是重新计算。**",
      "适合包裹 计算开销较大 或 返回稳定引用（如对象、回调函数）的情况。 useMemo 不会阻止组件重渲染，它只是在渲染过程中复用上一次计算的结果。 如果依赖数组未变，返回的是上次缓存的引用（对象或函数也一样）。 **如果依赖数组省略（即 []），计算只会在初次渲染时执行一次。** 缓存与组件生命周期绑定，自动清理 **依赖项要准确填写，否则可能缓存了过期的值（产生 bug）**"
    ],
    "reference": "/myKMS/knowledge/framework/react#_4-usememo-原理是啥",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 124,
    "question": "hook 缺少依赖, 会导致什么问题(React 闭包陷阱)",
    "answer": [
      "表现:缺少依赖导致过时闭包",
      "```jsx\nfunction Timer() {\n  const [count, setCount] = useState(0);\n  \n  useEffect(() => {\n    const interval = setInterval(() => {\n      // ❌ 问题：这里的 count 始终是 0（初始值）\n      // 因为 useEffect 只在挂载时执行，闭包捕获了初始的 count\n      setCount(count + 1);\n      console.log('Count:', count); // 始终输出 0\n    }, 1000);\n    \n    return () => clearInterval(interval);\n  }, []); // ❌ 缺少 count 依赖\n  \n  return <div>计数: {count}</div>;\n  // 组件首次渲染，count = 0\n  // useEffect 执行，创建定时器，回调函数捕获了此时的 count = 0\n  // 后续 count 更新，但 useEffect 不会重新执行（因为依赖数组为空）\n  // 定时器回调中访问的 count 始终是最初捕获的 0\n}\nfunction Chat() {\n  const [messages, setMessages] = useState([]);\n  const [input, setInput] = useState('');\n  \n  const sendMessage = useCallback(() => {\n    // ❌ 问题：这里的 messages 始终是初始的空数组\n    // 因为 useCallback 在依赖不变时返回缓存的函数\n    const newMessage = { text: input, timestamp: new Date() };\n    setMessages([...messages, newMessage]); // messages 始终是 []\n    setInput('');\n  }, [input]); // ❌ 缺少 messages 依赖\n  \n  return (\n    <div>\n      <input value={input} onChange={(e) => setInput(e.target.value)} />\n      <button onClick={sendMessage}>发送</button>\n    </div>\n  );\n}\n```",
      "缺少依赖的根本原因",
      "1. React 在每次 render 时都会创建新的函数作用域 **Hooks 每次渲染都是全新执行的函数** 2. 如果依赖数组缺少某个在回调或 effect 中使用的变量，React 不会重新运行 Hook 来“刷新”闭包 3. 因此，Hook 内部的函数始终使用旧的变量快照 → 产生 过时闭包",
      "js 角度, 闭包陷阱的根本原因是 JavaScript 的闭包机制：",
      "当一个函数被定义时，它会捕获当前作用域中的变量。 如果这些变量是状态或 props，它们的值在函数定义时被“固定”下来。 当状态或 props 更新时，闭包中的值并不会自动更新。",
      "最佳实践:",
      "依赖声明的黄金法则: 所有在回调中使用的值都应该在依赖数组中声明 启用 ESLint 规则自动检测 使用函数式更新避免依赖状态值"
    ],
    "reference": "/myKMS/knowledge/framework/react#_5-hook-缺少依赖-会导致什么问题-react-闭包陷阱",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 125,
    "question": "useEffect 和 useLayoutEffect 的区别",
    "answer": [
      "**调用时机不同** 会直接影响 UI 渲染顺序和性能",
      "| Hook | 调用时机 | 执行特点 | 适用场景 | | --------------------- | ------------------- | ------------------ | ----------------------------- | | **`useEffect`** | 浏览器完成绘制（paint）后异步执行（异步，下一帧） | 不阻塞浏览器绘制 | 数据获取、订阅、日志、定时器等 | | **`useLayoutEffect`** | DOM 变更后、浏览器绘制前同步执行（同步，阻塞绘制） | **阻塞绘制，先运行副作用，再渲染到屏幕** | 需要**测量 DOM 尺寸/位置** 或在绘制前做样式调整 |",
      "总结",
      "useEffect: **异步执行，不阻塞渲染**(在浏览器绘制后执行 → 性能友好)，适合大多数副作用操作。 useLayoutEffect: **同步执行，阻塞渲染**(在绘制前执行 → 用于 DOM 测量和避免闪烁)，适合需要在绘制前同步完成的副作用操作。",
      "仅在必要时用 useLayoutEffect 比如：读取 DOM 布局信息（测量元素大小）;需要在绘制前同步修改 DOM 样式（避免闪烁)",
      "```\nRender 阶段（计算虚拟 DOM）\n        ↓\nDOM 更新（Commit 阶段）\n        ↓\nuseLayoutEffect（同步执行） 👈 页面还没绘制\n        ↓\n浏览器绘制（Repaint）\n        ↓\nuseEffect（异步执行） 👈 页面已经绘制\n```"
    ],
    "reference": "/myKMS/knowledge/framework/react#_6-useeffect-和-uselayouteffect-的区别",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 126,
    "question": "为何 dev 模式下 useEffect 执行两次？",
    "answer": [
      "react 18后默认开启了 StrictMode, 使开发模式下，React 会刻意“多渲染一次”组件（mount → unmount → 再 mount），用来帮助我们发现不安全的副作用。",
      "借助严格模式的目标是帮助开发者提前发现以下问题：",
      "**不纯的渲染逻辑**：例如，依赖外部状态或直接修改 DOM。 **未正确清理的副作用**：例如，未在 useEffect 的清理函数中取消订阅或清除定时器。 **不稳定的组件行为**：例如，组件在多次挂载和卸载时表现不一致。 通过强制组件挂载和卸载两次，React 可以更好地暴露这些问题, “多跑一次是为了更早发现问题，不是 Bug。”"
    ],
    "reference": "/myKMS/knowledge/framework/react#_7-为何-dev-模式下-useeffect-执行两次",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 127,
    "question": "React state 不可变数据",
    "answer": [
      "**State（状态）必须保持不可变（immutable）** 不可变数据（Immutable Data）:指的是一旦创建就不能直接修改的对象或数组。如果要更新，必须创建一个新对象/数组。",
      "React 为何需要不可变数据",
      "高效的重渲染判断, 性能好 React 使用 浅比较（===） 判断 state 是否变化。 只有引用变化（新对象/数组）才会认为状态更新。",
      "避免副作用 直接修改状态可能会导致意外的副作用，尤其是在异步操作或复杂组件中。 不可变数据确保了状态的更新是纯函数式的，避免了副作用。 不可变数据能保证“之前的渲染”不会被“之后的修改”影响。 可预测性 不可变数据使得状态的变化更加可预测和可追踪。 每次状态更新都会生成一个新的对象或数组，这样可以更容易地调试和追踪状态的变化历史",
      "负责数据可以用 immer 库"
    ],
    "reference": "/myKMS/knowledge/framework/react#_8-react-state-不可变数据",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 128,
    "question": "React state 异步更新",
    "answer": [
      "setState 一般不是立即更新",
      "为什么是异步的? React 把 state 更新设计为 异步的、批量的（batching），主要有两个原因：",
      "性能优化 多次 setState 调用会被合并成一次渲染，避免重复渲染。",
      "保证一致性 React 18 引入 Concurrent Rendering（并发渲染），允许 React 中断、重用、跳过渲染。如果 state 是立即更新的，可能出现“半更新”的 UI 状态。",
      "👉 所以 React 会先记录更新请求，然后在合适的时机（如事件处理结束后或下一个渲染周期）再去批量执行。",
      "如果你需要基于 上一次的 state 来更新，应该用函数式写法.",
      "在哪些场景异步?",
      "在 React 控制的事件处理函数 中（如 onClick、onChange） → 异步批量更新 在 生命周期或 Effect 中 → 异步批量更新 在 异步回调（setTimeout、Promise.then）中 → React 18 之前是同步，18 开始默认也会批量更新",
      "Automatic Batching",
      "同步更新的场景:",
      "非 React 管理的环境中(例如直接在浏览器事件监听器里更新) React DOM API 中的 flushSync React 提供 flushSync 来强制立即刷新 state React 18 之前的版本 在 setTimeout、Promise.then 等异步回调中 setState 是同步执行的 React 18 改为了默认批量处理",
      "**异步更新如何实现的?**",
      "React 的 setState 不会立刻改变 state，而是：",
      "1. 先创建一个 更新对象（Update） 并加入到对应 Fiber 节点的更新队列中。 2. 调度器（Scheduler）决定何时进行 Render → Commit → Paint。 3. 在下一次渲染（Render Phase）时才根据队列计算新的 state。 4. 在 Commit Phase 把新的 state 应用到 DOM 并触发副作用（useEffect）。",
      "因此我们看到的“异步”本质上是 **延迟应用 + 批量处理**。"
    ],
    "reference": "/myKMS/knowledge/framework/react#_9-react-state-异步更新",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 129,
    "question": "React 项目可做哪些性能优化？",
    "answer": [
      "**减少渲染次数、缩短渲染时间、降低资源体积、提升交互流畅度。**",
      "渲染层优化:",
      "减少不必要的渲染 组件拆分：让状态尽量下沉到最小必要范围，避免父组件变化导致大范围子组件重渲染。 React.memo：对函数组件进行浅比较，如果 props 没变化就跳过重渲染。 useMemo / useCallback：缓存计算结果或函数引用，避免因引用变化导致子组件更新。 避免内联函数/对象：频繁生成新引用会触发子组件重新渲染。 Key 使用稳定且唯一的值：避免列表渲染时产生无意义的卸载/挂载 避免昂贵的计算 昂贵计算用 useMemo 缓存 对需要频繁更新的复杂计算结果（如过滤、排序）可用惰性计算或selector（如 Reselect）。 使用webwork 合理使用 Context Context 变化会触发所有消费它的组件重渲染。 对大规模依赖全局数据的场景，可用：redux",
      "资源, 首屏与网络优化",
      "代码拆分（Code Splitting）：用 React.lazy + Suspense 或 webpack dynamic import 按路由/组件拆分包 Tree-shaking / Dead-code Elimination：减少未使用代码。 图片优化：压缩、懒加载（`<img loading=\"lazy\" />`）。 Gzip/Brotli 压缩、HTTP/2、多路复用。 CDN 缓存静态资源。 Server Components / SSR / SSG（Next.js）：减少客户端渲染压力，加快首屏时间。",
      "列表与大数据优化",
      "虚拟列表（Windowing）：react-window、react-virtualized。 对非常大的列表，使用增量渲染或分页加载。"
    ],
    "reference": "/myKMS/knowledge/framework/react#_10-react-项目可做哪些性能优化",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 130,
    "question": "React项目中组件销毁有哪几种方式？",
    "answer": [
      "1. 条件渲染（动态卸载） 2. 路由切换 3. 父组件卸载（连带子组件销毁） 4. useEffect 清理函数（资源释放） 5. 修改 key 强制重新挂载（重置组件） 6. 手动卸载（Portal 或第三方库）"
    ],
    "reference": "/myKMS/knowledge/framework/react#_11-react项目中组件销毁有哪几种方式",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 131,
    "question": "JSX 的本质是什么？",
    "answer": [
      "**JSX 本质上是 JavaScript 的语法糖，它会被编译为 React.createElement(...) 或 React17+ 的 jsx(...) 调用，最终生成普通的 JavaScript 对象（VNode / 虚拟 DOM）。**",
      "| 阶段 | JSX 扮演的角色 | | --------------------- | ------------------------------------------ | | 编译时（Babel） | 把 JSX 转换成 `React.createElement` 或 `jsx` 调用 | | 运行时（React） | 函数调用返回一个 JS 对象（虚拟 DOM） | | 渲染时（React Reconciler） | 根据虚拟 DOM 更新真实 DOM |"
    ],
    "reference": "/myKMS/knowledge/framework/react#_12-jsx-的本质是什么",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 132,
    "question": "如何理解 React Fiber 架构？",
    "answer": [
      "React Fiber 是 React16 引入的新架构，它解决了老版本 同步递归渲染 带来的卡顿问题，让 React 能够实现**可中断、可恢复的异步渲染**。",
      "1. 为什么要有 Fiber",
      "1.1. 老架构（Stack Reconciler）的问题 React15 及以前的 Reconciler 是基于 递归调用 的。当组件树很大时，递归更新是一口气（synchronous）完成的，中途不能暂停。 如果更新耗时几十毫秒甚至上百毫秒，浏览器就无法及时响应用户输入或动画，造成掉帧、卡顿。",
      "👉 需要一种机制能：",
      "把更新拆分成小任务 按优先级执行 在必要时暂停渲染，先处理用户交互，再回来继续",
      "2. Fiber 的核心思想",
      "Fiber 是对 React 更新过程的重构： 把原本递归的更新过程变成可中断的循环（迭代），并用一个 Fiber 数据结构 表示组件树中的每个节点。 每个 Fiber 节点本质上是一个 JS 对象.对应一个 React element.",
      "```jsx\ntype Fiber = {\n  type: any,             // 组件类型（函数/类/DOM标签）\n  stateNode: any,        // 对应的DOM实例或类组件实例\n  child: Fiber | null,   // 第一个子Fiber\n  sibling: Fiber | null, // 下一个兄弟Fiber\n  return: Fiber | null,  // 父Fiber\n  pendingProps: any,     // 新的props\n  memoizedState: any,    // 上一次渲染的state\n  alternate: Fiber | null, // 双缓存指针\n  flags: number,          // 标记需要执行的副作用\n  lanes: Lanes.HighPriority, // 任务优先级\n  ...\n}\n```",
      "双向链表树结构，包含以下关键信息：",
      "组件类型：函数组件、类组件或原生标签。 状态与副作用：Hooks 状态（如 useState）、生命周期标记（如 useEffect）。 调度信息：任务优先级（lane 模型）、到期时间（expirationTime）。 链表指针：child（子节点）、sibling（兄弟节点）、return（父节点）。",
      "3. 双缓存（Double Buffering）",
      "React 维护两棵 Fiber 树：",
      "current 树：当前已显示在页面上的 Fiber 树 workInProgress 树：正在计算更新的新 Fiber 树",
      "更新流程： 在 workInProgress 树上逐个构建 Fiber 节点（可中断） 完成后用一次 commit 阶段把 workInProgress 树切换为 current 树，并更新 DOM 👉 类似“画布双缓冲”，能避免中途渲染不完整。",
      "4. 渲染流程拆分",
      "Fiber 把渲染拆分为两大阶段：",
      "1. Render 阶段（可中断）",
      "也叫 “Reconciliation”(协调) 从根节点开始，按优先级遍历 Fiber 树 构建 workInProgress 树，标记需要更新的节点 如果浏览器需要打断（如用户输入、动画），可以中止，稍后继续",
      "2. Commit 阶段（同步）",
      "把 workInProgress 树的变更一次性提交到真实 DOM 这个阶段必须是同步的，不能被打断（否则 DOM 会不一致）",
      "5. 优先级调度",
      "React Fiber 引入了 优先级调度（Scheduler），在 React18 中与 Concurrent Mode 结合更强大。 React 通过 Lane 模型 管理任务优先级",
      "```\n  // 优先级从高到低\nImmediatePriority（用户输入）\nUserBlockingPriority（悬停、点击）\nNormalPriority（数据请求）\nLowPriority（分析日志）\nIdlePriority（非必要任务）\n```",
      "调度策略： 高优先级任务可抢占低优先级任务的执行权。 过期任务（如 Suspense 回退）会被强制同步执行。",
      "高优先级：用户输入、焦点、动画 低优先级：不紧急的列表渲染、后台数据加载 Fiber 节点在被调度时会携带类似自己的 expirationTime（过期时间），React 根据优先级决定先处理谁。",
      "**React Fiber = 用链表数据结构重写组件树 + 分片可中断渲染 + 双缓冲提交 + 优先级调度**",
      "useTransition: Render 阶段可打断并延迟，Commit 阶段照常执行，但可能推迟到稍后。 对 Render / Commit 的影响:Render 阶段：被标记为 transition 的更新，会放到低优先级队列里。高优先级（比如用户输入）会先 Render & Commit。低优先级 Render 可能会被 打断、延迟、重做。Commit 阶段：Commit 依旧是一次性、不可中断的。但由于 Render 被延迟，Commit 也可能推迟发生。用户可能先看到旧 UI（输入框响应快），再看到新 UI（列表刷新）",
      "useDeferredValue: Render 阶段被拆分成两批，Commit 阶段也可能分成多次。 对 Render / Commit 的影响:Render 阶段：依赖 deferredValue 的组件渲染会延后。React 先 Render 其他部分 → Commit → UI 更新一部分。再 Render 依赖 deferredValue 的部分 → Commit → UI 补齐。Commit 阶段：可能出现 多次 Commit：先 Commit 高优先级的 UI（比如输入框内容）。再 Commit 低优先级的 UI（比如搜索结果）。",
      "Fiber 架构是机制，Concurrent Mode 是策略。 Fiber 提供了能力，并发模式利用了这些能力。 具体来说： Fiber 提供能力： 将递归变成可中断的循环（time slicing） 支持任务优先级和调度 双 Fiber 树切换，支持渐进渲染 Concurrent Mode 使用这些能力： 通过 useTransition 把某些更新标记为低优先级 → Fiber 可以延迟它们 通过 Suspense 控制 UI 的显示顺序 → Fiber 可以中断和恢复渲染 通过 startTransition、useDeferredValue 等 Hook → 利用 Fiber 的调度机制分配任务",
      "Fiber 是基础架构：解决了 React 渲染不可中断的问题。 Concurrent Mode 是应用层能力：利用 Fiber 提供的可中断渲染和任务调度，实现并发渲染、优先级管理和流畅的用户体验。 没有 Fiber，就没有 Concurrent Mode。"
    ],
    "reference": "/myKMS/knowledge/framework/react#_13-如何理解-react-fiber-架构",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 133,
    "question": "vue3 diff 算法 与react diff算法",
    "answer": [
      "共同点:",
      "| 特性 | Vue3 与 React 都有 | | ----------------- | --------------------------- | | **同层比较** | 只比较同一层级节点，不考虑跨层级移动 | | **类型判断复用** | 节点类型相同则复用并继续比较子节点，不同则直接销毁重建 | | **key 辅助列表 diff** | 通过 key 判断列表节点是否可复用、是否需要移动 | | **复杂度 O(n)** | 放弃最优解，追求可接受的线性时间复杂度 |",
      "差异点:",
      "| 方面 | Vue 3 | React | | -------------- | ---------------------------------------------------------------------------------------- | --------------------------------------------------------- | | **整体架构** | 运行时 + 编译时框架，编译器能在构建阶段分析模板，生成优化提示（PatchFlag）。<br>Diff 阶段根据这些标记跳过大部分无需更新的节点。 | 纯运行时框架，无法在编译期静态分析 JSX，只能在运行时比较新旧 VDOM。 | | **静态节点处理** | **静态提升**：模板中完全静态的节点会在编译时提取出来，只创建一次，不参与 diff。<br>**PatchFlag** 精确标记动态绑定的属性或子节点，使得更新更有针对性。 | 没有静态提升，所有节点每次 render 都要重新比较。可以通过 `memo`、`useMemo` 等手动优化。 | | **列表 diff 策略** | 使用 **双端指针算法（双指针 + 最长递增子序列 LIS）** 来计算最小移动次数。<br>即先比较两端相同节点，然后对中间乱序部分用 LIS 算法最小化 DOM 移动。 | 通过单向遍历 + key 映射来识别需要移动、插入、删除的节点，没有使用 LIS，只保证最小复用，不一定最少移动。 | | **更新粒度** | 模板编译后知道哪些部分是动态的，只 diff 有变化的部分 → 更新粒度细。 | 组件 render 后得到新的 VDOM 树，需遍历整个子树 → 更新粒度较粗。 | | **组件更新策略** | 有**响应式系统**（依赖收集 + effect），组件只会在依赖变化时重新渲染，减少 diff 次数。 | 没有内置响应式，组件 render 受父组件传入 props 或 state 改变驱动。 | | **fiber 架构** | Vue 3 仍是递归遍历 vnode，使用位运算优化，但没有 fiber 异步可中断更新。 | React 16+ 使用 Fiber，将 diff 拆分为可中断的单元，实现并发调度。 |"
    ],
    "reference": "/myKMS/knowledge/framework/react#_14-vue3-diff-算法-与react-diff算法",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 134,
    "question": "React 事件",
    "answer": [
      "React 事件系统是 React 为了实现 跨浏览器一致性、性能优化、与 Fiber 协调 而构建的一套合成事件机制（Synthetic Events）。 它不是直接把事件监听器绑定在 DOM 节点上，而是在内部做了一层封装。",
      "跨浏览器兼容 性能优化（事件委托） 直接给大量子节点绑定事件会消耗内存、频繁注册/销毁。 React 把事件委托到根容器上（React17 前是 document，React17+ 是组件挂载的根 DOM 节点）。 与 Fiber 更新配合 React 需要在 Reconciliation / Commit 阶段动态添加或删除事件，同时可以在事件回调中控制批量更新（batching）。",
      "合成事件（SyntheticEvent） React 在触发事件时，会把原生事件包装成一个合成事件对象，它：",
      "提供与原生事件相同的属性（target、type、clientX…），保证跨浏览器一致。 对象来自 React 的事件池（event pool），性能优化：",
      "React 渲染时不会直接给 button 注册原生 onclick，而是：",
      "在根容器上注册一次统一的 click 监听器。 保存 button 对应的回调到 Fiber 节点的 props 中。",
      "用户点击 button 时：",
      "原生事件冒泡到根容器。 React 根监听器捕获到事件，根据事件的 target 找到对应 Fiber 节点。 按虚拟 DOM 树的层级依次触发相关的合成事件回调。",
      "👉 好处：减少原生事件绑定次数 + 跨浏览器统一行为。",
      "React17 之前：统一把事件绑定到 document。 React17 之后：事件绑定改为绑定在根容器 DOM 节点（如 root），避免多个 React 应用之间的事件冲突，更易与原生事件混用。 React 在合成事件回调中会自动开启批处理（batching），把多次 setState 合并为一次渲染更新："
    ],
    "reference": "/myKMS/knowledge/framework/react#_15-react-事件",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 135,
    "question": "React batchUpdate 机制",
    "answer": [
      "React 的 batchUpdate（批处理更新）机制 是一种优化策略，旨在将多个状态更新合并为一次渲染，减少不必要的组件重新渲染次数，从而提高性能。",
      "核心机制",
      "1. 异步合并更新 当在 同一执行上下文（如同一个事件处理函数、生命周期方法或 React 合成事件）中多次调用状态更新（如 setState、useState 的 setter 函数），React 不会立即触发渲染，而是将多个更新收集到一个队列中，最终合并为一次更新，统一计算新状态并渲染。",
      "2. 更新队列 React 内部维护一个更新队列。在触发更新的代码块中，所有状态变更会被暂存到队列，直到代码执行完毕，React 才会一次性处理队列中的所有更新，生成新的虚拟 DOM，并通过 Diff 算法高效更新真实 DOM。",
      "触发批处理的场景",
      "React 合成事件 如 onClick、onChange 等事件处理函数中的多次状态更新会自动批处理。 React 生命周期函数 React 18+ 的自动批处理增强 React 18 引入 createRoot 后，即使在异步操作（如 setTimeout、Promise、原生事件回调）中的更新也会自动批处理：",
      "绕过批处理的场景:",
      "React 17 及之前的异步代码 在 setTimeout、Promise 或原生事件回调中的更新默认不会批处理，每次 setState 触发一次渲染： 手动强制同步更新 使用 flushSync（React 18+）可强制立即更新，绕过批处理",
      "设计目的",
      "性能优化 避免频繁的 DOM 操作，减少浏览器重绘和回流，提升应用性能。",
      "状态一致性 确保在同一个上下文中多次状态变更后，组件最终基于最新的状态值渲染，避免中间状态导致的 UI 不一致。"
    ],
    "reference": "/myKMS/knowledge/framework/react#_16-react-batchupdate-机制",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 136,
    "question": "React concurrency 并发机制是什么, 怎么体现的",
    "answer": [
      "1. 背景：为什么需要并发机制 在 React16 之前（Stack Reconciler）：",
      "React 渲染是 同步阻塞式 的： 一旦开始调和（reconcile），就会一路递归下去直到渲染完成。 如果组件树很大，渲染会长时间占用主线程。 期间浏览器不能响应用户输入、动画、滚动 → 卡顿（jank）。",
      "在现代 Web 应用中：",
      "用户交互、网络响应、动画等都在争夺主线程。 我们希望 渲染是可中断、可调度、分优先级的。",
      "👉 Concurrent Rendering（并发渲染） 就是 React Fiber 在 16 以后引入的核心能力，真正实现在 渲染过程中可以打断、暂停、恢复、丢弃。",
      "旧:",
      "```\nupdate → render → commit\n         (整棵树一次性调和)\n```",
      "新:",
      "```\nupdate → render(可被打断、分段) → commit(同步)\n```",
      "render 阶段是可中断的：React Fiber 允许每次只渲染一小段，然后把控制权交回浏览器。 commit 阶段是同步的：最终将变更应用到 DOM 的步骤必须是原子的。 👉 这样，长时间的渲染任务可以被拆分成多个“小工作单元”，在浏览器有空闲时再继续。",
      "2. Fiber 是并发的基础",
      "Fiber 是 React 16 引入的数据结构与调度模型：",
      "每个组件对应一个 Fiber 节点。 通过 Fiber 链表可以实现 增量渲染（incremental rendering）。 支持为不同更新分配 优先级（lanes）。",
      "渲染调度大致流程：",
      "把更新放入任务队列（Fiber root）。 按优先级选择下一个任务。 每次工作单元渲染后检查是否需要让出主线程（shouldYield）。",
      "如果需要，先交还浏览器，下次空闲时再继续。",
      "3. 并发机制的工作原理：",
      "**时间分片（Time Slicing）**： React 将渲染任务拆分为多个小片段，每个片段在主线程空闲时执行。这使得浏览器可以在渲染过程中处理用户输入和其他高优先级任务，避免长时间的渲染阻塞用户交互。 **优先级调度（Priority Scheduling）**： React 为不同的更新分配不同的优先级。高优先级的更新（如用户输入）会被优先处理，而低优先级的更新（如数据预加载）可以在空闲时处理。 **可中断渲染（Interruptible Rendering）**： 在并发模式下，React 可以中断当前的渲染任务，处理更高优先级的任务，然后再恢复之前的渲染。这确保了应用在长时间渲染过程中仍能保持响应性。",
      "4. 并发机制的优势：",
      "**提升响应性**： 通过优先处理高优先级任务，React 能够更快地响应用户输入，提升用户体验。 **优化性能**： 将渲染任务拆分为小片段，避免长时间的渲染阻塞，提升应用的整体性能。 **更好的资源利用**： 在主线程空闲时处理低优先级任务，充分利用系统资源。",
      "Concurrency 的体现",
      "React18 默认开启了并发特性（通过 createRoot）。",
      "常见体现：",
      "可中断渲染 当长列表渲染时： 在同步模式下，渲染过程会一次性阻塞线程。 在并发模式下，如果用户在渲染中点击了按钮，React 会暂停当前渲染，优先处理更高优先级的事件（如点击），然后再继续剩下的渲染 startTransition 有些更新是紧急的（urgent）（如输入框输入），有些是非紧急的（non-urgent）（如搜索结果列表更新）。 startTransition 把里面的更新标记为低优先级，可以被打断 useDeferredValue 延迟某些状态的更新，让界面先响应用户交互，再处理耗时渲染。 Suspense 并发机制让 React 能够更好地协调数据请求和组件加载，例如： 当异步数据尚未返回时，可以先显示 fallback，再在数据准备好后无缝渲染。 React18 的 automatic batching 在并发模式下，即便在 Promise 回调、setTimeout 中，也会自动批处理多次 setState，减少重复渲染。",
      "**React Concurrency 是通过 Fiber 架构和调度器实现的一套可中断、可恢复、可优先级调度的渲染机制。** 它让 React 可以更好地响应用户交互，避免长时间阻塞主线程，并通过 startTransition、useDeferredValue、Suspense 等 API 显式利用这一能力。 并发机制不是“多线程”，而是让 React 的渲染任务能与浏览器任务“交替进行”，从而显著提升用户体验。",
      "| 特性 | 同步模式（legacy） | 并发模式（concurrent） | | ----- | ----------------- | ---------------------------------------------------------- | | 渲染 | 一次性同步完成 | 可中断、可恢复、可丢弃 | | 优先级 | 不区分 | 有优先级，先处理紧急任务 | | 批处理 | 仅事件回调中 | 全局自动批处理 | | 交互流畅度 | 易卡顿 | 更流畅，响应更及时 | | API | `ReactDOM.render` | `ReactDOM.createRoot`，`startTransition`，`useDeferredValue` |"
    ],
    "reference": "/myKMS/knowledge/framework/react#_17-react-concurrency-并发机制是什么-怎么体现的",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 137,
    "question": "为何 Hooks 不能放在条件或循环之内？",
    "answer": [
      "一个组件中的 hook 会以链表的形式串起来， FiberNode 的 memoizedState 中保存了 Hooks 链表中的第一个 Hook。",
      "在更新时，会复用之前的 Hook，如果通过了条件或循环语句，增加或者删除 hooks，在复用 hooks 过程中，会产生复用 hooks状态和当前 hooks 不一致的问题。",
      "Hooks 本质上是 函数组件的状态机 + 调度机制。 核心思想: 1. React 内部维护了一个 hooks 数组（链表），存放当前组件的所有 Hook 状态。 2. 每次渲染时，React 会按 调用顺序 执行 Hook。 3. useState、useEffect 等 Hook 本质上就是操作 hooks 数组对应的节点。",
      "自定义 Hook：就是函数，里面可以用内置 Hook 来组合逻辑。"
    ],
    "reference": "/myKMS/knowledge/framework/react#_18-为何-hooks-不能放在条件或循环之内",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 138,
    "question": "useEffect 的底层是如何实现的",
    "answer": [
      "useEffect 的角色",
      "useEffect 是一种 副作用 Hook，用来在 DOM 更新（commit）后 执行副作用逻辑，例如数据请求、订阅、手动操作 DOM 等。 React 把副作用与渲染逻辑分离，保证渲染过程（render 阶段）是纯函数、可中断、可回溯的，而副作用统一推迟到 commit 阶段。",
      "useEffect 依赖变化的处理",
      "依赖数组的比较使用 Object.is()，只有依赖变化时才重新执行 useEffect。 更新阶段，React 遍历旧 effect，并先执行清理函数，然后再执行新的 effect。",
      "React 渲染更新分为两个阶段：",
      "| 阶段 | 说明 | 是否允许副作用 | | ------------- | ----------------------- | --------------------- | | **Render 阶段** | 计算出新的 Fiber 树（可以被打断、重做） | ❌ 不允许（保持纯函数） | | **Commit 阶段** | 把变更提交到 DOM（同步） | ✅ 执行副作用（包括 useEffect） |",
      "所以：",
      "useEffect 中注册的回调 不会在 render 阶段立即执行； 而是记录在 Fiber 节点上，等到 commit 阶段 DOM 更新完成后，浏览器完成绘制后（宏任务后）再异步调用。",
      "在 Fiber 节点上，每个函数组件会维护一个 **Hook 链表**：",
      "```\ntype Hook = {\n  memoizedState: any,        // 保存副作用依赖数组\n  next: Hook | null          // 指向下一个 Hook\n}\n\ntype Effect = {\n  create: () => (() => void) | void  // 副作用函数\n  destroy: (() => void) | void       // 清理函数\n  deps: any[] | null                 // 依赖数组\n  tag: number                        // 副作用标记\n  next: Effect | null                // 形成循环链表\n}\n```",
      "每个 useEffect 会创建一个 Hook 节点。 在这个 Hook 上保存一个 Effect 对象。 所有 Effect 通过循环链表挂在 Fiber 节点的 updateQueue 上，方便 commit 阶段统一处理。",
      "调用 useEffect 时发生了什么 当组件函数执行到 useEffect 时（位于 render 阶段）：",
      "1. React 通过 mountEffect（首渲染）或 updateEffect（更新）来处理。 它不会立刻调用副作用函数，而是： 保存 { create, deps } 到 Hook 中； 打上 Passive 副作用标记； 2. 如果依赖数组发生变化，还会记录需要销毁上一次副作用。 3. 继续执行后续 Hook，直到组件渲染完毕。 👉 Render 阶段结束后，React 已经知道哪些 Effect 需要执行或清理。",
      "Commit 阶段执行流程 在 commit 阶段，React 主要做两件事：",
      "1）DOM 更新 完成 Fiber 树标记的增删改 DOM 操作。",
      "2）副作用处理 在 DOM 更新完成后： React 会遍历所有带有 Passive 标记的 Fiber 节点。 对每个 Effect： 如果有上一次的 destroy 函数 → 先执行清理。 调用当前 create 副作用函数 → 并把返回值保存为新的 destroy。 这一过程默认使用 scheduler 异步调度（相当于 setTimeout），保证副作用不会阻塞浏览器绘制。",
      "// seEffect 与 useLayoutEffect 区别",
      "| Hook | 执行时机 | 常见用途 | | ----------------- | ----------------------------- | ------------------- | | `useLayoutEffect` | commit 阶段 DOM 变更后、浏览器绘制前，同步执行 | 需要读取或修改布局的操作（如测量尺寸） | | `useEffect` | 浏览器绘制后异步执行 | 数据请求、订阅、日志等不会影响首屏绘制 |",
      "**总结**（面试要点）",
      "useEffect 本质是 在 Fiber 上注册副作用对象。 副作用在 commit 阶段（DOM 更新后）按需异步执行。 通过依赖数组 deps 判断是否重新运行或跳过。 React 通过链表管理所有 Hook 和 Effect，方便批量处理。 useEffect 保证 render 阶段纯净，而副作用延迟到合适时机执行。"
    ],
    "reference": "/myKMS/knowledge/framework/react#_19-useeffect-的底层是如何实现的",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 139,
    "question": "React 组件渲染和更新的全过程",
    "answer": [
      "React 组件的渲染和更新过程涉及多个阶段，包括 **初始化、渲染、协调、提交、清理** 等 以下是 React 组件渲染和更新的全过程，结合源码逻辑和关键步骤进行详细分析。",
      "1. 整体流程概述 React 的渲染和更新过程可以分为以下几个阶段：",
      "初始化阶段：创建 Fiber 树和 Hooks 链表。 渲染阶段：生成新的虚拟 DOM（Fiber 树）。 协调阶段：对比新旧 Fiber 树，找出需要更新的部分。 提交阶段：将更新应用到真实 DOM。 清理阶段：重置全局变量，准备下一次更新。",
      "2. 详细流程分析",
      "（1）初始化阶段",
      "触发条件：组件首次渲染或状态/属性更新。 关键函数：render、createRoot、scheduleUpdateOnFiber。 逻辑： 通过 ReactDOM.render 或 createRoot 初始化应用。 创建根 Fiber 节点（HostRoot）。 调用 scheduleUpdateOnFiber，将更新任务加入调度队列。",
      "（2）渲染阶段",
      "触发条件：调度器开始执行任务。 关键函数：performSyncWorkOnRoot、beginWork、renderWithHooks。 逻辑： 调用 performSyncWorkOnRoot，开始渲染任务。 调用 beginWork，递归处理 Fiber 节点。 对于函数组件，调用 renderWithHooks，执行组件函数并生成新的 Hooks 链表。 对于类组件，调用 instance.render，生成新的虚拟 DOM。 对于 Host 组件（如 div），生成对应的 DOM 节点。",
      "（3）协调阶段",
      "触发条件：新的虚拟 DOM 生成后。 关键函数：reconcileChildren、diff。 逻辑： 调用 reconcileChildren，对比新旧 Fiber 节点。 根据 diff 算法，找出需要更新的节点。 为需要更新的节点打上 Placement、Update、Deletion 等标记。",
      "（4）提交阶段",
      "触发条件：协调阶段完成后。 关键函数：commitRoot、commitWork。 逻辑： 调用 commitRoot，开始提交更新。 调用 commitWork，递归处理 Fiber 节点。 根据节点的标记，执行 DOM 操作（如插入、更新、删除）。 调用生命周期钩子（如 componentDidMount、componentDidUpdate）。",
      "（5）清理阶段 触发条件：提交阶段完成后。 关键函数：resetHooks、resetContext。 逻辑： 重置全局变量（如 currentlyRenderingFiber、currentHook）。 清理上下文和副作用。 准备下一次更新",
      "React 渲染分为两阶段：Render 阶段负责根据 props 和 state 生成新的 Fiber 树，并进行 Diff；Commit 阶段把变更一次性应用到真实 DOM。 首次渲染是完整构建 Fiber 树并创建 DOM，更新时只计算需要变更的部分。 在 React18 并发模式下，Render 阶段可被打断以保证用户交互优先，Commit 阶段始终同步执行"
    ],
    "reference": "/myKMS/knowledge/framework/react#_20-react-组件渲染和更新的全过程",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 140,
    "question": "React 优化",
    "answer": [
      "1. React.memo：对于函数组件，React.memo 可以避免不必要的重新渲染。当组件的 props 没有变化时，React 会跳过重新渲染过程。 2. 在 JSX 中创建匿名函数或内联函数会导致每次渲染时都重新创建函数，从而触发子组件的重新渲染。尽量避免这种做法。 使用useCallback包裹避免重复创建函数, 避免重复渲染. 3. 使用唯一且稳定的key, 确保列表渲染正常 4. 在 React 中，函数的重新创建和复杂计算会影响性能，尤其是在父组件频繁重新渲染时。useMemo 可以缓存计算结果，而 useCallback 则缓存函数的引用。 5. 虚拟化 react-virtualized 6. 懒加载(Lazy Loading) 按需加载(Code Splitting) 使用 React 的 Suspense 和 lazy 实现懒加载, 配合import() 方法实现 7. 使用 webpack 的代码分割 8. webpack Tree shaking 基于 es6 ESM 是静态结构，能被编译阶段静态分析。 手动优化大型库的 Tree Shaking 如dayjs, lodash 9. webpack-bundle-analyzer 10. 服务器端渲染（SSR）与静态站点生成（SSG） 11. 图片懒加载"
    ],
    "reference": "/myKMS/knowledge/framework/react#_21-react-优化",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 141,
    "question": "在 React 应用中如何排查性能问题?",
    "answer": [
      "1. 浏览器层面（渲染、网络、JS 执行) 2. React 本身（组件渲染、状态管理、diff 算法） React DevTools Profiler 常见问题: 不必要的 re-render(状态提升过多，导致全局刷新,props 传递引用类型（对象/数组）时，每次 render 都创建新引用,解决：React.memo、useCallback、useMemo、状态下沉); 大列表渲染卡顿(列表虚拟化);重复计算 / 重逻辑;昂贵的 DOM 操作;"
    ],
    "reference": "/myKMS/knowledge/framework/react#_23-在-react-应用中如何排查性能问题",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 142,
    "question": "useTransition useDeferredValue debounce 对比与原理",
    "answer": [
      "| 特性 | `useTransition` | `useDeferredValue` | 防抖（Debounce） | | ------------- | ----------------------------------- | ----------------------------- | ------------------------ | | **React 内置** | ✅ 是 | ✅ 是 | ❌ 否（需自定义或使用第三方库） | | **控制粒度** | 高：可控制更新的启动时机和优先级 | 中：延迟值更新，适用于父组件传递的值 | 低：基于时间间隔控制更新频率 | | **适用场景** | 用户交互引发的状态更新，需控制更新优先级和反馈 | 父组件传递的频繁更新值，需避免子组件频繁渲染 | 输入框、搜索框等用户输入场景，减少频繁触发的操作 | | **是否阻塞 UI** | ❌ 否，更新被标记为低优先级，不会阻塞用户输入 | ❌ 否，延迟更新不会阻塞 UI，但可能导致 UI 延迟更新 | ❌ 否，延迟执行函数，避免频繁触发 | | **是否可中断** | ✅ 是，新的高优先级更新会中断当前低优先级更新 | ✅ 是，React 会根据当前任务的优先级处理更新 | ❌ 否，一旦设置时间间隔，无法中断 | | **是否自动适应性能** | ✅ 是，React 会根据设备性能自动调整更新策略 | ✅ 是，React 会根据设备性能自动调整延迟更新 | ❌ 否，固定的时间间隔不考虑设备性能 | | **是否需要额外配置** | ❌ 否，直接使用即可 | ❌ 否，直接使用即可 | ✅ 是，需要设置延迟时间和可能的取消机制 | | **是否影响组件渲染** | ✅ 是，可通过 `isPending` 状态判断更新是否完成，提供反馈 | ✅ 是，可通过比较原始值和延迟值判断是否需要更新 UI | ✅ 是，延迟执行函数，减少不必要的渲染 | | **是否适用于第三方库** | ❌ 否，需控制状态更新函数 | ✅ 是，适用于无法控制状态更新的场景 | ✅ 是，适用于控制频繁触发的函数 |"
    ],
    "reference": "/myKMS/knowledge/framework/react#_24-usetransition-usedeferredvalue-debounce-对比与原理",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 143,
    "question": "react suspence 与 lazy() 底层实现原理是什么?",
    "answer": [
      "**React.lazy 的底层是让组件在未加载时 抛出一个 Promise，而 Suspense 则在 Fiber 渲染时捕获这个 Promise，挂起渲染并显示 fallback，等 Promise resolve 后恢复渲染。**",
      "Suspense 作用:用于在子树中捕获“未就绪状态”，显示一个 fallback UI（比如 loading）。;与 ErrorBoundary 类似，只不过它捕获的是 **“Promise 挂起”。**",
      "React.lazy 把动态加载的组件封装成一个“会在未加载时抛出 Promise”的特殊组件。",
      "Suspense 作为“捕手”，在渲染子树时捕获这个 Promise，展示 fallback，并在 Promise resolve 后再重新渲染。",
      "Suspense,底层原理:",
      "渲染子组件时，如果子组件内部调用 lazy 还没 resolve，就会抛出一个 Promise。 React Fiber 架构检测到渲染过程中抛出了 Promise，会暂停当前 Fiber 树的渲染。 React 将这个 Promise 挂到 Suspense 边界上，等 Promise resolve 后重新触发渲染。 在等待期间，Suspense 显示 fallback。"
    ],
    "reference": "/myKMS/knowledge/framework/react#_25-react-suspence-与-lazy-底层实现原理是什么",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 144,
    "question": "react 如何实现国际化",
    "answer": [
      "i18n 实现国际化",
      "1. 动态语言切换 + 按需加载",
      "动态import+映射表,页面级组件在useEffect或路由加载时调用i18n.addResources(),减少初始打包体积，提高首屏加载速度, 使用缓存(localStorage / IndexedDB) 2. 日期/时间/数字/货币格式化",
      "3. 自动提取翻译 Key & 多语言管理 i18next-scanner 扫描",
      "4. i18n + 路由（多语言 URL） :lang 作为路由参数, 配合effect, navigate loadLanguage实现",
      "5. i18n 国际化对 React 组件性能的影响？如何优化？ react-i18next 会在语言切换时触发重新渲染依赖翻译的组件: 精准使用 useTranslation('namespace')(语言文件可以按 namespace 划分)，避免全局组件不必要渲染; Trans 组件只包裹需要翻译的部分; 使用 memoization (React.memo) 避免深层组件重复渲染, 避免重复 useTranslation, 子组件可通过 props 传递翻译后的文本, react-i18next 使用 Context + Hook，组件通过 useTranslation() 获取翻译函数 t()"
    ],
    "reference": "/myKMS/knowledge/framework/react#_26-react-如何实现国际化",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 145,
    "question": "自己写的hooks",
    "answer": [
      "简单的 useLocalStorage; 基于useRequest封装项目使用useDict 提供 dict 功能,支持单个, 批量获取dict 初始化, 缓存, 刷新, getLabel; - useFlatOrgTree 获取机构树, 后端是List 的结构, 转化成Tree 结构, 还有把Tree 结构转化成list机构; useModal 把弹窗状态和打开关闭方法封装成一个hook(open 是的把对象传入); usePermission 判断权限, useRequset: 基于 vueuse的useAsyncState 封装的 useRequset, 返回state,isLoading,isReady,run, 支持配置showMessage,formatResult,initialState, immediate等; useSearchTable 将 table 操作封装再里面; useConfirm"
    ],
    "reference": "/myKMS/knowledge/framework/react#_27-自己写的hooks",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 146,
    "question": "Redux Toolkit",
    "answer": [
      "1. createSlice 内部用 Immer，允许你写“可变写法”，但底层会生成不可变的新 state。",
      "2. createAsyncThunk 内部是如何工作的？ 生成一个 thunk action（函数），会在调用时触发一个 生命周期三段式： pending → 异步任务开始 fulfilled → 异步任务成功 rejected → 异步任务失败 内部用 dispatch 多次派发 action，而不是只派发一次。",
      "3.Redux Toolkit 如何优化性能 1.内置 Immer + useSelector 的 浅比较，减少无效渲染。 2.createEntityAdapter 提供规范化数据结构（normalized state），避免深层次 diff。 3. 配合 memo / useMemo / useCallback，只渲染必要组件。",
      "4. 如果要在 Redux Toolkit 里实现一个 Undo/Redo 功能，怎么做？ 在 reducer 里维护一个 past[]、present、future[] 三段式结构。 每次 dispatch：把当前 present 推入 pastpresent 替换为新 state Undo → 从 past 弹出最后一个到 present，并把原先的 present 推入 future"
    ],
    "reference": "/myKMS/knowledge/framework/react#_28-redux-toolkit",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 147,
    "question": "react usestate usereducer useref useeffece 原理",
    "answer": [
      "环形队列就是：链表的最后一个节点的 next 指针 指向头节点，形成一个环。",
      "useState 的原理 原理可以拆解成三个部分：状态保存、状态更新 和 触发渲染。 useState 把状态保存在 Fiber 的 Hook 链表中，setState 通过更新队列记录变化，并触发 Fiber 的调度和重新渲染，最终在下一次执行组件时计算出新状态。 React 为什么需要 useState: 在函数组件里，普通的局部变量在函数执行完后会被销毁。React 通过 useState 把状态存放在 Fiber 节点 上，这样每次函数组件重新执行时，状态不会丢失。 状态保存原理: 每个组件对应一个 Fiber 节点。Fiber 上有一个 memoizedState 属性，存储链表结构，保存多个 Hook 的状态。 状态更新原理: 调用 setState 时, 会创建一个 更新对象, 放到对应 Hook 的更新队列里, 然后 React 会调度一次 组件重新渲染 触发渲染机制: setState 本质上调用了 React 的 调度器，会标记当前 Fiber 为需要更新，然后触发一次 Fiber 调度 → Diff → commit → 重新渲染 流程。",
      "usereducer原理 useState 的原理一样, 是把状态更新逻辑抽出来交给 reducer 函数. 其实 React 内部 useState 就是 useReducer 的语法糖。 useReducer 本质上和 useState 一样，状态保存在 Fiber Hook 链表里，更新通过环形队列记录；不同的是，它通过 reducer(state, action) 把更新逻辑交给用户，让状态更新更可控。",
      "```\nfunction useState(initialState) {\n    return useReducer((state, action) => {\n        return typeof action === 'function' ? action(state) : action;\n    }, initialState);\n}\n```",
      "useRef 原理 useRef 的作用就是：给你一个不会变的“盒子”来存放东西。 和其他 Hooks 一样，useRef 也存放在 Fiber 的 Hook 链表里。 不同点在于：初次渲染时，React 会创建一个对象 { current: initialValue }，并保存到 memoizedState。之后的渲染，直接返回同一个对象。 每次调用 useRef，拿到的都是同一个对象引用；修改 .current 不会触发渲染，因为 React 不会监听这个值的变化。",
      "useeffece 原理 React 提供 useEffect，把这些副作用挂到 Fiber 的副作用链表，在 DOM 更新提交之后 执行。(commit 阶段执行) 可以分成三个阶段: 初次渲染, 提交阶段, 更新渲染 updateQueue（effect 链表） layoutEffect（同步执行）：在 DOM 更新后，浏览器绘制之前执行（会阻塞渲染）。 effect（即 useEffect）（异步执行）：在浏览器完成绘制后执行，不会阻塞渲染 useEffect 的原理就是：在渲染时收集副作用，存到 Fiber 的effect链表；在commit阶段统一执行，并根据依赖数组判断是否需要重新运行，同时处理清理函数。"
    ],
    "reference": "/myKMS/knowledge/framework/react#_29-react-usestate-usereducer-useref-useeffece-原理",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 148,
    "question": "react useEffect 依赖项为数据或者对象, 如何处理",
    "answer": [
      "当 useEffect 的依赖项是数组或对象时，你可能会遇到一个陷阱：useEffect 会在每次组件重新渲染时都执行，即使数组或对象的内容“看起来”没有变化.",
      "React 组件每次重新渲染时，在函数体内部定义的对象或数组都会被重新创建一个新的实例。比较时Object.is 始终为false,因此 effect 会重新执行",
      "方案一：解构原始值 (Destructuring Primitives) 取只关心其中的某些原始值",
      "方案二：使用 useMemo 稳定引用 (Memoization) useMemo 会缓存这个对象/数组，只有当 useMemo 自己的依赖项改变时，它才会重新创建一个新的对象/数组。",
      "方案三：序列化为字符串 (Stringification) 把它们转换成一个 JSON 字符串，因为字符串是原始值。",
      "方案四：使用自定义 Hook (Deep Compare) 创建一个自定义 Hook（例如 useRef）来存储前一个值，并在 useEffect 内部手动进行“深度比较”。"
    ],
    "reference": "/myKMS/knowledge/framework/react#_30-react-useeffect-依赖项为数据或者对象-如何处理",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 149,
    "question": "jsx 为什么只允许有一个父节点",
    "answer": [
      "**因为 JSX 最终会被编译成 JavaScript 函数调用，而 JavaScript 的函数一次只能返回一个值。**",
      "核心原理：JSX 是 React.createElement() 的语法糖.",
      "你写的 JSX 代码并不会直接在浏览器中运行。它需要一个转译器（最常见的是 Babel）将其转换为浏览器能理解的纯 JavaScript。 在 React 中，你写的每一段 JSX 标签都会被转译成一个 React.createElement(component, props, ...children) 函数调用 这个函数调用的返回值是一个 JavaScript 对象（用来描述你想要创建的 UI，也就是 React 元素或“虚拟 DOM”节点）"
    ],
    "reference": "/myKMS/knowledge/framework/react#_31-jsx-为什么只允许有一个父节点",
    "source": "/myKMS/knowledge/framework/react"
  },
  {
    "id": 150,
    "question": "Webpack 的工作流程",
    "answer": [
      "Webpack 的工作流程",
      "1. 入口（Entry）：从指定文件（如 index.js）开始分析依赖。 2. 依赖图（Dependency Graph）：递归构建模块间的依赖关系。 3. 加载器（Loaders）：转换非 JS 资源（如编译 Sass、处理图片）。 4. 插件（Plugins）：在构建生命周期中执行优化任务。 5. 输出（Output）：生成优化后的静态文件（如 bundle.js）。"
    ],
    "reference": "/myKMS/knowledge/framework/vite#_1-webpack-的工作流程",
    "source": "/myKMS/knowledge/framework/vite"
  },
  {
    "id": 151,
    "question": "Webpack 中的 Loaders 和 Plugins 有什么区别",
    "answer": [
      "| 对比项 | **Loader** | **Plugin** | | :--- | :----------------------------------------- | :---------------------------------------------------------- | | 作用阶段 | 文件加载、转换阶段（打包前） | 编译、打包的整个生命周期 | | 操作对象 | 单个模块文件（JS、CSS、图片等） | 整个编译过程（模块、资源、chunk、输出） | | 类型 | 转换器（Transformer） | 扩展器（Enhancer） | | 常见用途 | 把非 JS 资源转成 JS 模块 | 优化、注入、压缩、环境变量等 | | 调用方式 | `module.rules` 中配置 `use` | `plugins` 数组中配置 | | 工作机制 | 线性执行（从右到左） | 基于 Tapable 的事件钩子机制 | | 示例 | `babel-loader`, `css-loader`, `url-loader` | `HtmlWebpackPlugin`, `DefinePlugin`, `MiniCssExtractPlugin` |",
      "Loader 执行机制",
      "串行执行（从右到左）； 每个 loader 接收上一个 loader 的结果； 只能处理文件内容字符串； 是一个纯函数（无副作用）。",
      "Plugin 执行机制",
      "通过 Webpack 的 Tapable 钩子系统； 插入到 Webpack 的编译生命周期中； 可以访问 compiler、compilation 对象； 可读可写资源、依赖、输出、日志等。"
    ],
    "reference": "/myKMS/knowledge/framework/vite#_2-webpack-中的-loaders-和-plugins-有什么区别",
    "source": "/myKMS/knowledge/framework/vite"
  },
  {
    "id": 152,
    "question": "Tree Shaking",
    "answer": [
      "Tree Shaking = 静态分析 + dead code elimination",
      "去除未使用代码的技术, ESM 的 import/export 是静态分析的. 本质目标：减少打包体积，把代码中 未引用的函数、变量、类 剔除掉。 支持条件: 必须使用 ES Module; 导出必须是静态; 副作用(如果模块执行会有副作用（如修改全局变量），Tree Shaking 默认不会移除整个模块). 动态 import 可以按需加载，但静态分析更高效; 类库打包方式影响 Tree Shaking(lodash/es → 支持 Tree Shaking,lodash → CommonJS，不支持)",
      "1. 静态分析：树摇依赖于ES2015模块语法（即 import 和 export ），因为这些语法声明是静态的，使得构建工具在编译时就能确定哪些代码是没有被使用的。",
      "2. 标记未使用的导出：构建工具会遍历所有的导出项，标记那些在工程中未被其他模块引用的导出。",
      "3. 移除未引用代码：在最终的打包文件中移除那些未被引用的代码，这样做不仅减少了文件大小，还能提高应用的加载速度和性能。"
    ],
    "reference": "/myKMS/knowledge/framework/vite#_3-tree-shaking",
    "source": "/myKMS/knowledge/framework/vite"
  },
  {
    "id": 153,
    "question": "Tree Shaking 对 css 有效吗",
    "answer": [
      "纯 CSS 文件 Tree Shaking 无法分析哪些 CSS 类使用或未使用 所以 未使用的 CSS 默认不会被移除 CSS-in-JS / CSS Module CSS-in-JS（如 styled-components, emotion）生成的 JS 代码 对未使用的 styled 组件，Webpack/Rollup 的 Tree Shaking 可以删除对应 JS，从而间接删除样式 但这需要 样式写在 JS 里，纯 CSS 文件不适用",
      "tailwind / PostCSS / PurgeCSS 对于类名型 CSS（如 Tailwind、Bootstrap） 可以使用工具 扫描项目源码，删除未使用类 原理类似 Tree Shaking，但实际上是 静态 CSS 去重，不依赖 JS Tree Shaking"
    ],
    "reference": "/myKMS/knowledge/framework/vite#_4-tree-shaking-对-css-有效吗",
    "source": "/myKMS/knowledge/framework/vite"
  },
  {
    "id": 154,
    "question": "webpack runtime 是啥",
    "answer": [
      "**webpack runtime = 浏览器端的模块管理器 + 动态加载器 + 缓存器**",
      "webpack 为了在浏览器执行模块打包后的代码而生成的一套加载、执行、管理模块的核心逻辑。",
      "负责:",
      "加载模块 (**webpack_require**) 核心加载器，用来执行模块函数并返回 exports 每个模块在打包后都变成一个函数 `(module, exports, **webpack_require**) => { … }` 缓存模块 webpack 会把每个模块的执行结果缓存，避免重复执行： 支持动态 import / chunk 加载 JSONP 或 Module Federation 加载 chunk 加载状态表 处理热更新（HMR） 监听更新的 chunk； 动态替换模块内容，不刷新页面"
    ],
    "reference": "/myKMS/knowledge/framework/vite#_5-webpack-runtime-是啥",
    "source": "/myKMS/knowledge/framework/vite"
  },
  {
    "id": 155,
    "question": "webpack  有哪些优化项目的手段？",
    "answer": [
      "围绕 webpack 做性能优化，分为两个方面： 构建时间优化 、 构建体积优化",
      "构建时间优化 缩小范围 文件后缀 别名 缓存 并行构建(多核心) 定向查找第三方模块",
      "构建结果优化 压缩 js 压缩 css 压缩 html 压缩图片 按需加载 prload、prefetch 代码分割 tree shaking gzip 作用域提升"
    ],
    "reference": "/myKMS/knowledge/framework/vite#_6-webpack-有哪些优化项目的手段",
    "source": "/myKMS/knowledge/framework/vite"
  },
  {
    "id": 156,
    "question": "简述Vite的依赖预加载机制",
    "answer": [
      "**Vite 的依赖预构建机制通过在开发模式下提前处理常用依赖（如 Vue、React 等），将这些依赖转换为浏览器可以直接执行的格式。这避免了每次启动时重新编译这些依赖，显著提升了启动速度。** 预构建的依赖被缓存，并在后续启动时复用缓存，进一步加速了开发过程中的构建和启动时间。",
      "具体来说，它的工作原理如下：",
      "1. 依赖识别和路径补全： Vite 会首先识别项目中需要的依赖，并对非绝对路径或相对路径的引用进行路径补全。比如，Vue 的加载路径会变为 node_modules/.vite/deps/Vue.js?v=1484ebe8，这一路径显示了 Vite 在 node_modules/.vite/deps 文件夹下存放了经过预处理的依赖文件。 2. 转换成 ES 模块： 一些第三方包（特别是遵循 CommonJS 规范的包）在浏览器中无法直接使用。为了应对这种情况，Vite 会使用 esbuild 工具将这些依赖转换为符合 ES 模块规范的代码。转换后的代码会被存放在 node_modules/.vite/deps 文件夹下，这样浏览器就能直接识别并加载这些依赖。 3. 统一集成 ES 模块： Vite 会对每个包的不同模块进行统一集成，将各个分散的模块（如不同的 ES 函数或组件）合并成一个或几个文件。这不仅减少了浏览器发起多个请求的次数，还能够加快页面加载速度"
    ],
    "reference": "/myKMS/knowledge/framework/vite#_1-简述vite的依赖预加载机制",
    "source": "/myKMS/knowledge/framework/vite"
  },
  {
    "id": 157,
    "question": "vite HMR 模块热更新 (与webpack对比)",
    "answer": [
      "修改代码 → 浏览器自动更新 → 状态不丢失",
      "基本工作原理",
      "1. 开发服务器启动时：Vite 会用 ES Module 的方式向浏览器提供源码。 2. 文件变动：Vite 通过 chokidar 监听文件改动。 3. HMR 通知：Vite Dev Server 用 WebSocket 通知浏览器“某个模块变了”。type:'update', updates 更新的文件内容 4. 模块替换：浏览器端的 Vite HMR 客户端会：尝试只替换改动的模块（比如 .vue 组件、.css 文件）。如i18n.json 文件修改, 会刷新页面 5. import.meta.hot 可以手动控制 HMR 行为 6. Vite 内部维护一份 模块依赖图,向上传播，找接受更新的模块, 如果无法安全替换（比如入口文件改了），就会触发 整页刷新。",
      "Webpack HMR:基本原理一致, 开发时需要 打包，生成 bundle.js, 因为有打包过程，HMR 会比 Vite 慢",
      "为什么 Vite 的 HMR 比 Webpack 快？",
      "1. **Vite 基于 原生 ESM，不用重新打整个 bundle。** 2. **改动时只编译改动文件（按需编译）。** 3. **Webpack 需要走完整的打包流程，依赖图越大更新越慢。** 4. 所以在大项目里，Webpack 热更新可能要几秒，而 Vite 通常 <100ms。",
      "Vite 如何实现 React/Vue 的状态保留热更新？",
      "1. React：通过 @vitejs/plugin-react 集成 react-refresh，在替换组件时保留 Hook 状态。 2. Vue：通过 @vitejs/plugin-vue，在替换 .vue 组件时保留组件实例的响应式状态。 3. 本质：框架层插件拦截 HMR 更新过程，执行“局部替换 + 状态迁移”。",
      "Vite HMR 可能带来的问题？",
      "1. 内存泄漏：模块替换时没清理事件监听 / 定时器。 2. 调试复杂度：和实际生产行为不一致（生产中没有 HMR）。 3. 兼容性问题：某些第三方库没有 HMR 支持，只能整页刷新"
    ],
    "reference": "/myKMS/knowledge/framework/vite#_2-vite-hmr-模块热更新-与webpack对比",
    "source": "/myKMS/knowledge/framework/vite"
  },
  {
    "id": 158,
    "question": "Webpack 与 Vite",
    "answer": [
      "| 对比项 | **Webpack** | **Vite** | | :--------------- | :---------------------------------------------- | :-------------------------------------------- | | **核心思想** | 一次性**打包所有文件**再启动开发服务器 | **按需编译（ESM 原生支持）**，依赖与源码分离处理 | | **启动阶段** | 需先打包整个项目（构建依赖图 → 打包输出） | 启动极快，仅分析依赖，不预打包源码 | | **开发模式 (dev)** | 使用 webpack-dev-server：<br>所有模块打包成 bundle 后再提供服务 | 使用原生 ESM：<br>直接通过浏览器请求模块，Vite 拦截并按需编译返回 | | **热更新 (HMR)** | 修改文件后需重新打包相关 chunk，代价较高 | 仅重新编译变动的模块源码（原生 ESM 热替换），非常快 | | **构建阶段 (build)** | 打包时用 loader + plugin 处理所有文件，输出 bundle | 构建阶段由 **Rollup** 完成打包（利用 ESM 静态分析） | | **打包粒度** | 依赖与源码一起打包成 bundle | 依赖单独预构建（esbuild），源码按需处理 | | **依赖处理** | JS、CSS、图片等都需 loader 解析 | 依赖模块（node_modules）由 **esbuild** 预构建，源码按请求动态编译 | | **性能瓶颈** | 打包体积大、编译速度慢（依赖 AST 分析） | 使用 **esbuild（Go 编写）**，依赖构建快 10-100 倍 | | **构建结果** | 输出多个 bundle 文件 | 输出原生 ESM 模块（经 Rollup 优化） | | **适用场景** | 大型复杂项目，生态成熟（如 React + Webpack5） | 快速开发、现代浏览器环境（Vue3、React18） | | **插件机制** | Tapable 构建的复杂插件系统 | Rollup + Vite Hook，轻量、直观 | | **配置复杂度** | 配置项繁多（entry、loader、plugin 等） | 默认开箱即用，配置极简（vite.config.js） | | **首次启动速度** | 慢：需先打完整包 | 快：直接启动服务器即可运行 | | **生产打包速度** | 中等（依赖 JS 解析打包） | 快：esbuild + Rollup 组合优化 | | **调试体验** | 源码被打包，调试路径复杂 | 源码即模块，调试路径清晰 | | **静态资源处理** | 需配置 loader（file-loader/url-loader） | 内置资源处理机制，直接 import 即可 | | **依赖缓存** | 可配置 cache-loader | 自动缓存依赖（esbuild 缓存 + HTTP 缓存） |",
      "webpack 的打包流程: 读取配置 → 创建 Compiler → 从入口构建依赖图 → Loader 转换模块 → Plugin 优化 → 生成 Chunk → 输出文件。",
      "vite 开发时走原生 ESM + 按需编译，而生产环境走 Rollup 打包。vite 打包流程: 配置解析 -> 调用 Rollup 构建 -> 优化处理 -> 产物生成"
    ],
    "reference": "/myKMS/knowledge/framework/vite#_3-webpack-与-vite",
    "source": "/myKMS/knowledge/framework/vite"
  },
  {
    "id": 159,
    "question": "ssr 是啥, 对比csr的优势和适用场景",
    "answer": [
      "SSR（Server-Side Rendering） 是指在服务器端生成 HTML 内容，再发送到浏览器渲染，而不是浏览器端通过 JS 生成 DOM。",
      "SSR 的核心实现原理: SSR 的核心在于“同构（Isomorphic）”或“通用（Universal）”应用——即一套代码（通常是 React, Vue, Svelte 等）既能在服务器上运行，也能在客户端上运行。",
      "核心实现流程如下：",
      "1. 请求到达服务器",
      "2. 服务器端路由与数据获取",
      "路由匹配: 服务器根据请求的 URL 匹配到对应的页面组件 数据预取: 服务器在渲染组件之前，会执行该页面组件定义的“服务器端数据获取函数”（例如 Next.js 中的 getServerSideProps）。它会去调用数据库或 API，获取 ID 为 123 的产品数据。",
      "3. 服务器端渲染（Render to String）",
      "服务器使用框架提供的服务器端渲染 API（例如 React 的 ReactDOMServer.renderToString()）来“执行”组件。 由于在第 2 步已经获取了数据，组件会被填充完整的数据（产品名称、价格、描述等）。 这个执行过程的产物不是一个虚拟 DOM，而是一个完整的 HTML 字符串。",
      "4. 响应与首次渲染",
      "服务器将这个完整的 HTML 字符串打包成一个 HTTP 响应，发送给浏览器。 浏览器接收到 HTML 后，立即解析并渲染。用户此时立刻就能看到页面的完整内容（这就是首屏加载极快的原因）。 注意：此时的页面只是“静态的”，没有任何交互（点击按钮没反应），因为它对应的 JavaScript 还没执行。",
      "5. Hydration（注水/激活） 在浏览器渲染 HTML 的同时，它会开始下载 CSR 模式下也需要的 JavaScript 包（例如 app.js）。 JS 下载并执行后，框架（如 React/Vue）会在客户端再次运行。 但它不会粗暴地重新渲染并替换所有 DOM，而是执行一个称为 **\"Hydration\"（注水）**的过程。 Hydration 会**“接管”**服务器渲染的静态 DOM，遍历虚拟 DOM 和真实 DOM，将事件监听器（如 onClick）附加到现有的 HTML 元素上。 这个过程完成后，页面就从“静态 HTML”变成了“可交互的单页应用（SPA）”。",
      "核心流程图： **用户请求 → 服务器路由 → 服务器获取数据 → 服务器渲染 (生成HTML字符串) → 浏览器接收HTML并立即显示 → (并行)浏览器下载JS → JS执行 (Hydration) → 页面完全可交互**",
      "SSR 相比 CSR 的不可替代优势:",
      "CSR 最大的问题是“白屏时间长”和“SEO 灾难”。SSR 正是为解决这两个核心痛点而生，在以下场景具有不可替代的优势：",
      "搜索引擎优化 (SEO) 极致的“首屏加载速度”（FCP）"
    ],
    "reference": "/myKMS/knowledge/framework/vite#_4-ssr-是啥-对比csr的优势和适用场景",
    "source": "/myKMS/knowledge/framework/vite"
  },
  {
    "id": 160,
    "question": "微前端 / import-html-entry 场景下，子应用中存在路由懒加载（dynamic import）的情况，import-html-entry 会如何处理或者需要注意什么",
    "answer": [
      "import-html-entry 默认只处理 index.html 中的静态 script 和 link，所以懒加载模块不会被提前 fetch 或 exec。懒加载模块会在子应用自己的 webpack runtime 中正常 fetch（通过 publicPath 拼接 URL），然后动态加载。",
      "懒加载的模块执行时会使用子应用的 runtime（webpackJsonp / webpackChunk），所以如果你在 import-html-entry 里用 sandbox proxy window，需要把 webpackJsonp / webpack_require 等 runtime 挂到 proxy 上，确保 chunk 加载执行正常。",
      "qiankun 会在 execScripts 中注入 sandbox proxy，保证动态 import 能访问 webpack runtime。"
    ],
    "reference": "/myKMS/knowledge/framework/vite#_5-微前端-import-html-entry-场景下-子应用中存在路由懒加载-dynamic-import-的情况-import-html-entry-会如何处理或者需要注意什么",
    "source": "/myKMS/knowledge/framework/vite"
  },
  {
    "id": 161,
    "question": "CSS-in-JS  的优缺点",
    "answer": [
      "| 优点 | 说明 | 实际收益 | | -------------------------------- | -------------------------------------- | --------------------------- | | **1️⃣ 样式作用域自动隔离** | 每个组件的样式自动作用于自身，不会影响全局或其他组件 | 避免 CSS 命名冲突、全局污染 | | **2️⃣ 动态样式支持（基于状态）** | 可以直接使用 JS 变量、props、state 动态控制样式 | 让样式与逻辑无缝联动（例如根据主题、交互状态变化） | | **3️⃣ 真正的组件化开发体验** | 样式与组件逻辑紧密绑定在一起（co-located） | 提高可维护性与可读性，代码结构更清晰 | | **4️⃣ 消除了全局命名问题** | 自动生成唯一 className（hash） | 无需再手动设计命名规范（如 BEM / SMACSS） | | **5️⃣ 支持服务端渲染（SSR）与关键路径 CSS 提取** | 框架（如 styled-components）可在 SSR 阶段注入 CSS | 提高首屏性能、避免闪烁（FOUC） | | **6️⃣ 更好的主题系统支持** | 内置 ThemeProvider 概念，可动态切换主题 | 适合暗黑模式、品牌主题等需求 | | **7️⃣ 死代码消除（Tree Shaking 友好）** | 未使用组件的样式不会被打包 | 打包体积更小、更干净 | | **8️⃣ 类型安全（TypeScript 集成）** | 样式属性有类型提示与检查 | 减少拼写错误与无效样式 | | **9️⃣ 样式动态计算能力** | 可以编写逻辑，如条件判断、循环、计算值 | 复杂 UI 响应更灵活（如动态 grid、尺寸） | | **🔟 无需独立 CSS 构建管线** | 不依赖 CSS Loader / PostCSS | 前端构建配置更轻量（尤其在 Vite 等环境） |",
      "| 缺点 | 说明 | | ---------- | ------------------------------------------- | | **运行时开销** | 一些库（如 styled-components）会在运行时动态生成样式，性能略低 | | **构建体积稍大** | 比纯 CSS 稍重，需要额外 runtime | | **调试难度** | 虽然 devtools 支持不错，但不如传统 CSS 文件直观 | | **学习成本** | 对初学者来说，需要理解 styled-components 或 Emotion API |",
      "| 场景 | 是否推荐使用 CSS-in-JS | | ------------------- | ---------------- | | 设计系统 / UI 库（需要主题支持） | ✅ 强烈推荐 | | React / Vue 组件化项目 | ✅ 推荐 | | 静态网站（CSS 变化少） | ⚙️ 可选 | | 大型老项目（已用 SASS/BEM） | ⚠️ 慎重迁移，成本较高 |"
    ],
    "reference": "/myKMS/knowledge/framework/vite#_6-css-in-js-的优缺点",
    "source": "/myKMS/knowledge/framework/vite"
  },
  {
    "id": 162,
    "question": "vue 动态渲染组件的原理是什么",
    "answer": [
      "**本质是根据虚拟 DOM（VNode）的 type 动态切换组件** 动态组件就是根据 VNode 的 type 动态 patch，不同类型就卸载旧组件、挂载新组件。",
      "-`Vue 模板编译 <component :is=\"currentComponent\"> → createVNode(currentComponent)`",
      "当 currentComponent 变化： 生成新的 VNode 调用 patch(oldVNode, newVNode) 对比 VNode 类型： 类型相同 → 复用组件实例 类型不同 → 卸载旧组件，挂载新组件",
      "如果是字符串 → 查找全局组件注册表 如果是组件对象 → 返回组件本身",
      "**Vue 动态组件就是 根据 reactive/ref 的值动态生成 VNode type，然后通过 patch 更新组件实例，keep-alive 则通过缓存实例优化挂载卸载。**"
    ],
    "reference": "/myKMS/knowledge/framework/vue#_1-vue-动态渲染组件的原理是什么",
    "source": "/myKMS/knowledge/framework/vue"
  },
  {
    "id": 163,
    "question": "Vue 项目可做哪些性能优化",
    "answer": [
      "减少不必要的响应式追踪 用 markRaw() 包装不需要响应的对象 使用 shallowReactive / shallowRef 避免深层递归依赖 使用 key 保证组件复用正确 合理的使用指令 合理的使用 v-if 和 v-show 指令，避免不必要的渲染。 使用 v-for 时，尽量提供唯一的 key ，避免重复渲染。 使用 v-once 指令，只渲染一次，避免不必要的计算。 使用 v-memo 指令，对使用v-for生成的列表进行渲染优化 组件优化 合理使用 keep-alive 组件，缓存组件实例，避免重复渲染。 合理划分组件，提升复用性和渲染性能。 响应式优化 watch的优化: 避免滥用深度监听，降低性能开销。对于频繁触发的响应式数据变化，可以通过防抖和节流优化监听逻辑。 异步组件懒加载 合理使用 Teleport 与 Suspense 减少模板内复杂计算 代码分割 & 按需加载 Tree Shaking + 移除无用依赖 懒加载 渲染加 key 虚拟滚动 ..."
    ],
    "reference": "/myKMS/knowledge/framework/vue#_2-vue-项目可做哪些性能优化",
    "source": "/myKMS/knowledge/framework/vue"
  },
  {
    "id": 164,
    "question": "nextTick 原理是什么",
    "answer": [
      "**nextTick在下次 DOM 更新循环结束后执行回调，确保我们能操作到最新的 DOM 状态。**",
      "Vue 采用 异步批量更新策略：",
      "收集本轮所有的更新任务； 等当前“事件循环”结束后，一次性刷新 DOM； 保证更新最少、性能最好。",
      "Vue 3 的 nextTick 实际上是封装了一个**微任务调度器（microtask scheduler）**。",
      "```\n// Vue3 内部核心实现伪代码\nlet pending = false\nconst queue = []\n\nfunction queueFlush() {\n  if (!pending) {\n    pending = true\n    Promise.resolve().then(flushJobs) // 微任务\n  }\n}\n\nfunction flushJobs() {\n  pending = false\n  // 执行 watcher、渲染任务\n  ...\n  // 执行 nextTick 回调\n  flushPostFlushCbs()\n}\n\nexport function nextTick(cb) {\n  return cb ? Promise.resolve().then(cb) : Promise.resolve()\n}\n```",
      "Vue 内部维护了多个“任务队列”，它们依次执行：",
      "| 队列名 | 作用 | 举例 | | ------------------- | ------------------------------ | --------------------------- | | **job queue** | 收集响应式副作用更新（组件 render、watch 回调） | 数据变化后重新渲染组件 | | **postFlushCbs** | DOM 更新后执行 | nextTick 回调、watch post 回调 | | **microtask queue** | 最底层调度机制 | Promise.resolve().then(...) |",
      "所以 nextTick() 实际是在 DOM 更新完（flushJobs 执行后）被触发的。",
      "因此 nextTick() 实际上是一个微任务级别的等待；所以它总是保证在本轮 DOM 更新完成后执行。",
      "**nextTick 一定比 setTimeout 先执行。** 因为：",
      "nextTick 底层用的是 微任务（microtask）； setTimeout 属于 宏任务（macrotask）； 在一次事件循环中，微任务总是早于宏任务执行。",
      "nextTick 回调 再dom 渲染之后, 宏任务执行之前."
    ],
    "reference": "/myKMS/knowledge/framework/vue#_3-nexttick-原理是什么",
    "source": "/myKMS/knowledge/framework/vue"
  },
  {
    "id": 165,
    "question": "如何统一监听 Vue 组件报错",
    "answer": [
      "在 Vue 3 中，可以通过 全局错误处理器 （errorHandler） 和 生命周期钩子（例如 onErrorCaptured ）来统一监听和处理组件中的错误.",
      "通过全局错误处理器 app.config.errorHandler 局部错误捕获（onErrorCaptured） Vue 只能捕获「Vue 运行时错误」，但是有些错误是全局 JavaScript 运行时错误（例如异步请求、脚本加载失败）。需要配合浏览器原生错误监听"
    ],
    "reference": "/myKMS/knowledge/framework/vue#_4-如何统一监听-vue-组件报错",
    "source": "/myKMS/knowledge/framework/vue"
  },
  {
    "id": 166,
    "question": "什么是 MVVM",
    "answer": [
      "MVVM（Model-View-ViewModel） 是一种用于构建用户界面的架构模式，用于现代的前端开发框架（Vue、Angular）。它通过 数据绑定 和 视图模型 提供了高效的 UI 更新和数据同步机制。",
      "MVVM 模式主要由 Model （模型）、 View （视图）、 ViewModel （视图模型）三个部分组成。",
      "Model表示程序的核心数据和业务逻辑，它不关心用户界面，只负责数据的获取、存储和处理，并提供与外界交互的接口。 View负责展示数据和用户交互，简单来说他就是我们看到的UI 组件或 HTML 页面。 ViewModel是连接 View 和 Model 的桥梁，它不直接操作视图或模型，而是通过数据绑定将两者连接起来。",
      "**MVVM：让数据和视图自动同步（双向绑定）**",
      "React 是一种 UI 声明式渲染的 View 层库，核心是 函数式 + 单向数据流。 Vue 是 MVVM 模型",
      "| 对比项 | Vue (MVVM) | React (View + State) | | ---- | -------------- | -------------------------- | | 数据流 | 双向绑定 | 单向数据流 | | 绑定方式 | `v-model` 自动同步 | 手动 `onChange` + `setState` | | 响应系统 | Proxy 响应式追踪 | 调用 `setState` 触发重新渲染 | | 哲学思想 | 声明式 + 响应式 | 函数式 + 纯 UI 渲染 | | 框架定位 | 完整 MVVM 框架 | UI 库（View 层） |"
    ],
    "reference": "/myKMS/knowledge/framework/vue#_5-什么是-mvvm",
    "source": "/myKMS/knowledge/framework/vue"
  },
  {
    "id": 167,
    "question": "Vue 组件初始化的各个阶段都做了什么？",
    "answer": [
      "从组件的创建到挂载到页面，再到组件的更新和销毁，每个阶段都有特定的任务和职责。",
      "🎯 组件实例创建：当我们第一次访问页面时，Vue创建组件实例，解析props、data、methods等属性方法，在组合式API中，执行 setup()。",
      "🎯 响应式系统建立：基于 Proxy 实现 reactive、ref，建立依赖收集和触发更新机制，props 传递时自动响应式处理。",
      "🎯 模板编译与渲染：将 template 编译为渲染函数，Vue 3 通过 静态提升等方式优化性能，Vite 预编译 SFC（单文件组件）。",
      "🎯 DOM 挂载：执行渲染函数生成 VNode，通过 Patch 算法 转换为真实 DOM 并插入页面，同时初始化子组件。mounted（Options API）或 onMounted（Composition API）触发，可进行 DOM 操作。",
      "🎯 响应式更新：状态变更触发 Diff 算法 计算最小 DOM 更新，beforeUpdate、updated（Options API）或 onBeforeUpdate、onUpdated（Composition API）执行相应逻辑。",
      "🎯 组件销毁：移除 DOM，清理副作用（解绑事件、销毁 watcher、清理 effect），递归卸载子组件，触发 beforeUnmount、unmounted（Options API）或 onBeforeUnmount、onUnmounted（Composition API）。"
    ],
    "reference": "/myKMS/knowledge/framework/vue#_6-vue-组件初始化的各个阶段都做了什么",
    "source": "/myKMS/knowledge/framework/vue"
  },
  {
    "id": 168,
    "question": "Vue3 如何实现双向数据绑定",
    "answer": [
      "**Vue 实现双向数据绑定的核心是通过响应式系统的 数据劫持和 观察者模式来实现的。**",
      "Vue3 实现双向绑定的本质是这三层： 数据层（Model） ←→ 响应式系统（Reactivity） ←→ 视图层（View）",
      "它主要依赖三个核心模块：",
      "Proxy + Reflect —— 数据劫持（响应式追踪） 依赖收集与触发更新（effect + scheduler） 模板编译生成 getter/setter 更新逻辑",
      "数据劫持：reactive() / ref() Proxy/Reflect get 时依赖收集, set 时触发更新",
      "track()：记录当前副作用（watchEffect、render 等）依赖了哪个数据； trigger()：数据变更时，重新运行依赖的副作用函数（更新视图）。",
      "Vue3 的双向绑定本质是：",
      "通过 Proxy 劫持数据 实现响应式追踪； 通过 effect 依赖收集与触发机制 实现自动更新； 通过 v-model 语法糖 + 事件机制 实现视图 ↔ 数据同步。",
      "Proxy 的缺点: 对数组的一些边界问题 数组索引越界修改无效 部分原生方法不触发更新 性能问题 嵌套非常深的对象,依赖收集和触发依然有开销 Proxy 不支持原始类型 ref 是封装value的对象"
    ],
    "reference": "/myKMS/knowledge/framework/vue#_7-vue3-如何实现双向数据绑定",
    "source": "/myKMS/knowledge/framework/vue"
  },
  {
    "id": 169,
    "question": "Vue 模板编译的过程",
    "answer": [
      "**模板解析、AST优化 和 代码生成**",
      "```\n模板字符串 (template)\n       ↓\n[1] 解析（Parse） → 生成 AST\n       ↓\n[2] 转换（Transform） → 优化、静态标记、指令处理\n       ↓\n[3] 生成（Generate） → 输出可执行的 render 函数\n\n```",
      "1. 模板解析: Vue 使用其解析器将 HTML 模板转换为 抽象语法树（AST）。在这个阶段，Vue 会分析模板中的标签、属性和指令，生成一颗树形结构。每个节点表示模板中的一个元素或属性。 2. AST优化: Vue 在生成渲染函数前，会对 AST 进行优化。优化的核心目标是标记 静态节点，在渲染时，Vue 可以跳过这些静态节点，提升性能。 还有动态标记. 3. 代码生成: 生成渲染函数是编译的最终阶段，这个阶段会将优化后的 AST 转换成 JavaScript 渲染函数。"
    ],
    "reference": "/myKMS/knowledge/framework/vue#_8-vue-模板编译的过程",
    "source": "/myKMS/knowledge/framework/vue"
  },
  {
    "id": 170,
    "question": "vue 异步更新",
    "answer": [
      "Vue 会延迟更新 DOM，等同一轮事件循环中所有状态改动都完成后，再统一执行更新。",
      "目的： ✅ 避免频繁的 DOM 重绘（性能优化） ✅ 保证多次修改只渲染一次（批量更新） ✅ 数据一致性：确保在同一事件循环中的所有数据变更后，视图一次性更新到最终状态。",
      "```\n数据变化（Proxy.set）\n       ↓\n触发依赖（trigger）\n       ↓\n派发更新任务（scheduler → queueJob）\n       ↓\n进入异步任务队列（微任务）\n       ↓\n批量执行更新（flushJobs）\n       ↓\n重新渲染组件（patch → diff → DOM 更新）\n```",
      "**响应式数据变化 → 触发依赖 effect → 将更新任务加入微任务队列 → 批量刷新渲染。**"
    ],
    "reference": "/myKMS/knowledge/framework/vue#_9-vue-异步更新",
    "source": "/myKMS/knowledge/framework/vue"
  },
  {
    "id": 171,
    "question": "vue watch computed 的区别",
    "answer": [
      "| 特性 | `computed` | `watch` | | ------------- | --------------------------------------------------------- | --------------------------------------- | | 目的 / 语义 | 用于声明式地 “从状态推导 / 派生” 一个响应式的新值 | 用于监听状态变化，执行副作用逻辑（如 API 请求、日志、手动修改等） | | 缓存 / 重算 | 有缓存机制，只有依赖变化时才重新计算 | 每次被监听的源变化时，回调都会执行（无缓存） | | 延迟 / 惰性 | 惰性求值 —— 只有在被访问时才计算 | 立即触发（可配置 `immediate: true`） | | 副作用能力 | 不推荐在 computed 中写副作用（应保持纯函数） | 正是用来执行副作用的场景，如异步操作、状态同步、DOM 操作等 | | 输入 / 输出 | 通常是同步逻辑，返回值给模板或其他计算使用 | 回调可接收新值和旧值，执行任意复杂逻辑 | | 依赖跟踪 | 自动追踪内部访问的响应式变量作为依赖 | 明确指定被监听的响应式源（ref / reactive / getter 等） | | 是否能监听深层对象 /数组 | 默认浅依赖；对于深层嵌套需要用 `computed(() => JSON.stringify(...))` 等技巧 | 可设置 `deep: true` 监听嵌套属性变化 | | 适合场景 | 计算属性、派生状态、模板绑定等 | 异步逻辑、数据拉取、条件触发、清理副作用、观察状态变化等 |",
      "原理: computed 底层是用 Vue 的响应式系统（effect + 依赖收集）包装的“缓存 getter”机制。只有其内部依赖发生变化时，才重新执行计算。",
      "watch 则是一个高阶封装，让你监听某个响应式源的变化，并在变化时执行回调。它不会缓存回调的结果，也不会阻止重复调用。"
    ],
    "reference": "/myKMS/knowledge/framework/vue#_10-vue-watch-computed-的区别",
    "source": "/myKMS/knowledge/framework/vue"
  },
  {
    "id": 172,
    "question": "vue3 lis",
    "answer": [
      "LIS 在 Diff 中的作用：找出不需要移动的节点，最小化 DOM 操作 1. 将新节点映射到旧节点索引序列 2. 求最长递增子序列（LIS） 3. 非 LIS 节点移动或创建",
      "能够降低时间复杂度;大型表格、树结构、虚拟列表和移动频繁但大部分节点不变的场景, 效果好."
    ],
    "reference": "/myKMS/knowledge/framework/vue#_11-vue3-lis",
    "source": "/myKMS/knowledge/framework/vue"
  },
  {
    "id": 173,
    "question": "vue3 类似react hooks的原理是什么?",
    "answer": [
      "Composition API（组合式 API）。 虽然它们在目的（解决状态逻辑复用、组织代码）上非常相似，但它们的核心实现原理完全不同。",
      "React Hooks 的原理：基于“调用顺序”和“链表” Vue Composition API 的原理：基于“响应式系统”和“依赖追踪”",
      "React Hooks 的核心原理: 核心机制：基于“调用顺序” 运行方式： React 组件的函数体在每次渲染时都会重新执行。",
      "React 在内部为每个组件实例维护了一个**特殊数据结构（可以想象成一个数组或链表）**来存储 Hooks 的状态。 这就是为什么 React Hooks 有严格的“规则”： 不能在条件（if）或循环（for）中调用 Hooks。 必须在函数顶层调用",
      "Vue Composition API 的核心原理: Vue 的原理则完全不同，它不依赖于“调用顺序”，因此没有 React Hooks 的那些限制。 核心机制：基于“响应式系统”（Reactivity System） 运行方式： setup() 函数在组件实例创建时只执行一次。",
      "Vue 3 的响应式系统是独立于组件的。当你调用 ref 或 reactive 时，你创建的是一个独立的、可被追踪的响应式对象。",
      "setup() 只执行一次 这是与 React 的最大区别。 React 的函数组件每次渲染都会重新执行，所以它需要“调用顺序”来找回状态。 Vue 的 setup() 只在组件初始化时执行一次。",
      "**ref 和 reactive 创建的状态只被创建一次，然后被闭包引用，它们在组件的整个生命周期中都是持久的。**",
      "| 特性 | React Hooks | Vue Composition API | | ---------- | ------------------------------------------- | --------------------------------------------------- | | 核心原理 | 调用顺序 (Call Order) | 依赖追踪 (Dependency Tracking) | | 状态机制 | React 内部的链表/数组 | 独立的响应式对象 (Proxy / Ref) | | 函数执行 | 组件函数每次渲染都执行 | setup() 只执行一次 | | 使用限制 | 有（Rules of Hooks，不能在 if/for 中） | 无（可以在 if/for 中，因为状态是独立的） | | 心智模型 | “每次渲染都是全新的” | “状态是持久的，当它变化时自动触发更新” |"
    ],
    "reference": "/myKMS/knowledge/framework/vue#_12-vue3-类似react-hooks的原理是什么",
    "source": "/myKMS/knowledge/framework/vue"
  },
  {
    "id": 174,
    "question": "vue3 手写一个once修饰器",
    "answer": [
      "```\n\n<template>\n  <div>\n    <h2 v-once-directive>{{ message }}</h2>\n    <button @click=\"message = '更新后的消息'\">修改 message</button>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\n\nconst message = ref('初始内容')\n\n// 注册自定义 once 指令\nconst vOnceDirective = {\n  // 第一次挂载时（渲染一次）\n  mounted(el, binding) {\n    el._onceContent = el.innerHTML // 记录初次渲染内容\n  },\n  // 当数据变化时，会触发 updated 钩子\n  updated(el, binding) {\n    // 恢复初始内容，防止重新渲染\n    el.innerHTML = el._onceContent\n  }\n}\n</script>\n\n<script>\nexport default {\n  directives: {\n    onceDirective: vOnceDirective\n  }\n}\n</script>\n\n```",
      "事件",
      "```\n\n<template>\n  <button v-once-click=\"handleClick\">点击我一次</button>\n</template>\n\n<script setup>\nconst handleClick = () => {\n  alert('只执行一次')\n}\n\nconst vOnceClick = {\n  mounted(el, binding) {\n    const fn = (e) => {\n      binding.value(e)\n      el.removeEventListener('click', fn) // 移除监听\n    }\n    el.addEventListener('click', fn)\n  }\n}\n</script>\n\n\n```",
      "自定义指令有很多钩子可以选择",
      "```vue\nconst myDirective = {\n  // 在绑定元素的 attribute 前\n  // 或事件监听器应用前调用\n  created(el, binding, vnode) {\n    // 下面会介绍各个参数的细节\n  },\n  // 在元素被插入到 DOM 前调用\n  beforeMount(el, binding, vnode) {},\n  // 在绑定元素的父组件\n  // 及他自己的所有子节点都挂载完成后调用\n  mounted(el, binding, vnode) {},\n  // 绑定元素的父组件更新前调用\n  beforeUpdate(el, binding, vnode, prevVnode) {},\n  // 在绑定元素的父组件\n  // 及他自己的所有子节点都更新后调用\n  updated(el, binding, vnode, prevVnode) {},\n  // 绑定元素的父组件卸载前调用\n  beforeUnmount(el, binding, vnode) {},\n  // 绑定元素的父组件卸载后调用\n  unmounted(el, binding, vnode) {}\n}\n```"
    ],
    "reference": "/myKMS/knowledge/framework/vue#_13-vue3-手写一个once修饰器",
    "source": "/myKMS/knowledge/framework/vue"
  }
]
