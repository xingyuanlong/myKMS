
### 1. http2的首部压缩

<Collapse>

- 为什么要压缩首部？
  - HTTP/1.1 的每个请求都会携带大量重复的首部. 这些头部在同一个连接中 几乎每次都一样，比如 User-Agent、Cookie、Accept。HTTP/2 引入 首部压缩（Header Compression） 来减少这种重复，提高传输效率。

- HTTP/2 首部压缩机制：HPACK

| 机制                          | 说明                                                   |
| --------------------------- | ---------------------------------------------------- |
| **静态表（Static Table）**       | 内置常见头部字段，如 `:method`, `:path`, `:status` 等；用索引代替字符串。 |
| **动态表（Dynamic Table）**      | 在连接中缓存已发送的头部；后续请求只需引用索引。                             |
| **霍夫曼编码（Huffman Encoding）** | 对字符串部分再进行霍夫曼编码，进一步压缩体积。                              |

- HPACK 的压缩原理图

| 步骤 | 动作     | 效果                               |
| -- | ------ | -------------------------------- |
| 1  | 查静态表   | 常用字段直接用编号（如 `:method: GET` = #2） |
| 2  | 查动态表   | 最近请求过的头字段从表中引用                   |
| 3  | 发送差异数据 | 只发送新字段或变化部分                      |
| 4  | 霍夫曼编码  | 对字符串再压缩                          |
| ✅  | 结果     | 头部数据量可减少 60–90%                  |

**HTTP/2 的首部压缩机制（HPACK）通过静态表、动态表和霍夫曼编码三种方式，实现头部字段的高效压缩与重用，大幅减少网络传输开销。**

</Collapse>

### 2. tcp 断开4次挥手

<Collapse>

TCP 是全双工的. 全双工（Full-duplex）：

- 即双方可以同时发送和接收数据。
- 所以连接断开时，双方都要单独关闭各自的发送方向。

假设：客户端（主动关闭连接）服务器（被动关闭连接）

通信结束时，断开过程如下：

| 步骤 | 方向        | 报文标志位   | 说明                   |
| -- | --------- | ------- | -------------------- |
| ①  | 客户端 → 服务器 | `FIN=1` | 客户端请求关闭发送通道          |
| ②  | 服务器 → 客户端 | `ACK=1` | 服务器确认接收              |
| ③  | 服务器 → 客户端 | `FIN=1` | 服务器也关闭发送通道           |
| ④  | 客户端 → 服务器 | `ACK=1` | 客户端确认接收，进入 TIME_WAIT |

```
客户端 (Client)                             服务器 (Server)
------------------                          ------------------

   ESTABLISHED                                  ESTABLISHED
        |                                              |
        | ① FIN=1, seq=u                              |
        |--------------------------------------------->|
        |                                              |
        |                           收到 FIN, 发 ACK=1, ack=u+1
        | ②                                            |
        |<---------------------------------------------|
        |                                              |
        |                           服务器继续处理剩余数据
        |                                              |
        |                           ③ FIN=1, seq=v    |
        |<---------------------------------------------|
        | ④ ACK=1, ack=v+1                             |
        |--------------------------------------------->|
        |                                              |
   TIME_WAIT(等待2MSL)                          CLOSED
        |
   连接彻底关闭
```

客户端最后要 等待 2×MSL（Maximum Segment Lifetime） 时间，约几十秒。

作用：

- 确保服务器收到最终 ACK
  - 若 ACK 丢失，服务器会重发 FIN。
  - 客户端在 TIME_WAIT 状态还能重发 ACK。

- 防止旧连接残余报文影响新连接
  - 等待 MSL 确保网络中旧包都过期。

1. 为什么关闭要四次，而不是三次？
因为 TCP 是全双工：

- 一方关闭发送，不代表另一方也关闭；
- 必须双方都各自发送 FIN，确认关闭。

2. 为什么客户端要 TIME_WAIT？

防止最后的 ACK 丢失，确保连接彻底关闭。
另外，避免旧连接的数据干扰新连接。

3. 为什么是 “2MSL”？

因为：
一个 MSL 是一个报文在网络中能存活的最长时间；
等 2×MSL，确保往返的所有旧报文都消失。

4. 如果服务器先关闭会怎样？

流程相同，只是角色对调。
谁主动关闭，谁就经历 TIME_WAIT。

</Collapse>

### 3. 什么是队头阻塞

<Collapse>

队头阻塞就是“队列第一个请求卡住，后面全被拖延”。HTTP/3 通过 QUIC 彻底缓解了这个问题。

</Collapse>

### 4. http 2 多路复用

<Collapse>

HTTP/1.1 每个请求都必须建立在一个 TCP 连接上。虽然它支持“Keep-Alive”长连接，但仍然有两个性能瓶颈：

- 队头阻塞（Head-of-Line Blocking）: 一个连接中，请求是串行执行的。前一个响应没回来，后面的请求必须等。
- 多连接并发受限: 浏览器为同一域名通常只能同时开 6 个 TCP 连接，多了也被限制。
- 📦 头部重复传输: 每次请求都要携带大量相同的 Header（如 cookie、user-agent）。

在一个 TCP 连接上，同时并发多个 HTTP 请求与响应。

工作方式：

1. 所有请求和响应都被拆分成小块（frame）。
2. 每个请求分配一个唯一的 Stream ID。
3. 这些 frame 被交错（交织）发送，在同一个 TCP 连接中同时传输。
4. 接收端再根据 Stream ID 把它们拼回原样。

举个例子：
假设浏览器要加载三个资源：

```
index.html
style.css
main.js

```

HTTP/1.1：

- 3 个请求需要占用 3 个 TCP 连接；
- 或者 1 个连接按顺序：html → css → js；
- 前面的慢了，后面的全卡住（队头阻塞）。

HTTP/2：

- 所有请求共用 1 个 TCP 连接；
- 三个请求的 frame 被交错发送；
- 谁先返回数据就先解析，完全并行。

多路复用消除了 HTTP 层阻塞，但 TCP 层仍可能受丢包影响。

**HTTP/2 多路复用 = 一个连接里同时传多条请求流，互不阻塞，性能飞升。**

</Collapse>


### 5. DNS 协议

<Collapse>

DNS（Domain Name System） 是一个将 域名 ↔ IP 地址 相互映射的分布式系统。


因为：用户容易记住 www.example.com;计算机只能识别 93.184.216.34;DNS 让我们可以使用域名访问网站，系统自动帮你找到正确的 IP。

DNS 解析的完整流程:

- 浏览器缓存: 先查本地 DNS 缓存（比如上次访问过)
- 操作系统缓存: 如果浏览器里没有，就问操作系统的 DNS 缓存。
- hosts 文件: 操作系统先查 hosts 文件，看看是否有手动配置。
- 本地 DNS 服务器（递归解析器）: 一般由 ISP（网络运营商）提供，比如 8.8.8.8（Google）、114.114.114.114（中国电信）。
- 递归查询（DNS 服务器帮你查到底）

DNS 通常使用 UDP 53 端口（查询），TCP 用于传输大数据量（如区域传送）。

每条 DNS 记录都有一个 TTL（Time To Live） 值，比如 300 秒。


</Collapse>


### 6. html script defer 与async


<Collapse>


| 特性             | `<script async> `                                          | `<script defer>`                                                    |
| ---------------- | -------------------------------------------------------- | ------------------------------------------------------------------ |
| 加载时机 (Loading) | 立即加载（与 HTML 解析并行）                                | 立即加载（与 HTML 解析并行）                                         |
| 执行时机 (Execution) | 文件下载完成后立即执行                                      | 等待整个 HTML 文档解析完成后再执行                                    |
| 执行顺序          | 不保证顺序。哪个文件先下载完，哪个先执行。                     | 保证顺序。按在文档中出现的顺序依次执行。                               |
| 是否阻塞 HTML     | 会。文件执行时会暂停 HTML 解析。                              | 不会。保证在 HTML 解析完成后才执行。                                   |
| 适用场景          | 适用于独立脚本，不依赖 DOM，也不被其他脚本依赖（如统计脚本）。      | 适用于依赖 DOM 或被其他 defer 脚本依赖的脚本（如应用主逻辑脚本）。         |


</Collapse>





### 其他

- HTTP/1.1
  - 特点: 持久连接 (Keep-Alive);管道化 (Pipelining);多连接并发;头部冗余;
  - 问题: 队头阻塞、连接利用率低、头部冗余。
- HTTP2
  - 特点: 二进制分帧 (Binary Framing);多路复用 (Multiplexing);头部压缩 (HPACK);服务端推送 (Server Push);
  - 改进点：减少延迟、提升带宽利用率。
  - 问题: 因为仍然基于 TCP，丢包时所有流都要等，TCP 层仍然存在 队头阻塞
- HTTP/3
  - 特点: 基于 QUIC 协议（UDP 上实现）;内置 TLS 1.3 加密;更快的连接建立;多路复用天然支持;

- TLS/SSL: 加密（防止窃听）;身份认证（确认服务端身份）;完整性校验（防止篡改）

- HTTPS 是在 HTTP 与 TCP 之间加入了TLS/SSL层，保证了通信的安全性。它通过数字证书验证服务器身份，用非对称加密实现安全的密钥交换，然后使用对称加密进行高效的数据传输。TLS 1.3 相比 TLS 1.2，减少了握手延迟并提升了安全性。

- TLS 握手过程: ClientHello(浏览器发起握手，请求支持的加密算法、随机数), ServerHello(服务器选择加密算法，返回随机数和 数字证书（包含公钥）),验证证书(浏览器验证证书是否可信（CA 签发、域名匹配、未过期）), 密钥交换(浏览器用服务器公钥加密一个“对称会话密钥”，发给服务器。服务器用私钥解密，拿到对称密钥。), 建立安全通信(后续通信用对称加密（如 AES, ECC），保证性能)

- TCP 特点: 传输控制协议：面向连接的，可靠的，基于字节流的传输层通信协议.(基于连接的,字节流,流量缓冲,可靠的传输服务,拥塞控制)

- SYN: 握手, ACK 应答, FIN 断开
