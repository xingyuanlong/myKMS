<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS 知识 | 知识库</title>
    <meta name="description" content="知识库">
    <meta name="generator" content="VitePress v2.0.0-alpha.12">
    <link rel="preload stylesheet" href="/myKMS/assets/style.OwVREeIS.css" as="style">
    <link rel="preload stylesheet" href="/myKMS/vp-icons.css" as="style">
    
    <script type="module" src="/myKMS/assets/app.BNCbZhGe.js"></script>
    <link rel="preload" href="/myKMS/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/myKMS/assets/chunks/theme.BDiiRWX1.js">
    <link rel="modulepreload" href="/myKMS/assets/chunks/framework.Dp-6g2cw.js">
    <link rel="modulepreload" href="/myKMS/assets/knowledge_base_js.md.BbqvaTkS.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body><!--teleport start anchor--><!----><!--teleport anchor-->
    <div id="app"><div class="Layout" data-v-304c8b69><!--[--><!--]--><!--[--><span tabindex="-1" data-v-fcbfc0e0></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-fcbfc0e0>Skip to content</a><!--]--><!----><header class="VPNav" data-v-304c8b69 data-v-d5bf7c8e><div class="VPNavBar" data-v-d5bf7c8e data-v-8eab0e6d><div class="wrapper" data-v-8eab0e6d><div class="container" data-v-8eab0e6d><div class="title" data-v-8eab0e6d><div class="VPNavBarTitle has-sidebar" data-v-8eab0e6d data-v-d4488dd0><a class="title" href="/myKMS/" data-v-d4488dd0><!--[--><!--]--><!----><span data-v-d4488dd0>知识库</span><!--[--><!--]--></a></div></div><div class="content" data-v-8eab0e6d><div class="content-body" data-v-8eab0e6d><!--[--><!--[--><!--[--><div class="random-question random-question--nav" data-v-4e1b7e9a><button type="button" class="random-question__trigger random-question__trigger--nav" data-v-4e1b7e9a> 🎯 随机一题 </button><!--teleport start--><!--teleport end--></div><!--]--><!--]--><!--]--><div class="VPNavBarSearch search" data-v-8eab0e6d><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-8eab0e6d data-v-020be4db><span id="main-nav-aria-label" class="visually-hidden" data-v-020be4db> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/myKMS/" tabindex="0" data-v-020be4db data-v-815115f5><!--[--><span data-v-815115f5>Home</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/myKMS/interview/code.html" tabindex="0" data-v-020be4db data-v-815115f5><!--[--><span data-v-815115f5>面试</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/myKMS/knowledge/framework/react.html" tabindex="0" data-v-020be4db data-v-815115f5><!--[--><span data-v-815115f5>框架</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/myKMS/knowledge/browser/http.html" tabindex="0" data-v-020be4db data-v-815115f5><!--[--><span data-v-815115f5>浏览器</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-8eab0e6d data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-8eab0e6d data-v-ef6192dc data-v-a1a7286e><!--[--><a class="VPSocialLink no-icon" href="https://github.com/xingyuanlong/myKMS" aria-label="github" target="_blank" rel="me noopener" data-v-a1a7286e data-v-32d78712><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-8eab0e6d data-v-f953d92f data-v-d8fae6e2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-d8fae6e2><span class="vpi-more-horizontal icon" data-v-d8fae6e2></span></button><div class="menu" data-v-d8fae6e2><div class="VPMenu" data-v-d8fae6e2 data-v-fcd1d7a8><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>Appearance</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-a1a7286e><!--[--><a class="VPSocialLink no-icon" href="https://github.com/xingyuanlong/myKMS" aria-label="github" target="_blank" rel="me noopener" data-v-a1a7286e data-v-32d78712><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-8eab0e6d data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-8eab0e6d><div class="divider-line" data-v-8eab0e6d></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-304c8b69 data-v-5ae341c6><div class="container" data-v-5ae341c6><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-5ae341c6><span class="vpi-align-left menu-icon" data-v-5ae341c6></span><span class="menu-text" data-v-5ae341c6>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-5ae341c6 data-v-e28a51a6><button data-v-e28a51a6>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-304c8b69 data-v-e0eef791><div class="curtain" data-v-e0eef791></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-e0eef791><span class="visually-hidden" id="sidebar-aria-label" data-v-e0eef791> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0 has-active" data-v-a84b7c21 data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h2 class="text" data-v-6b36a2fd>基础知识</h2><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/base/js.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>js</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/base/nodejs.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>node</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/base/css.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>css</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0" data-v-a84b7c21 data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h2 class="text" data-v-6b36a2fd>interview</h2><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/interview/2025.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>2025</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/interview/code.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>code</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/interview/index.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>开放性问题</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0" data-v-a84b7c21 data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h2 class="text" data-v-6b36a2fd>框架</h2><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/framework/react.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>react</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/framework/vue.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>vue</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/framework/vite.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>工程化</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/framework/electron.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>electron</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0" data-v-a84b7c21 data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h2 class="text" data-v-6b36a2fd>浏览器</h2><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/browser/index.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>browser</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/browser/http.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>http</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/browser/webSecurity.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>web安全</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0" data-v-a84b7c21 data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h2 class="text" data-v-6b36a2fd>读书笔记</h2><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/book/vue_1.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>vue.js 设计与实践</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0" data-v-a84b7c21 data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h2 class="text" data-v-6b36a2fd>算法</h2><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/algorithm/index.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>总</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0" data-v-a84b7c21 data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h2 class="text" data-v-6b36a2fd>AI</h2><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/ai/index.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>ai</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-304c8b69 data-v-2652e39a><div class="VPDoc has-sidebar has-aside" data-v-2652e39a data-v-d668f7cc><!--[--><!--]--><div class="container" data-v-d668f7cc><div class="aside" data-v-d668f7cc><div class="aside-curtain" data-v-d668f7cc></div><div class="aside-container" data-v-d668f7cc><div class="aside-content" data-v-d668f7cc><div class="VPDocAside" data-v-d668f7cc data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-c8b19031><div class="content" data-v-c8b19031><div class="outline-marker" data-v-c8b19031></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-c8b19031>页面导航</div><ul class="VPDocOutlineItem root" data-v-c8b19031 data-v-b7d7ef80><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-d668f7cc><div class="content-container" data-v-d668f7cc><!--[--><!--]--><main class="main" data-v-d668f7cc><div style="position:relative;" class="vp-doc _myKMS_knowledge_base_js" data-v-d668f7cc><div><h1 id="js-知识" tabindex="-1">JS 知识 <a class="header-anchor" href="#js-知识" aria-label="Permalink to “JS 知识”">​</a></h1><h3 id="_1-js-闭包-如何理解" tabindex="-1">1.JS 闭包，如何理解 <a class="header-anchor" href="#_1-js-闭包-如何理解" aria-label="Permalink to “1.JS 闭包，如何理解”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><p>什么是闭包？ <strong>闭包是指一个函数能够记住并访问其词法作用域中的变量，即使该函数在其词法作用域之外执行。</strong></p><p>简单来说：<strong>当一个函数内部定义了另一个函数，并且内部函数引用了外部函数的变量，就创建了一个闭包。</strong></p><p>闭包的实际应用</p><ul><li>创建私有变量</li><li>在循环中使用闭包(解决引用问题)</li><li>模块模式</li></ul><p>闭包的工作原理 JavaScript 的作用域链机制使得闭包成为可能：</p><ul><li>每个函数在创建时都会保存对其词法环境的引用</li><li>当函数执行时，它会沿着作用域链查找变量</li><li>即使外部函数执行完毕，只要内部函数仍然存在，外部函数的变量就不会被垃圾回收</li></ul><p>闭包风险</p><ul><li>内存泄漏风险 ( 在不需要时手动解除引用)</li><li>性能考虑 过度使用闭包可能会影响性能，因为：需要维护额外的作用域链;变量查找时间可能增加;</li></ul><p>闭包本质上是：<strong>函数 + 其定义时的词法作用域（作用域链的引用）</strong></p><!--]--></div></div><h3 id="_2-描述-event-loop-运行机制" tabindex="-1">2.描述 Event Loop 运行机制 <a class="header-anchor" href="#_2-描述-event-loop-运行机制" aria-label="Permalink to “2.描述 Event Loop 运行机制”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><ol><li>背景 JavaScript 是 单线程 的：同一时刻只能执行一个任务。但浏览器/Node 需要同时处理用户输入、网络请求、定时器、渲染等。 👉 为了解决“同时处理多任务”的需求，JS 引入了 事件循环（Event Loop） 机制。</li></ol><p>Event Loop（事件循环）是 JavaScript 处理 异步操作 的核心机制。它允许 JavaScript 以 非阻塞 的方式执行代码，即使遇到 I/O 操作（如网络请求、定时器），也不会影响主线程继续执行其他任务。</p><p>三个核心关键概念</p><ul><li>Call Stack（调用栈） JS 引擎执行代码时，按照函数调用的嵌套关系入栈/出栈。同步代码按顺序直接在栈中运行。</li><li>Task Queue（任务队列） 异步任务完成后，将回调放入队列，等待主线程空闲时取出执行。</li><li>Event Loop（事件循环） 事件循环不断检查调用栈是否为空，如果为空，就从队列取出一个任务放入栈中执行。这个过程周而复始。</li></ul><p>JS 中的任务按优先级分为 宏任务（Macrotask） 和 微任务（Microtask）。</p><ul><li><p>宏任务（Macrotask）</p><ul><li>整体脚本 script</li><li>setTimeout / setInterval</li><li>setImmediate（Node）</li><li>I/O 回调</li><li>UI 渲染</li><li>JS 中用户输入（如 click、input、keydown 等 DOM 事件的回调）</li></ul></li><li><p>微任务（Microtask）</p><ul><li>Promise.then / catch / finally</li><li>queueMicrotask</li><li>MutationObserver（浏览器）</li><li>process.nextTick（Node）</li></ul></li></ul><p>规则： 每轮事件循环：</p><ul><li>执行一个宏任务</li><li>执行所有微任务（直到清空微任务队列）</li><li>渲染（浏览器）<strong>渲染永远在微任务之后</strong></li><li>开始下一轮循环</li></ul><p>顺序可认为是：</p><ul><li>task</li><li>microtasks</li><li>rAF callbacks</li><li>render (layout/paint/composite)</li><li>next task</li></ul><p>不是每轮事件循环都渲染</p><ul><li>浏览器一般按屏幕刷新率（比如 60Hz）渲染：</li><li>每 ~16.7ms 最多渲染一次 如果这一轮没有视觉更新、或还没到帧时间点，就可能跳过 render</li></ul><p><strong>同步先执行，异步分队列；先宏后微，再渲染。</strong></p><p>Node.js：</p><ul><li><strong>process.nextTick 优先级高于 Promise 微任务</strong></li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>[宏任务/事件] → [微任务] → [rAF 回调] → [样式计算/布局/合成/绘制] → [空闲回调/下一轮]</span></span></code></pre></div><p>在 rAF 中写样式/改 DOM，浏览器会在同一帧随后进行样式计算与绘制。</p><!--]--></div></div><h3 id="_3-网页多标签页之间如何通讯-和-iframe-如何通讯" tabindex="-1">3.网页多标签页之间如何通讯？和 iframe 如何通讯？ <a class="header-anchor" href="#_3-网页多标签页之间如何通讯-和-iframe-如何通讯" aria-label="Permalink to “3.网页多标签页之间如何通讯？和 iframe 如何通讯？”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><table tabindex="0"><thead><tr><th>特性</th><th><code>BroadcastChannel</code></th><th><code>localStorage</code> + <code>storage</code> 事件</th><th><code>postMessage</code> + iframe / worker</th></tr></thead><tbody><tr><td>是否需要刷新</td><td>否</td><td>否</td><td>否</td></tr><tr><td>是否支持多 Tab</td><td>✅</td><td>✅</td><td>部分（需要 iframe/worker）</td></tr><tr><td>是否易用</td><td>✅（直接发送消息）</td><td>中等（需要 JSON 序列化）</td><td>较复杂（需建立通道）</td></tr><tr><td>是否跨域</td><td>❌（只能同源）</td><td>❌</td><td>可跨域（需正确设置 targetOrigin）</td></tr><tr><td>性能</td><td>较好</td><td>一般（依赖 storage 事件）</td><td>较好</td></tr></tbody></table><!--]--></div></div><h3 id="_4-前端常见的设计模式有哪些-以及应用场景" tabindex="-1">4.前端常见的设计模式有哪些？以及应用场景 <a class="header-anchor" href="#_4-前端常见的设计模式有哪些-以及应用场景" aria-label="Permalink to “4.前端常见的设计模式有哪些？以及应用场景”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><table tabindex="0"><thead><tr><th>模式类型</th><th>设计模式</th><th>定义 / 核心思想</th><th>前端典型应用场景</th></tr></thead><tbody><tr><td><strong>创建型</strong></td><td>工厂模式（Factory）</td><td>用一个工厂方法创建对象，解耦对象创建和使用</td><td>组件库动态创建组件（ButtonFactory）、Axios 不同配置实例</td></tr><tr><td></td><td>单例模式（Singleton）</td><td>保证类只有一个实例，并提供全局访问</td><td>全局 Store（Redux/Pinia）、全局弹窗/通知、全局缓存</td></tr><tr><td><strong>结构型</strong></td><td>装饰器模式（Decorator）</td><td>不改变对象本身，动态给对象添加功能</td><td>React 高阶组件（HOC）、TS 装饰器、函数增强（日志、权限）</td></tr><tr><td></td><td>代理模式（Proxy）</td><td>通过代理对象控制对目标对象访问</td><td>Vue3 响应式、请求缓存、防抖/节流、懒加载</td></tr><tr><td></td><td>适配器模式（Adapter）</td><td>将不兼容接口转换为可用接口</td><td>封装第三方 SDK、统一后端接口格式、浏览器 API 兼容</td></tr><tr><td><strong>行为型</strong></td><td>观察者模式（Observer）</td><td>对象状态改变时通知所有订阅者</td><td>DOM 事件监听、Vue2 响应式依赖收集</td></tr><tr><td></td><td>发布订阅模式（Pub/Sub）</td><td>将事件和回调解耦，发布者触发事件，订阅者响应事件</td><td>Redux / Vuex 的状态更新订阅、EventBus、跨组件通信/pinia</td></tr><tr><td></td><td>策略模式（Strategy）</td><td>封装一系列算法，可互换</td><td>表单验证策略、支付方式选择、动画策略</td></tr><tr><td></td><td>命令模式（Command）</td><td>将请求封装为对象，便于参数化和管理</td><td>富文本编辑器命令、Undo/Redo、Canvas 绘图命令</td></tr><tr><td><strong>前端特有</strong></td><td>组合模式（Composition）</td><td>通过组合而非继承实现功能复用</td><td>React children、Vue 插槽（Slot）、Hooks 组合逻辑</td></tr><tr><td></td><td>MVVM / 单向数据流</td><td>数据驱动视图，状态单向流动</td><td>Vue / Angular MVVM、React + Redux</td></tr></tbody></table><!--]--></div></div><h3 id="_5-浏览器从输入-url-到显示网页的全过程" tabindex="-1">5.浏览器从输入 url 到显示网页的全过程 <a class="header-anchor" href="#_5-浏览器从输入-url-到显示网页的全过程" aria-label="Permalink to “5.浏览器从输入 url 到显示网页的全过程”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><!--]--></div></div><h3 id="_6-从-0-搭建一个前端项目-需要考虑哪些方面" tabindex="-1">6.从 0 搭建一个前端项目，需要考虑哪些方面 <a class="header-anchor" href="#_6-从-0-搭建一个前端项目-需要考虑哪些方面" aria-label="Permalink to “6.从 0 搭建一个前端项目，需要考虑哪些方面”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><p>主要是框架/库, 工具链 和cicd 选择</p><ul><li>技术选型：框架、状态管理、工具链、UI 组件库</li><li>项目架构：目录结构、模块化、路由、状态管理、接口管理</li><li>开发与运维：构建优化、测试、性能、安全、CI/CD</li></ul><!--]--></div></div><h3 id="_7-ajax-并发请求控制" tabindex="-1">7. ajax 并发请求控制 <a class="header-anchor" href="#_7-ajax-并发请求控制" aria-label="Permalink to “7.  ajax 并发请求控制”">​</a></h3><p>现有 30 个异步请求需要发送，但由于某些原因，我们必须将同一时刻并发请求数量控制在 5 个以内</p><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>async function batchRequestAllSettled(tasks, batchSize = 5) {</span></span>
<span class="line"><span>  const results = []</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  for (let i = 0; i &lt; tasks.length; i += batchSize) {</span></span>
<span class="line"><span>    const batch = tasks.slice(i, i + batchSize).map(fn =&gt; fn())</span></span>
<span class="line"><span>    // 等待当前批次所有请求完成（成功或失败）</span></span>
<span class="line"><span>    const batchResults = await Promise.allSettled(batch)</span></span>
<span class="line"><span>    results.push(...batchResults)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return results</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 使用示例</span></span>
<span class="line"><span>const urls = Array.from({ length: 30 }, (_, i) =&gt; `https://api.example.com/data/${i}`)</span></span>
<span class="line"><span>const tasks = urls.map(url =&gt; () =&gt; fetch(url).then(res =&gt; res.json()))</span></span>
<span class="line"><span></span></span>
<span class="line"><span>batchRequestAllSettled(tasks, 5).then(results =&gt; {</span></span>
<span class="line"><span>  results.forEach((res, idx) =&gt; {</span></span>
<span class="line"><span>    if (res.status === &#39;fulfilled&#39;) console.log(`任务 ${idx} 成功`, res.value)</span></span>
<span class="line"><span>    else console.log(`任务 ${idx} 失败`, res.reason)</span></span>
<span class="line"><span>  })</span></span>
<span class="line"><span>})</span></span></code></pre></div><!--]--></div></div><h3 id="_8-线上出了严重-bug-你该如何解决" tabindex="-1">8. 线上出了严重 bug 你该如何解决？ <a class="header-anchor" href="#_8-线上出了严重-bug-你该如何解决" aria-label="Permalink to “8. 线上出了严重 bug 你该如何解决？”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><p><strong>先止损 → 再排查 → 然后修复 → 最后复盘防再发</strong></p><ul><li>第一要务: <strong>回滚，及时止损</strong></li><li>通知项目组成员，看谁最近有过上线—— 线上 bug 一般是最近一次上线导致的</li><li>在本地或测试环境复现 bug，查找原因</li><li>修复，测试，重新上线</li><li>开<strong>复盘会议</strong>，以后如何规避此类问题 —— 总结经验教训</li></ul><!--]--></div></div><h3 id="_9-你如何保障代码质量" tabindex="-1">9. 你如何保障代码质量？ <a class="header-anchor" href="#_9-你如何保障代码质量" aria-label="Permalink to “9. 你如何保障代码质量？”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><ul><li>配置统一的 eslint 和 prettier 规则，规范代码格式</li><li>尽量组织 code review</li><li>使用 Sentry 等平台进行线上错误报警，并及时修复问题</li></ul><!--]--></div></div><h3 id="_10-esm-与-commonjs-的循环引用" tabindex="-1">10. esm 与 CommonJS 的循环引用 <a class="header-anchor" href="#_10-esm-与-commonjs-的循环引用" aria-label="Permalink to “10. esm 与 CommonJS 的循环引用”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><ul><li>CommonJS 模块规范在遇到循环引用时,Node 会返回当前已执行部分的 exports 对象.(Node 通过 require.cache 缓存机制避免了无限递归)</li><li>ES Module（ESM）在循环引用时有“实时绑定（live binding）”机制, (静态分析 esm编译阶段就确定依赖关系，不是在运行时动态执行; 单例缓存：同一个模块只会被执行一次，并缓存结果; 实时绑定 (live binding)：import 的变量不是值拷贝，而是一个引用，对应 export 的内存位置。所以即使 export 后续被修改，import 端也能拿到最新的值。)</li></ul><!--]--></div></div><h3 id="_11-esm-中-import-会发生什么" tabindex="-1">11. esm 中 import 会发生什么? <a class="header-anchor" href="#_11-esm-中-import-会发生什么" aria-label="Permalink to “11. esm 中 import 会发生什么?”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><p>ES Module (ESM) 的 import 是编译期就确定依赖关系;ESM 默认是 严格模式，并且是 异步加载</p><p><strong>解析阶段（Parsing）=&gt; 加载阶段 =&gt; 实例化阶段 =&gt; 执行阶段 =&gt; 缓存</strong></p><ul><li>为每个模块创建 模块环境记录（Module Environment Record），里面存放变量绑定, 实时绑定:如果 export 的值后来被修改，</li><li>import 端也能感知。ESM 的缓存机制是基于 URL/路径唯一性，并且在 异步上下文中生效。</li><li>esm缓存生效场景: 同一个模块被多次 import; 循环依赖(缓存的“半成品”也会存起来，这样可以避免死循环);动态 import 多次;</li></ul><p>import 导入的变量是 活引用（live binding），不是拷贝。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// counter.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// main.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { count, inc } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./counter.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">inc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1  ✅ 值会实时变化</span></span></code></pre></div><!--]--></div></div><h3 id="_12-在-js-代码中避免内存泄漏的方法" tabindex="-1">12. 在 JS 代码中避免内存泄漏的方法? <a class="header-anchor" href="#_12-在-js-代码中避免内存泄漏的方法" aria-label="Permalink to “12. 在 JS 代码中避免内存泄漏的方法?”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><ol><li>释放不再需要的引用(把对象置 null 或者移除属性，就能让 GC 正常回收。)</li><li>避免全局变量</li><li>小心闭包(闭包会一直保持引用,导致无法回收对象)</li><li>定时器 / 事件监听要清理</li><li>使用 WeakMap / WeakSet 存放临时对象</li><li>避免 JSON.stringify 大对象</li><li>复用对象 / 数组</li><li>按需加载数据</li><li>及时释放 DOM 引用</li></ol><!--]--></div></div><h3 id="_13-es6-继承在前-实例在后" tabindex="-1">13. es6 “继承在前，实例在后”? <a class="header-anchor" href="#_13-es6-继承在前-实例在后" aria-label="Permalink to “13. es6 “继承在前，实例在后”?”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><ul><li>new 子类发生什么: 创建子类实例对象 =&gt; 设置原型 =&gt; 父类构造函数执行 =&gt; 调用子类构造函数 =&gt; 子类构造函数继续执行</li><li>先创建空实例 → 调用子类 constructor → super() 调用父类 constructor → 父类属性挂载 → 回到子类挂载属性 → 实例返回。</li><li>ES6 的 class extends 就是对寄生组合继承的语法封装</li></ul><!--]--></div></div><h3 id="_14-script-type-module-是什么效果" tabindex="-1">14. script type=&quot;module&quot; 是什么效果? <a class="header-anchor" href="#_14-script-type-module-是什么效果" aria-label="Permalink to “14. script type=&quot;module&quot; 是什么效果?”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><ul><li><code>&lt;script type=&quot;module&quot;&gt;</code> 会 异步下载和解析，等 HTML 解析完成后执行，按依赖顺序执行模块代码，类似加了 defer 的普通脚本，但支持模块化特性。</li><li><code>&lt;script type=&quot;module&quot; async&gt;</code> 异步,下载完成立即执行,不保证顺序 (适合独立模块，不依赖 DOM，也不依赖其他模块执行顺序，比如统计脚本或广告脚本。)</li></ul><!--]--></div></div><h3 id="_15-文件的软链接与硬链接" tabindex="-1">15. 文件的软链接与硬链接? <a class="header-anchor" href="#_15-文件的软链接与硬链接" aria-label="Permalink to “15. 文件的软链接与硬链接?”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><ul><li>硬链接 = 同一份文件的不同名字, 删除源文件,不影响数据，数据依然可访问,</li><li>软链接 = 指向另一个文件路径的快捷方式, 删除源文件,软链接链接失效</li></ul><p>文件系统中使用一个叫做 inode（索引节点） 的结构来记录文件的真实内容。</p><ul><li>硬链接: 多个文件名共享同一个 inode。</li><li>软链接: 一个独立的文件，里面保存着目标文件的路径。(更像是 Windows 的快捷方式)</li></ul><!--]--></div></div><h3 id="_16-js-原型链-作用是什么" tabindex="-1">16.js 原型链, 作用是什么? <a class="header-anchor" href="#_16-js-原型链-作用是什么" aria-label="Permalink to “16.js 原型链, 作用是什么?”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><ul><li><p>原型链？ 在 JavaScript 里，每个对象都有一个隐藏属性 [[Prototype]]（通常通过 <strong>proto</strong> 访问）。当我们访问一个对象的属性/方法时，如果对象本身没有，JS 引擎就会顺着 [[Prototype]] 向上找。这条由 [[Prototype]] 串起来的链路，就叫 原型链。</p></li><li><p>原型链的作用</p><ul><li>核心作用就是实现继承和共享属性/方法。 <ul><li>继承机制：子对象可以通过原型链继承父对象的方法/属性。</li><li>方法复用：所有实例共享同一个方法定义，避免每次 new 都复制一份。</li><li>动态扩展：可以在运行时给 prototype 添加方法，所有实例立刻可用</li></ul></li></ul></li></ul><p>原型链是 JS 实现继承的机制，通过逐层查找 [[Prototype]] 来实现属性/方法共享和复用。</p><!--]--></div></div><h3 id="_17-web-components" tabindex="-1">17. web components <a class="header-anchor" href="#_17-web-components" aria-label="Permalink to “17. web components”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><p>Web Components 是一套 浏览器原生的前端组件技术标准，让开发者能创建可复用、封装、独立于框架的组件</p><ul><li><p>Custom Elements;Shadow DOM;HTML Templates;</p></li><li><p>继承 HTMLElement , 使用 customElements</p></li><li><p>生命周期</p><ul><li>constructor → 元素实例化</li><li>connectedCallback → 添加到 DOM</li><li>disconnectedCallback → 从 DOM 移除</li><li>attributeChangedCallback → 被观察属性变化</li></ul></li><li><p>属性</p><ul><li>HTML 属性与 JS 属性双向绑定</li><li>使用 observedAttributes + attributeChangedCallback</li><li>可以通过 getter/setter 做同步映射</li></ul></li><li><p>自定义事件</p><ul><li>使用 dispatchEvent(new CustomEvent(...))</li><li>穿透 Shadow DOM → composed: true</li><li>冒泡 → bubbles: true</li><li>建议只传小对象或数据引用</li></ul></li><li><p>插槽</p><ul><li>提供组件可插入自定义内容的能力</li><li><code>&lt;slot&gt;</code> 默认内容，外部可用 slot=&quot;name&quot; 覆盖</li></ul></li><li><p>属性/事件/插槽封装模式（常用技巧）</p><ul><li>formatProps → 统一解析属性</li><li>emit → 封装 dispatchEvent，像 Vue emit</li><li>BaseComponent → 封装生命周期、属性监听、事件分发、props 解析</li></ul></li><li><p>优点:</p><ul><li>原生支持;真正的封装;可复用性;互操作性;长期可用性</li></ul></li><li><p>缺点:</p><ul><li>生态和工具链;样式主题化困难;基础功能;SEO;</li></ul></li><li><p>优化:</p><ul><li>使用 requestAnimationFrame 节流渲染</li><li>维护虚拟 DOM / shadow DOM patch</li><li>避免深度 DOM 查询，每次 render 只更新变化部分</li></ul></li></ul><!--]--></div></div><h3 id="_18-ts-类型推断原理" tabindex="-1">18. ts 类型推断原理？ <a class="header-anchor" href="#_18-ts-类型推断原理" aria-label="Permalink to “18. ts 类型推断原理？”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><p>类型推断（Type Inference）指的是 —— 当开发者没有显式标注类型时，TypeScript 编译器自动根据上下文推导变量、参数、函数返回值的类型</p><p>TypeScript 在编译阶段会：</p><ul><li><p>扫描变量声明、赋值、函数签名、返回值；</p></li><li><p>根据上下文建立一个“类型约束图”（constraint graph）；</p></li><li><p>利用<strong>控制流分析（Control Flow Analysis）</strong>更新类型的可变性；</p></li><li><p>最终在不声明类型的情况下，自动推导出最合理的类型</p></li><li><p>当函数使用泛型时，TS 会从调用时的实参反向推导类型参数：</p></li><li><p>TS 类型系统支持从上下文反推表达式的类型，即“类型从左到右流动”：</p></li><li><p>TS 会在 if、switch、typeof、in、instanceof 等控制流语句中自动缩小类型：</p></li></ul><p>ts 适合:</p><ul><li>大型多人协作项目</li><li>SDK、组件库、Hooks 封装</li><li>安全重构 / 版本演进</li><li>智能提示和自文档化</li></ul><!--]--></div></div><h3 id="_19-canvas-与-svg" tabindex="-1">19. Canvas 与 SVG <a class="header-anchor" href="#_19-canvas-与-svg" aria-label="Permalink to “19. Canvas 与 SVG”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><table tabindex="0"><thead><tr><th>特性</th><th>Canvas</th><th>SVG</th></tr></thead><tbody><tr><td><strong>渲染方式</strong></td><td>位图（Bitmap），直接绘制到画布像素上</td><td>矢量图形（Vector），每个元素是 DOM 节点</td></tr><tr><td><strong>核心原理</strong></td><td>JS 调用 Canvas API 绘制，结果写入画布缓冲区；渲染完成后无法直接操作已画元素</td><td>XML 描述图形，浏览器解析为 DOM 节点；元素可直接操作和绑定事件</td></tr><tr><td><strong>交互性</strong></td><td>需要手动管理元素状态和事件，复杂</td><td>高，可直接绑定事件、样式和动画</td></tr><tr><td><strong>性能</strong></td><td>高性能，适合大量元素和频繁重绘</td><td>元素数量多时性能下降，不适合上万级节点</td></tr><tr><td><strong>缩放</strong></td><td>放大可能模糊，需要重绘</td><td>矢量缩放无损失</td></tr><tr><td><strong>典型应用场景</strong></td><td>游戏、实时数据图表、粒子动画、图像处理</td><td>数据可视化中等规模图表、流程图、拓扑图、矢量图标、地图</td></tr><tr><td><strong>优点</strong></td><td>高性能、适合实时渲染和复杂动画</td><td>高可交互性、开发简单、支持矢量缩放</td></tr><tr><td><strong>缺点</strong></td><td>不可直接操作已绘制元素、事件管理复杂</td><td>渲染大量元素性能下降、不适合高频更新</td></tr></tbody></table><!--]--></div></div><h3 id="_20-git-pull-与-git-fetch" tabindex="-1">20. git pull 与 git fetch <a class="header-anchor" href="#_20-git-pull-与-git-fetch" aria-label="Permalink to “20. git pull 与 git fetch”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><table tabindex="0"><thead><tr><th>对比项</th><th><code>git fetch</code></th><th><code>git pull</code></th></tr></thead><tbody><tr><td><strong>作用</strong></td><td>只从远程仓库拉取最新的提交记录和分支信息，不合并</td><td>从远程仓库拉取后，自动与本地分支进行合并（或 rebase）</td></tr><tr><td><strong>是否修改本地代码</strong></td><td>❌ 不会修改当前工作区或本地分支</td><td>✅ 会修改当前分支（触发 merge 或 rebase）</td></tr><tr><td><strong>是否更新远程追踪分支</strong></td><td>✅ 更新（如 <code>origin/main</code>）</td><td>✅ 更新（并合并到当前分支）</td></tr><tr><td><strong>安全性</strong></td><td>✅ 安全（不会改变当前代码）</td><td>⚠️ 有风险（可能产生冲突）</td></tr><tr><td><strong>命令形式</strong></td><td><code>git fetch [remote] [branch]</code></td><td><code>git pull [remote] [branch]</code></td></tr><tr><td><strong>实际等价操作</strong></td><td>—</td><td><code>git fetch</code> + <code>git merge FETCH_HEAD</code></td></tr><tr><td><strong>适用场景</strong></td><td>想先查看远程更新，不立即合并；或用于手动合并策略</td><td>想直接更新到最新版本（自动合并）</td></tr><tr><td><strong>可见效果</strong></td><td>更新 <code>.git</code> 内部的远程分支信息</td><td>同时更新远程信息并更新工作区</td></tr><tr><td><strong>是否可能冲突</strong></td><td>❌ 不会冲突</td><td>⚠️ 可能发生合并冲突</td></tr><tr><td><strong>常用组合命令</strong></td><td><code>git fetch origin main &amp;&amp; git log HEAD..origin/main</code></td><td><code>git pull origin main</code></td></tr></tbody></table><!--]--></div></div><h3 id="_21-git-merge-与-git-rebase" tabindex="-1">21. git merge 与 git rebase <a class="header-anchor" href="#_21-git-merge-与-git-rebase" aria-label="Permalink to “21. git merge 与 git rebase”">​</a></h3><div class="vp-collapse" data-v-4585a904><div class="vp-collapse__summary" data-v-4585a904><!--[-->► 展开<!--]--></div><div class="vp-collapse__content" style="display:none;" data-v-4585a904><!--[--><table tabindex="0"><thead><tr><th>对比项</th><th><code>git merge</code></th><th><code>git rebase</code></th></tr></thead><tbody><tr><td><strong>主要作用</strong></td><td>合并两个分支的历史记录，生成一个新的“合并提交”</td><td>将一个分支的提交重新“嫁接”到另一个分支上</td></tr><tr><td><strong>历史结构</strong></td><td>保留分叉历史（产生合并节点）</td><td>线性化历史（重写提交）</td></tr><tr><td><strong>是否生成新提交</strong></td><td>✅ 会生成一个新的 <em>merge commit</em></td><td>⚠️ 重新生成一批新的提交（commit hash 改变）</td></tr><tr><td><strong>提交历史结果</strong></td><td>历史复杂，但真实反映开发过程</td><td>历史干净，像一条直线</td></tr><tr><td><strong>是否修改提交哈希</strong></td><td>❌ 不会改变已有提交的哈希</td><td>✅ 所有 rebase 的提交哈希都会改变</td></tr><tr><td><strong>是否易冲突</strong></td><td>⚠️ 可能在合并时冲突一次</td><td>⚠️ 每个提交应用时都可能冲突</td></tr><tr><td><strong>安全性</strong></td><td>✅ 安全（不会重写历史）</td><td>⚠️ 可能破坏共享历史（不建议在公共分支上用）</td></tr><tr><td><strong>适用场景</strong></td><td>保留真实开发分支结构（例如多人合作）</td><td>自己分支上整理历史，让日志更清晰</td></tr><tr><td><strong>常见命令</strong></td><td><code>git merge feature</code></td><td><code>git rebase main</code></td></tr><tr><td><strong>结果历史示意</strong></td><td>分叉 + 合并节点 🪵</td><td>一条直线 🚀</td></tr><tr><td><strong>是否影响他人</strong></td><td>❌ 不会（提交哈希不变）</td><td>⚠️ 若已推送，会影响他人分支同步</td></tr></tbody></table><!--]--></div></div><h2 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to “其他”">​</a></h2><ul><li><p>12px 的字体只能满足 37.6% 用户的阅读体验，但如果我们将字体放大到 14px，就可以保证大约 77% 的显示器用户处于比较好的阅读体验</p></li><li><p>h5 开发尺寸可以使用 750 * 1350</p></li><li><p>移动端300ms延时的原因是啥 ?</p><ul><li><p>根本原因：浏览器要等待判断用户是否要“双击缩放”。现代解决方案：正确设置 viewport 或使用 touch-action: manipulation，即可完全消除延迟。</p></li><li><p>早期（iPhone 3G / Android 2.x 时代）移动浏览器需要区分两种用户操作：</p><ul><li>单击（tap）</li><li>双击（double tap） —— 用来缩放页面（放大文字、图片）</li></ul></li><li><p>👉 为了判断用户是不是要“再点一次”，浏览器必须 等待一小段时间（约300ms）。</p></li><li><p>于是：</p><ul><li>用户点击一次，浏览器先不立即触发 click；</li><li>等待 300ms；</li><li>如果在 300ms 内用户又点了一次 → 识别为“双击缩放”；</li><li>否则才触发单击事件。</li></ul></li><li><p>这就是 “300ms click delay”。</p></li></ul></li></ul></div></div></main><footer class="VPDocFooter" data-v-d668f7cc data-v-1bcd8184><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><!----></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/myKMS/knowledge/base/nodejs.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>Next page</span><span class="title" data-v-1bcd8184>node</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"ai_index.md\":\"Cxc5djOL\",\"algorithm_index.md\":\"BAC8T6ba\",\"api-examples.md\":\"E6LX-pdi\",\"book_vue_1.md\":\"CxTBYs6e\",\"index.md\":\"CZQXgvW8\",\"interview_2025.md\":\"DlzCptuz\",\"interview_code.md\":\"DsYQlBp5\",\"interview_index.md\":\"CDNwji7O\",\"knowledge_base_app.md\":\"BzB-ntl5\",\"knowledge_base_css.md\":\"2cQpbvS5\",\"knowledge_base_js.md\":\"BbqvaTkS\",\"knowledge_base_nodejs.md\":\"BSXMttSJ\",\"knowledge_browser_http.md\":\"wycGYWXF\",\"knowledge_browser_index.md\":\"CQO48v9p\",\"knowledge_browser_websecurity.md\":\"BluWW2j2\",\"knowledge_framework_angular.md\":\"BPcHROea\",\"knowledge_framework_app.md\":\"DL-BSY03\",\"knowledge_framework_electron.md\":\"CHXctEPH\",\"knowledge_framework_react.md\":\"Dlj_TB3-\",\"knowledge_framework_taro.md\":\"R_D0LbuV\",\"knowledge_framework_vite.md\":\"BmQE8KNI\",\"knowledge_framework_vue.md\":\"CDqHUzw4\",\"knowledge_framework_wx.md\":\"9mMAHaOQ\",\"readme.md\":\"Dz7ap6P5\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"知识库\",\"description\":\"知识库\",\"base\":\"/myKMS/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"Home\",\"link\":\"/\"},{\"text\":\"面试\",\"link\":\"/interview/code\"},{\"text\":\"框架\",\"link\":\"/knowledge/framework/react\"},{\"text\":\"浏览器\",\"link\":\"/knowledge/browser/http\"}],\"sidebar\":[{\"text\":\"基础知识\",\"items\":[{\"text\":\"js\",\"link\":\"/knowledge/base/js\"},{\"text\":\"node\",\"link\":\"/knowledge/base/nodejs\"},{\"text\":\"css\",\"link\":\"/knowledge/base/css\"}]},{\"text\":\"interview\",\"items\":[{\"text\":\"2025\",\"link\":\"/interview/2025\"},{\"text\":\"code\",\"link\":\"/interview/code\"},{\"text\":\"开放性问题\",\"link\":\"/interview/index\"}]},{\"text\":\"框架\",\"items\":[{\"text\":\"react\",\"link\":\"/knowledge/framework/react\"},{\"text\":\"vue\",\"link\":\"/knowledge/framework/vue\"},{\"text\":\"工程化\",\"link\":\"/knowledge/framework/vite\"},{\"text\":\"electron\",\"link\":\"/knowledge/framework/electron\"}]},{\"text\":\"浏览器\",\"items\":[{\"text\":\"browser\",\"link\":\"/knowledge/browser/index\"},{\"text\":\"http\",\"link\":\"/knowledge/browser/http\"},{\"text\":\"web安全\",\"link\":\"/knowledge/browser/webSecurity\"}]},{\"text\":\"读书笔记\",\"items\":[{\"text\":\"vue.js 设计与实践\",\"link\":\"/book/vue_1\"}]},{\"text\":\"算法\",\"items\":[{\"text\":\"总\",\"link\":\"/algorithm/index\"}]},{\"text\":\"AI\",\"items\":[{\"text\":\"ai\",\"link\":\"/ai/index\"}]}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/xingyuanlong/myKMS\"}],\"outline\":{\"level\":[2,3],\"label\":\"页面导航\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false,\"additionalConfig\":{}}");</script>
    
  </body>
</html>