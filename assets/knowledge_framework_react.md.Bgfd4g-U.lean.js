import{_ as p,I as r,c as h,o as k,ah as n,J as e,j as i,w as l,a}from"./chunks/framework.fGi7qB65.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/framework/react.md","filePath":"knowledge/framework/react.md"}'),d={name:"knowledge/framework/react.md"};function o(c,s,u,E,g,y){const t=r("Collapse");return k(),h("div",null,[s[4]||(s[4]=n("",201)),e(t,null,{default:l(()=>[...s[0]||(s[0]=[i("p",null,"i18n 实现国际化",-1),i("ol",null,[i("li",null,"动态语言切换 + 按需加载")],-1),i("ul",null,[i("li",null,"动态import+映射表,页面级组件在useEffect或路由加载时调用i18n.addResources(),减少初始打包体积，提高首屏加载速度, 使用缓存(localStorage / IndexedDB)")],-1),i("ol",{start:"2"},[i("li",null,"日期/时间/数字/货币格式化"),i("li",null,"自动提取翻译 Key & 多语言管理")],-1),i("ul",null,[i("li",null,"i18next-scanner 扫描")],-1),i("ol",{start:"4"},[i("li",null,"i18n + 路由（多语言 URL）")],-1),i("ul",null,[i("li",null,":lang 作为路由参数, 配合effect, navigate loadLanguage实现")],-1),i("ol",{start:"5"},[i("li",null,[a("i18n 国际化对 React 组件性能的影响？如何优化？ "),i("ul",null,[i("li",null,"react-i18next 会在语言切换时触发重新渲染依赖翻译的组件: 精准使用 useTranslation('namespace')(语言文件可以按 namespace 划分)，避免全局组件不必要渲染;"),i("li",null,"Trans 组件只包裹需要翻译的部分;"),i("li",null,"使用 memoization (React.memo) 避免深层组件重复渲染, 避免重复 useTranslation, 子组件可通过 props 传递翻译后的文本, react-i18next 使用 Context + Hook，组件通过 useTranslation() 获取翻译函数 t()")])])],-1)])]),_:1}),s[5]||(s[5]=i("h3",{id:"_27-自己写的hooks",tabindex:"-1"},[a("27. 自己写的hooks "),i("a",{class:"header-anchor",href:"#_27-自己写的hooks","aria-label":"Permalink to “27. 自己写的hooks”"},"​")],-1)),e(t,null,{default:l(()=>[...s[1]||(s[1]=[i("ul",null,[i("li",null,"简单的 useLocalStorage;"),i("li",null,"基于useRequest封装项目使用useDict 提供 dict 功能,支持单个, 批量获取dict 初始化, 缓存, 刷新, getLabel; - useFlatOrgTree 获取机构树, 后端是List 的结构, 转化成Tree 结构, 还有把Tree 结构转化成list机构;"),i("li",null,"useModal 把弹窗状态和打开关闭方法封装成一个hook(open 是的把对象传入);"),i("li",null,"usePermission 判断权限, useRequset:"),i("li",null,"基于 vueuse的useAsyncState 封装的 useRequset, 返回state,isLoading,isReady,run, 支持配置showMessage,formatResult,initialState, immediate等;"),i("li",null,"useSearchTable 将 table 操作封装再里面;"),i("li",null,"useConfirm")],-1)])]),_:1}),s[6]||(s[6]=i("h3",{id:"_28-redux-toolkit",tabindex:"-1"},[a("28.Redux Toolkit "),i("a",{class:"header-anchor",href:"#_28-redux-toolkit","aria-label":"Permalink to “28.Redux Toolkit”"},"​")],-1)),e(t,null,{default:l(()=>[...s[2]||(s[2]=[i("ol",null,[i("li",null,"createSlice 内部用 Immer，允许你写“可变写法”，但底层会生成不可变的新 state。"),i("li",null,[a("createAsyncThunk 内部是如何工作的？ "),i("ul",null,[i("li",null,[a("生成一个 thunk action（函数），会在调用时触发一个 生命周期三段式： "),i("ul",null,[i("li",null,"pending → 异步任务开始"),i("li",null,"fulfilled → 异步任务成功"),i("li",null,"rejected → 异步任务失败")])]),i("li",null,"内部用 dispatch 多次派发 action，而不是只派发一次。")])])],-1),i("p",null,"3.Redux Toolkit 如何优化性能 - 1.内置 Immer + useSelector 的 浅比较，减少无效渲染。 - 2.createEntityAdapter 提供规范化数据结构（normalized state），避免深层次 diff。 - 3. 配合 memo / useMemo / useCallback，只渲染必要组件。",-1),i("ol",{start:"4"},[i("li",null,[a("如果要在 Redux Toolkit 里实现一个 Undo/Redo 功能，怎么做？ "),i("ul",null,[i("li",null,"在 reducer 里维护一个 past[]、present、future[] 三段式结构。"),i("li",null,"每次 dispatch：把当前 present 推入 pastpresent 替换为新 state"),i("li",null,"Undo → 从 past 弹出最后一个到 present，并把原先的 present 推入 future")])])],-1)])]),_:1}),s[7]||(s[7]=i("h3",{id:"_29-react-usestate-usereducer-useref-useeffece-原理",tabindex:"-1"},[a("29. react usestate usereducer useref useeffece 原理 "),i("a",{class:"header-anchor",href:"#_29-react-usestate-usereducer-useref-useeffece-原理","aria-label":"Permalink to “29. react usestate usereducer useref useeffece 原理”"},"​")],-1)),e(t,null,{default:l(()=>[...s[3]||(s[3]=[i("p",null,"环形队列就是：链表的最后一个节点的 next 指针 指向头节点，形成一个环。",-1),i("ul",null,[i("li",null,[i("p",null,"useState 的原理"),i("ul",null,[i("li",null,"原理可以拆解成三个部分：状态保存、状态更新 和 触发渲染。 useState 把状态保存在 Fiber 的 Hook 链表中，setState 通过更新队列记录变化，并触发 Fiber 的调度和重新渲染，最终在下一次执行组件时计算出新状态。"),i("li",null,"React 为什么需要 useState: 在函数组件里，普通的局部变量在函数执行完后会被销毁。React 通过 useState 把状态存放在 Fiber 节点 上，这样每次函数组件重新执行时，状态不会丢失。"),i("li",null,"状态保存原理: 每个组件对应一个 Fiber 节点。Fiber 上有一个 memoizedState 属性，存储链表结构，保存多个 Hook 的状态。"),i("li",null,"状态更新原理: 调用 setState 时, 会创建一个 更新对象, 放到对应 Hook 的更新队列里, 然后 React 会调度一次 组件重新渲染"),i("li",null,"触发渲染机制: setState 本质上调用了 React 的 调度器，会标记当前 Fiber 为需要更新，然后触发一次 Fiber 调度 → Diff → commit → 重新渲染 流程。")])]),i("li",null,[i("p",null,"usereducer原理"),i("ul",null,[i("li",null,"useState 的原理一样, 是把状态更新逻辑抽出来交给 reducer 函数. 其实 React 内部 useState 就是 useReducer 的语法糖。"),i("li",null,"useReducer 本质上和 useState 一样，状态保存在 Fiber Hook 链表里，更新通过环形队列记录；不同的是，它通过 reducer(state, action) 把更新逻辑交给用户，让状态更新更可控。")])])],-1),i("div",{class:"language-"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"}),i("pre",{class:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabindex:"0",dir:"ltr"},[i("code",null,[i("span",{class:"line"},[i("span",null,"function useState(initialState) {")]),a(`
`),i("span",{class:"line"},[i("span",null,"    return useReducer((state, action) => {")]),a(`
`),i("span",{class:"line"},[i("span",null,"        return typeof action === 'function' ? action(state) : action;")]),a(`
`),i("span",{class:"line"},[i("span",null,"    }, initialState);")]),a(`
`),i("span",{class:"line"},[i("span",null,"}")])])])],-1),i("ul",null,[i("li",null,[i("p",null,"useRef 原理"),i("ul",null,[i("li",null,"useRef 的作用就是：给你一个不会变的“盒子”来存放东西。"),i("li",null,"和其他 Hooks 一样，useRef 也存放在 Fiber 的 Hook 链表里。 不同点在于：初次渲染时，React 会创建一个对象 { current: initialValue }，并保存到 memoizedState。之后的渲染，直接返回同一个对象。"),i("li",null,"每次调用 useRef，拿到的都是同一个对象引用；修改 .current 不会触发渲染，因为 React 不会监听这个值的变化。")])]),i("li",null,[i("p",null,"useeffece 原理"),i("ul",null,[i("li",null,"React 提供 useEffect，把这些副作用挂到 Fiber 的副作用链表，在 DOM 更新提交之后 执行。(commit 阶段执行)"),i("li",null,[a("可以分成三个阶段: 初次渲染, 提交阶段, 更新渲染 "),i("ul",null,[i("li",null,"updateQueue（effect 链表）"),i("li",null,"layoutEffect（同步执行）：在 DOM 更新后，浏览器绘制之前执行（会阻塞渲染）。"),i("li",null,"effect（即 useEffect）（异步执行）：在浏览器完成绘制后执行，不会阻塞渲染")])]),i("li",null,"useEffect 的原理就是：在渲染时收集副作用，存到 Fiber 的effect链表；在commit阶段统一执行，并根据依赖数组判断是否需要重新运行，同时处理清理函数。")])])],-1)])]),_:1}),s[8]||(s[8]=n("",2))])}const f=p(d,[["render",o]]);export{b as __pageData,f as default};
