
pr

### 1. react vue 有什么区别和相似

对比:

- vue 编译+运行时框架, react 运行时, 所以vue 再编译时能够做很多优化(如静态标记和动态提升), react 更注重运行时, react 19 也有 React Compiler 编译优化. (svelte 纯编译 )

- React：UI 库（Library），专注于 视图层，其它路由/状态管理等靠社区生态（React Router、Redux）。
    Vue：渐进式框架（Framework），提供了从视图到路由、状态管理（Vue Router、Pinia/Vuex）的完整解决方案。

- 语法与编程范式:
  - React：以 JavaScript/TypeScript 为核心，用 JSX 描述 UI。
                更偏向函数式编程，鼓励用 Hooks 管理状态、副作用。
  - Vue：提供 单文件组件 (SFC)，分为 `<template> + <script> + <style>`。
                更接近声明式和模板式编程，容易上手
  
- 数据绑定
  - React：单向数据流，props → 子组件，更新需要 setState 或 useState。
  - Vue：双向数据绑定 (v-model)，适合表单场景，逻辑简洁。

- 性能优化
  - React：依靠 shouldComponentUpdate / React.memo / useMemo / useCallback。
  - Vue：通过 响应式系统（Proxy + Effect 追踪依赖），自动追踪更新；还可以用 v-once、computed 优化

- 状态管理
  - React：依赖外部库（Redux、MobX、Zustand、Recoil 等），灵活但碎片化。
  - Vue：官方提供 Vuex（Vue2）/ Pinia（Vue3），统一、集成度高

- 底层区别:

1.核心思想

- React
     1. 核心是函数式 + 状态驱动 UI：UI = f(state)。
     2. 关注数据不可变和纯函数更新。
     3. React 本身是渲染库，路由/状态管理等能力由社区提供。
- Vue
     1. 核心是响应式系统 + 模板编译：通过响应式追踪 + 渲染函数驱动更新。
     2. 偏向声明式与命令式相结合，易上手。
     3. Vue 是一个完整的框架，提供更多开箱即用的能力。

2. 响应式机制
   - React: 没有内置响应式，靠 useState/useReducer 触发组件更新。每次 setState 会触发组件重新渲染，然后通过虚拟 DOM diff 决定哪些节点需要更新。数据变化 → 全量渲染 → Diff → 最小化 DOM 更新。
   - Vue: Vue 2 使用 Object.defineProperty，Vue 3 使用 Proxy；通过精确的依赖追踪，只有用到字段的组件或计算属性会订阅该字段。数据变化 → 精确找到依赖它的组件/模板 → 只更新必要部分。

3. 虚拟 DOM & 渲染
   - React: 使用 Fiber 架构（从 v16 开始）。每个组件对应一个 Fiber 节点，支持异步可中断渲染（time slicing、并发模式），强调调度与优先级，确保 UI 流畅。
   - Vue: Vue 3 借助编译期优化和 Block Tree（静态提升 + 动态节点追踪）。模板在编译时划分为“静态节点 + 动态节点”，更新时只 diff 动态部分。Vue 3.6 引入的 Vapor Mode 甚至尝试跳过虚拟 DOM，生成更精确的更新代码。

4. 调度机制
   - React：有完整的 Scheduler，支持优先级队列（用户交互优先、网络渲染延后）和并发渲染（Concurrent Mode）。
   - Vue：内置异步队列 + nextTick，保证数据更新合并（批量刷新），调度相对简单，不区分复杂优先级。

5. 渲染层抽象
   - React: ReactDOM 是一个渲染器，底层渲染器可替换（React Native、Ink、three-fiber），通过 Reconciler + Renderer 解耦。
   - Vue: Vue 3 同样有 Renderer 抽象（runtime-core + runtime-dom），官方维护 DOM 渲染器及其它平台的渲染器，但 React 在多端渲染生态上更成熟。

6. 生态设计
   - React：小核 + 强社区，灵活且可扩展（例如 React Native、Next.js、Remix 等）。
   - Vue：整体框架理念，内置响应式和编译器，适合小团队和中台项目，使用体验更统一。

相似性

- 都是 UI 层框架，专注视图
- 都基于 数据驱动视图
- 都通过 虚拟 DOM 进行高效 DOM 更新
- 都是 组件化开发，支持递归组合
- 父 → 子（props）单向数据流 保证数据可预测性
- 都有 生命周期钩子
- 都支持 SSR / SSG / CSR 混合渲染
- 都在追求 更细粒度更新和并发渲染
- 都支持跨平台渲染

### 2.qiankun

- js 隔离:
    1.SnapshotSandbox（快照沙箱）: 在应用切换前，把 window     的状态做一份快照。子应用运行时，修改的全局变量只保存在自己的快照里。卸载子应用时，还原 window。缺点：只能同时激活一个子应用（适合单实例场景）。

    2.ProxySandbox（代理沙箱）
      基于 ES6 Proxy 拦截子应用对全局对象的读写。每个子应用有一个独立的代理对象作为 window，实际访问 window.xxx 时，会优先读写子应用自己的代理上下文。多个子应用可并行运行，互不影响。

    qiankun 默认在支持 Proxy 的浏览器下使用这个方案

```
const fakeWindow = {};
const proxy = new Proxy(window, {
        get(target, key) {
        return key in fakeWindow ? fakeWindow[key] : target[key];
},
set(target, key, value) {
        fakeWindow[key] = value;
        return true;
      }
});
```

- 样式隔离:

  1. 严格样式隔离: Shadow DOM 兼容性不好
  2. 实验性样式隔离（样式前缀）:通过 ScopedCSS 插件，在运行时动态给子应用 CSS 加上前缀（比如 [data-qiankun="xxx"]）。确保样式只影响当前子应用的 DOM。原理类似 Vue 的 scoped 样式，但是在运行时做。
  3. css BEM, PostCSS 插件

### 3. amis 表单联动

  1. 给某个表单项绑定 onChange，当值变化时更新另一个表单项。
  2. 如果是展示或可用性联动 visibleOn / disabledOn

### 4.vite 插件

```
import type { Plugin } from 'vite';

function myPlugin(options?): Plugin {
  return {
    name: 'my-plugin',  // **必须**有 name，方便调试
    // enforce: 'pre' 或 'post'（可选），指定此插件执行顺序
    config(config, { command }) {
      // 修改 Vite / Rollup 配置（可选）
    },
    configResolved(resolvedConfig) {
      // 当最终 config 确定后执行
    },
    resolveId(source, importer) {
      // 自定义模块解析逻辑
    },
    load(id) {
      // 如果你要“自己加载一个模块”，返回内容
      // 否则返回 null 让后续钩子 /默认流程处理
    },
    transform(code, id) {
      // 转换模块源代码，返回 { code, map } 或 string
    },
    handleHotUpdate(ctx) {
      // 在开发服务下，处理 HMR 热更新逻辑
    },
    // 构建阶段钩子
    buildStart() { },
    generateBundle(options, bundle, isWrite) { },
    writeBundle() { },
    closeBundle() { },
  };
}
```

// 替换模板的一个字

```
export default function replaceTextPlugin(options = { search: 'FOO', replace: 'BAR' }) {
  return {
    name: 'vite-plugin-replace-text',
    enforce: 'pre',
    transform(code, id) {
      if (/\.(js|ts|jsx|tsx)$/.test(id)) {
        return code.replace(new RegExp(options.search, 'g'), options.replace);
      }
      return null;
    }
  };
}
```

// 统计TODO

```
import fs from 'fs';
import path from 'path';

export function vitePluginTodo() {
  const todos = [];

  function scanFile(filePath) {
    const code = fs.readFileSync(filePath, 'utf-8');
    const lines = code.split('\n');

    lines.forEach((line, index) => {
      const todoMatch = line.match(/\/\/\s*TODO\s*:(.*)/i) 
                     || line.match(/\/\*\s*TODO\s*:(.*)\*\//i);

      if (todoMatch) {
        todos.push({
          file: path.relative(process.cwd(), filePath),
          line: index + 1,
          content: todoMatch[1].trim(),
        });
      }
    });
  }

  function scanDir(dir) {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        if (entry.name === 'node_modules' || entry.name.startsWith('.')) continue;
        scanDir(fullPath);
      } else if (/\.(ts|js|tsx|jsx|vue)$/.test(entry.name)) {
        scanFile(fullPath);
      }
    }
  }

  console.log('vite-plugin-todo');
  return {
    name: 'vite-plugin-todo',
    apply: 'build',
    buildStart() {
      console.log('vite-plugin-todo buildStart');
      todos.length = 0;
      scanDir(process.cwd());
    },
    closeBundle() {
      if (todos.length > 0) {
        console.log('\n💡 TODO List:');
        todos.forEach(todo => {
          console.log(`${todo.file}:${todo.line} - ${todo.content}`);
        });
      } else {
        console.log('\n✅ No TODO found.');
      }
    }
  };
}

```

### 5. webpack 和 vite 的区别

1. Webpack：老牌的 打包器，把所有依赖打包成一个或多个 bundle。
2. Vite：新一代 前端构建工具，开发环境利用浏览器的 原生 ES 模块 (ESM)，生产环境用 Rollup 打包。

1.开发模式
        Webpack：
            启动时必须 先打包整个项目，再启动 dev server。
            启动速度和项目体积成正比。
        Vite：
            启动时 不打包业务代码，依赖用 esbuild 预构建，源码按需编译。
                启动速度几乎和项目体积无关，大型项目也能秒开。

        👉 一句话：Webpack = 打包后再跑，Vite = 边跑边编译。

2. 热更新（HMR）
      webpack：基于打包产物 diff，大型项目热更新会卡顿。
      Vite：直接基于 ESM 精确替换模块，更新速度更快。

3. 生产构建
        Webpack：开发和生产都用自家打包逻辑。
        Vite：开发用 esbuild + ESM，生产用 Rollup 打包（Tree-shaking 更强，但生态不如 Webpack 丰富）。

4. 配置与生态
        Webpack：配置复杂但灵活。loader + plugin 生态极其成熟。
        Vite：开箱即用，配置简单。插件体系基于 Rollup，生态在快速增长。

Webpack 是基于打包的老牌全能工具，功能强大但启动和热更新慢；Vite 利用 ESM 和 esbuild，开发体验好、速度快，生产打包用 Rollup。

### 6. React Fiber 架构

Fiber 是 React 对 虚拟 DOM 渲染机制的重写，它的核心目标是：支持可中断的渲染和任务优先级调度，从而改善大型应用的渲染性能和用户体验。简单理解就是：把更新任务拆成可中断的小单元，按优先级调度执行。

Fiber 的数据结构: Fiber 是一个链表/树形结构，每个 Fiber 节点对应一个 React 元素或组件。

双阶段渲染（两阶段 Reconciliation）:Fiber 实现了 可中断渲染，把渲染分为两个阶段：

- Render 阶段（Reconciliation, 构建 Fiber 树，比较新旧 Fiber 树，生成 effect list（要更新的副作用列表）。可以中断、按优先级切分任务。不直接修改 DOM。
- Commit 阶段:遍历 effect list，将副作用应用到真实 DOM。是同步执行的，一旦开始就不能中断。包括挂载、更新、删除 DOM.


调度与优先级:Fiber 内置 任务调度器，任务分为不同优先级：同步任务（高优先级，如点击事件);动画任务异步任务（低优先级，如网络请求完成后的渲染）通过分片（time slicing）和 requestIdleCallback / requestAnimationFrame，保证 UI 不被阻塞

- Fiber 为什么要出现？
  - 为了解决 React 15 的同步渲染阻塞问题，支持可中断渲染和任务优先级。

- Fiber 树 vs 虚拟 DOM 树区别？

  - 虚拟 DOM 树只表示 UI 元素结构。
  - Fiber 树表示元素 + 组件 + 更新状态 + 优先级 + 副作用列表，更复杂。

- Render 阶段和 Commit 阶段有什么区别？
  - Render 阶段：可中断、生成 effect list，不触碰 DOM。
  - Commit 阶段：同步执行、应用 effect，修改真实 DOM

--- 
jc

### 7. 单点登录:
  
用户在一个系统上登录后，就能无感知地访问其他关联系统，无需再次登录。

- 统一身份认证中心（Identity Provider, IdP）
  - 用户只在认证中心登录一次。
  - 认证中心负责验证用户名/密码、签发令牌（如 JWT、SAML、OAuth2 Token）。

- 业务系统（Service Provider, SP）
  - 用户访问业务系统时，业务系统会跳转到认证中心校验。
  - 认证成功后，认证中心返回一个「登录凭证」（Token / Ticket）。
  - 业务系统验证凭证后，允许用户访问。

- Cookie + Session（早期）
  - 依赖共享 Cookie（要求同域或二级域名一致）。
  - 局限性大，不适合跨域。

- Token（JWT / OAuth2 / OpenID Connect）（主流）
  - 用户认证成功后，认证中心签发 Token。
  - 各系统通过 Token 识别用户，支持跨域、跨平台。


### 8.状态管理redux mobx pinna 设计模式是啥？区别是啥


| 维度          | Redux               | MobX                         | Pinia                       |
| ----------- | ------------------- | ---------------------------- | --------------------------- |
| 状态更新方式      | 不可变 + reducer       | 可变 + observable              | 可变 + reactive               |
| 阅读 /可预测性    | 高（统一入口）             | 较低（更新处散落）                    | 较中等 /接近 Vue 响应式方式           |
| 异步 /副作用管理   | 通过中间件（thunk / saga） | action / reaction / autorun  | 普通 action + 插件 /订阅          |
| 模块化         | 使用 reducer 组合拆分     | 多 store / classes            | 天生模块 store                  |
| 学习成本        | 较高                  | 较低                           | 中等（依赖 Vue 响应式理解）            |
| 调试工具 / 时间旅行 | 强支持（Redux DevTools） | 有 MobX DevTools、reaction 日志等 | Pinia Devtools /插件支持        |
| 适合场景        | 大型复杂状态，团队协作         | 快速开发、响应性重 UI                 | Vue 应用 / Composition API 生态 |

| 库     | 核心模式                           | 特点                                 |
| ------ | ---------------------------------- | ------------------------------------ |
| Redux  | 发布-订阅 + 单例模式 + 函数式编程    | 可预测、严格、样板代码多              |
| MobX   | 观察者模式 + 响应式 + 面向对象(OOP) | 简洁直观、自动追踪依赖、灵活          |
| Pinia  | 观察者模式 + 依赖注入 + 组合模式     | 结合 Vue3 响应式系统，轻量优雅        |


观察者模式 与 发布-订阅模式（格式化）

| 模式               | 是否有中介 | 耦合度   | 典型场景                     |
| ------------------ | ---------- | -------- | ---------------------------- |
| 观察者模式 (Observer)    | ❌ 没有中介  | 相对紧耦合 | UI 响应数据变化（如 Vue2）        |
| 发布-订阅模式 (Pub/Sub)  | ✅ 有中介    | 松耦合     | 事件总线、跨模块通信、消息队列    |

概念要点：

- 观察者模式（Observer）
  - 结构：有一个目标对象（Subject），维护观察者列表；状态变化时主动通知所有观察者。
  - 特点：点对点通知，被观察者需要知道其观察者；适合一对多、紧密协作场景。

- 发布-订阅模式（Publish‑Subscribe）
  - 结构：引入消息中间件/事件中心，发布者发布事件到中间件，订阅者从中间件订阅事件。
  - 特点：发布者与订阅者解耦，扩展性强，适合多对多和跨模块通信。

对比总结：

- 耦合：Observer 更紧耦合（Subject 知道 observers）；Pub/Sub 更松耦合（通过中介解耦）。
- 可扩展性：Pub/Sub 更易扩展和复用；Observer 更简单、直接，适合 UI 内部数据驱动场景。

观察者模式（简要结构示例）
- Subject: 维护 observers 列表，提供 register / unregister / notify 方法。
- Observer: 实现 update 接口，接收通知并更新自身。

发布-订阅模式（简要结构示例）
- EventBus（中介）: on / off / emit。
- 发布者: emit(event, payload)。
- 订阅者: on(event, handler)。


### 9. 如果一个项目 使用了antd 组件库, 又使用了antd 2次开发组件库 会不会有问题
1. 样式冲突, 可以通过修改命名前缀区分
2. ConfigProvider 全局化配置也可能会冲突

### 10. 页面卡顿，内存泄露排查

| 现象                   | 原因可能性                                       |
| -------------------- | ------------------------------------------- |
| 页面卡顿 / 帧率低 /响应迟钝     | JS 执行时间过长、频繁重绘/重排、布局触发、事件处理阻塞、定时器或循环、垃圾回收暂停 |
| 内存持续上涨不降 /长时间运行后越来越慢 | 内存泄漏：一些对象、DOM、回调、事件监听器、定时器等未被释放仍被引用         |

| 阶段            | 目标           | 使用工具                                       | 主要操作                             | 关键观察点                                 | 可能问题 /风险          |
| ------------- | ------------ | ------------------------------------------ | -------------------------------- | ------------------------------------- | ----------------- |
| **1️⃣ 确认问题**  | 复现卡顿或内存异常的场景 | 浏览器、用户日志、监控平台                              | 收集用户反馈、复现路径、操作步骤                 | 卡顿是否规律出现 / 内存是否持续上涨                   | 确认是性能问题而非业务阻塞     |
| **2️⃣ 初步检测**  | 判断是卡顿还是内存泄漏  | Chrome DevTools → **Performance Monitor**  | 观察 FPS、CPU、JS Heap、DOM Node 数量变化 | Heap、Node 数持续上升                       | 存在潜在泄漏或渲染过频       |
| **3️⃣ 拍快照分析** | 捕获堆内对象状态     | DevTools → **Memory → Heap Snapshot**      | 操作前 / 操作后各拍一份快照                  | Retained Size / Detached DOM Trees    | 未被释放的 DOM / 对象被引用 |
| **4️⃣ 对比快照**  | 找出泄漏源头       | Memory → **Comparison 视图**                 | 比较两份快照差异                         | 哪些对象 / 节点数量持续增加                       | 确认泄漏对象及增长趋势       |
| **5️⃣ 引用链分析** | 找出被谁持有       | Memory → **Retainers / Object References** | 追踪泄漏对象的引用路径                      | 闭包、全局变量、事件监听、定时器                      | 典型 JS 引用未释放       |
| **6️⃣ 修复验证**  | 移除引用 / 优化逻辑  | 代码修改 + 重测                                  | 清理事件、取消定时器、销毁监听、优化响应式            | 重新运行监控，确认 Heap 稳定                     | 内存回收正常、卡顿消失       |
| **7️⃣ 性能优化**  | 防止再次发生       | Performance 面板 + Lighthouse                | 分析长任务（>50ms）和渲染瓶颈                | Recalculate Style / Layout / Paint 频率 | 渲染层优化、减少阻塞 JS     |
| **8️⃣ 持续监控**  | 监控上线表现       | 性能监控 SDK（如 Sentry、WebVitals）               | 采集 FPS / Heap / 页面耗时数据           | 长时间运行后趋势                              | 提前发现潜在泄漏          |


### 11.定位白屏的常见原因
- 1.JavaScript 错误导致渲染中断
    - 症状：控制台报错，页面无法正常渲染。
    -  也可能接口返回异常数据或前端未兼容数据
- 2.关键资源加载失败
    - 症状：页面依赖的 CSS、JS、图片等资源未加载，导致页面样式或功能缺失。
- 3.页面渲染逻辑异常
     - 症状：页面结构正常，但内容未渲染。
     - 排查方法：
        - 检查 JavaScript 渲染逻辑，确认数据是否正确传递和处理。
        - 使用断点调试，逐步执行代码，查看变量值和执行流程。
- 4.浏览器兼容性问题
    - 症状：特定浏览器或版本下页面白屏。
    - 排查方法：
    - 使用 Can I Use 等工具，检查所用特性在目标浏览器中的支持情况。
    - 添加适当的 Polyfill，确保功能在旧版浏览器中可用

- 5. 网络环境或权限问题
    - 症状：在特定网络环境下（如公司内网）页面白屏。
    - 排查方法：
      - 检查 Content Security Policy（CSP）设置，确保没有阻止资源加载。
      - 确认没有被防火墙或安全软件拦截


- 6.白屏检测方案
    - 方案一：检测根节点是否渲染：通过检查根节点是否有内容，判断页面是否白屏。
    - 方案二：Mutation Observer 监听 DOM 变化：监听页面 DOM 变化，判断页面是否渲染。
    - 方案三：页面截图检测：对比页面截图与纯白图片，判断页面是否白屏。
    - 方案四：采样对比：在页面中采样多个点，判断是否有元素渲染。
      
    - 步骤：
      - 1.生成随机坐标点：在页面的宽度和高度范围内生成多个随机坐标点。
      - 2.检查坐标点处的元素：使用 document.elementFromPoint(x, y) 方法获取指定坐标点处的最上层元素。
      - 3.判断元素是否可见：检查获取到的元素是否存在且可见。
```
function isElementRendered(sampleCount = 10) {
    let visibleCount = 0;
    for (let i = 0; i < sampleCount; i++) {
        const x = Math.random() * window.innerWidth;
        const y = Math.random() * window.innerHeight;
        const element = document.elementFromPoint(x, y);

        if (element && element.offsetParent !== null) {
            visibleCount++;
        }
    }

    return visibleCount / sampleCount > 0.5; // 如果超过一半的采样点有可见元素，认为页面已渲染
}
```

### 12.浏览器事件循环，网络请求是宏任务吗？

是的，浏览器中的网络请求（如使用 fetch 或 XMLHttpRequest）属于宏任务（macrotask）。

调用栈（Call Stack）：执行同步代码。
    - 宏任务队列（Macrotask Queue）：存放宏任务的回调函数，例如 setTimeout、setInterval、DOM 事件、网络请求, UI 渲染等。
    - 微任务队列（Microtask Queue）：存放微任务的回调函数，例如 Promise.then、MutationObserver 等。

事件循环的执行顺序如下：
  - 执行调用栈中的同步代码。
  - 执行微任务队列中的所有任务，直到队列为空。
  - 从宏任务队列中取出一个任务执行。
  - 更新渲染（如果需要）。
  - 重复上述步骤

### 13. 页面的线程

| 线程名称                               | 职责                                      | 是否并行  | 示例说明                    |
| ---------------------------------- | --------------------------------------- | ----- | ----------------------- |
| **主线程（Main Thread）**               | 执行 JS、解析 HTML、计算样式、布局（layout）、绘制（paint） | ❌ 单线程 | JS 运行、DOM 操作、重排、重绘都在此执行 |
| **渲染线程 / 合成线程（Compositor Thread）** | 接收绘制指令，合成图层生成最终画面                       | ✅ 可并行 | 负责 GPU 合成层的渲染，保证流畅动画    |
| **光栅化线程（Raster Thread）**           | 把图层位图栅格化（交给 GPU 绘制）                     | ✅ 多线程 | 将合成层绘制成像素输出             |
| **网络线程（Network Thread）**           | 处理网络请求（HTTP、WebSocket、fetch）            | ✅ 独立  | 不受主线程阻塞，可同时并发多个请求       |
| **IO 线程（Browser Process）**         | 管理文件、Cookie、缓存、输入输出等                    | ✅ 独立  | 负责硬盘 / 系统层交互            |
| **定时器线程（Timer Thread）**            | 管理定时器（setTimeout / setInterval）         | ✅ 独立  | 到期后把回调放回主线程事件队列执行       |
| **Web Worker 线程**                  | 执行耗时 JS 计算（不操作 DOM）                     | ✅ 多线程 | 后台计算、大文件处理、AI、解析任务      |
| **Service Worker 线程**              | 拦截请求、缓存资源、推送等                           | ✅ 独立  | PWA 核心线程，生命周期独立于页面      |
| **GPU 线程（GPU Process）**            | 负责页面绘制、图像合成、3D 渲染                       | ✅ 独立  | 合成层最终交由 GPU 渲染输出        |


**JS、DOM、CSSOM、Layout、Paint、事件响应、垃圾回收（GC）都在主线程中执行。**

因此：当 JS 执行时间过长时（例如死循环 / 大量同步逻辑），会阻塞渲染 → 页面卡顿。当频繁修改 DOM、触发布局重排（Reflow）、重绘（Repaint）时，主线程负载增加 → FPS 下降。

✅ 这就是为什么浏览器看似“多线程”，但 JS 执行仍是单线程的根本原因：JS 与渲染共用主线程，为了避免线程竞争 DOM。          


### 14.ts type interface

- interface：适用于定义对象的结构，支持声明合并和扩展，便于面向对象编程。(推荐interface)

- type：适用于定义联合类型、交叉类型、元组等复杂类型，提供更强的表达能力

| 对比维度           | `interface`                 | `type`                  |
| -------------- | --------------------------- | ----------------------- |
| **语义**         | 描述“对象的结构”或“类的契约”            | 可定义任意类型（对象、联合、交叉、原始类型等） |
| **扩展方式**       | 通过 `extends` 继承             | 通过 `&`（交叉类型）组合          |
| **可合并性（声明合并）** | ✅ 可以多次定义同名接口，自动合并           | ❌ 不可重复声明同名 type         |
| **能定义的类型范围**   | 仅限对象、函数、类结构                 | ✅ 可定义联合类型、交叉类型、条件类型、元组等 |
| **实现关系**       | 类（class）可实现（`implements`）接口 | 类不能直接实现 `type`          |
| **复杂类型表达**     | 不支持直接定义联合、映射等复杂类型           | ✅ 支持高级类型语法（联合、条件、映射等）   |
| **兼容性**        | 更适合定义公共 API（库、类）            | 更灵活，适合组合与函数类型           |
| **编译后表现**      | 不会生成 JS 代码，仅用于类型检查          | 同样仅存在于类型层               |

| 场景           | 推荐类型        | 理由           |
| ------------ | ----------- | ------------ |
| 定义对象结构 / 类契约 | `interface` | 语义更清晰、支持声明合并 |
| 定义联合、交叉、映射类型 | `type`      | 表达力更强        |
| 在公共库、类型声明文件中 | `interface` | 更好扩展性        |
| 内部工具类型、组合类型  | `type`      | 更灵活简洁        |


### 15. ts 泛型
泛型（Generics） 是一种强大的特性，允许在定义函数、接口或类时不预先指定具体的类型，而在使用时再指定类型，从而实现类型的复用和灵活性。
泛型使得代码在处理不同类型的数据时，仍能保持类型安全。

泛型的优势
  - 类型安全：在编译时进行类型检查，避免运行时错误。
  - 代码复用：编写与特定类型无关的通用代码，提高代码的复用性。
  - 灵活性：根据实际需要指定类型，适应不同的数据类型和数据结构。

- 高级: 泛型约束, 默认泛型类型, 泛型与联合类型,
- 函数重载: 所谓函数重载就是同一个函数，根据传递的参数不同，会有不同的表现形式
- never是其它类型(null undefined)的子类型，代表不会出现的值


### 16. 从输入 URL 到页面渲染的完整流程, 说出自己的理解


### 17. web安全

[web安全](/knowledge/browser/webSecurity.md)
1. xss
2. csrf
3. 点击劫持
4. token
5. sql注入
6. 文件上传
7. 认证与权限
8. 加密算法
9. ddos
10. 爬虫
11. 服务器安全


### 18. 防爬虫
    1. 使用验证码
    2. 设置访问频率限制
    3. 使用 User-Agent 检测
    4. 动态内容加载
    5. IP 黑名单
    6. 使用 Token 验证


### 19. 缓存

浏览器 / 缓存层（代理、CDN）会将服务器响应保存起来，当下次请求相同资源时可直接从缓存中返回，而不必到服务器取。这样可以减少网络延迟和服务器负荷。


- 新鲜度判断（Freshness） vs 验证（Validation）

  - 新鲜（Fresh）：在有效期内，缓存可直接返回给客户端。
  - 陈旧（Stale）：资源已过有效期，需要验证是否更新（例如通过 ETag / Last-Modified）或强制重新下载。

  验证机制：客户端发送条件请求（If-None-Match, If-Modified-Since），服务器如资源未变返回 304 Not Modified 让客户端继续用缓存。

- 缓存作用域

  - 私有缓存（Private Cache）：如浏览器本地缓存，仅对单个用户可见。

  - 共享缓存（Shared Cache / Proxy / CDN）：CDN / 代理服务器等中间缓存，可被多个用户共享。对于涉及用户隐私或基于 cookie 的响应，要限制这类缓存

  
- no-cache ≠ “不缓存” —— 它允许缓存储存，但使用前必须验证。
- no-store 是“不储存”的真正指令，但不会清除已经缓存的旧数据。
- Expires 比较老旧，现代多数场景用 cache-control 的 max-age。


---
zx

### 20. 组件 key 改变和 props 改变有什么区别

| 变化类型                 | 对组件实例的影响                      | 生命周期                                                                                             | state 是否保留        | 主要使用场景                              |
| ------------------------ | ------------------------------------- | ---------------------------------------------------------------------------------------------------- | --------------------- | ----------------------------------------- |
| **key 改变**             | **卸载旧组件 → 挂载新组件**（实例被销毁并重建） | 先触发旧组件的 `componentWillUnmount` / `useEffect` 的 cleanup，再触发新组件的 `constructor` → `render` → `useEffect` | **不会保留**（因为是全新实例） | 当需要强制重新初始化组件（比如重置表单、重新加载数据） |
| **props 改变（key 不变）** | **复用原组件实例**                     | 触发 `shouldComponentUpdate`（如有）/ `render` / 更新后的 `useEffect`                                  | **会保留**（除非代码主动重置） | 正常的属性更新：列表内容变化、UI 随数据更新 |

#### 核心思想

- key 是身份标签：一变就换人（卸载 + 重建）。
- props 是输入数据：只变数据，不换人（实例保留）。

##### 一句话总结

- 需要强制重新初始化组件（如清空表单、重新加载动画）时，用 key；
- 仅需更新组件展示的数据时，修改 props 即可。

#### 深入: props 引用没变 vs 引用改变

- props 引用没变
  - 父组件重新渲染，但 data 对象引用没变。
  - React 认为 props 没有变化，子组件如果是 React.memo，不会重新渲染。
  - state 保留，useEffect 依赖不会触发（如果依赖该 prop）。

- props 引用改变
  - 每次父组件渲染都会生成新对象。
  - 即使内容相同，引用改变 → React 认为 props 改变。
  - React.memo 会触发重新渲染。
  - useEffect 依赖该 prop 也会重新执行。

### 26. react form 里面非受控组件 如何对应上值的改变

| 方式    | 数据存放        | 值变化的响应                       | 外部值改变时                             |
| ----- | ----------- | ---------------------------- | ---------------------------------- |
| 受控组件  | React state | `onChange` → setState → 重新渲染 | 直接受 state 驱动，值自动更新                 |
| 非受控组件 | DOM 元素内部    | 通过 `ref` 读取                  | 需要用 `ref.current.value = ...` 手动更新 |

总结

- 非受控组件默认不会随着 props 变化而更新。
- 如果想同步外部变化：
  - 用 ref + useEffect 直接赋值给 DOM。
  - 或者通过改变 key 来强制重建。
  - 如果频繁需要同步外部数据，最好改用 受控组件

### 27. antd form是如何控制内部组件的value的

基于 v4+ 分析

##### 总体设计思路

Antd Form 并不是简单地把 `<Form.Item>` 里的 `<Input>` 当作受控组件包一层，而是自己实现了一套 “表单状态管理 + 受控注入” 机制。
核心：

- Form 内部维护一个 FormStore（字段名 → 值 的状态）。
- 每个 `<Form.Item>` 都会通过 Context 注册到 FormStore。
- FormStore 变化后，通过 Context + forceUpdate 通知对应 Form.Item 重新渲染。
- Form.Item 渲染时，会把 value 和 onChange 注入到子组件，实现受控。

典型用法:

```jsx
<Form form={form} initialValues={{ username: 'Tom' }}>
  <Form.Item name="username">
    <Input />
  </Form.Item>
</Form>
```

对应关系：

```js
<Form>           —— 维护 FormStore（字段状态）
   │
   └─<FormContext.Provider>  —— 提供 Store 和订阅方法
        │
        └─<Form.Item name="username"> —— 注册字段
              │
              └─ cloneElement(<Input>, {value, onChange})
```

1. 流程详解

- 1. FormStore
  - Form 创建时，内部有一个 store = {} 保存所有字段的值。
  - 提供方法：
    - getFieldValue(name) / getFieldsValue()
    - setFieldValue(name, value)
    - subscribe(callback) 订阅字段变化
    - Form.useForm() 返回的就是对这个 Store 的引用

- 2.Form.Item 注册字段
  - `<Form.Item name="username">` 渲染时，会通过 Context 把 name 注册到 Store。
  - 它会订阅对应字段，当该字段值变化时触发 forceUpdate() 来重新渲染该 Item。

- 3. 克隆子节点注入受控属性
  - 渲染时，Form.Item 会用 React.cloneElement 给子组件（如 `<Input />`）注入：

  ```js
    {
    value: store[name],
    onChange: (e) => {
      const newValue = e && e.target ? e.target.value : e;
      store.setFieldValue(name, newValue);
    }
  }
  ```

  - 这样，子组件（比如 antd Input）变成了 FormStore 受控的受控组件。
  - ***自定义组件支持接收value,onChange属性即可***
  - 如果原本子组件自己也传了 value 和 onChange，Form.Item 会合并，但以 Form 为主。
  - 因此，用 antd Form 时，不需要再手动写 value 和 onChange。

- 4. 触发更新
  - 用户在 Input 中输入：
    - 1. Input 调用 onChange → store.setFieldValue(name, newValue)
    - 2. Store 更新值后通知所有订阅者（相关 Form.Item）
    - 3. 对应 Form.Item forceUpdate()，重新渲染，给 Input 新的 value
    - 从而保证 Input 的显示值始终与 FormStore 中的值同步。
- 5.特殊场景
  - initialValues：初始渲染时写入 Store，Form.Item 会读取。
  - setFieldsValue / resetFields：调用这些 API 时直接改 Store → 通知订阅 → 触发 Form.Item 更新。
  - dependencies：依赖项变化时重新渲染 Form.Item。
  - shouldUpdate：控制 Form.Item 是否重新渲染。

受控与非受控的对比

| 特性   | 普通非受控表单              | antd Form 内部机制                     |
| ---- | -------------------- | ---------------------------------- |
| 值存放  | DOM（通过 defaultValue） | FormStore（JS 对象）                   |
| 组件更新 | 用户输入不会触发 React 重新渲染  | 每次输入都更新 Store 并触发 Form.Item 重渲染    |
| 外部控制 | 需要 ref 手动更新 DOM      | 用 `form.setFieldsValue()` 即可更新所有字段 |

👉 可以认为：
  **Antd Form 把所有字段都变成了受控组件，并用集中式 Store 管理。**

**总结**

- 核心机制：**集中式 FormStore 管理所有字段。**
- 关键手段：Form.Item 通过 Context 注册并订阅字段变化。
- 数据流：
  - 外部调用 setFieldsValue 或用户输入 → 更新 Store → 通知 Form.Item → 渲染子组件 → 子组件显示最新值。
- 因此，antd Form 里的 Input、Select、Checkbox 等都是受控的，值完全由 FormStore 决定。
