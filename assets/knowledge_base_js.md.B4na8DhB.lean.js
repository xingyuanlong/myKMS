import{_ as a,I as s,c as r,o as d,j as l,J as e,ah as o,a as u,w as i}from"./chunks/framework.fGi7qB65.js";const c=JSON.parse('{"title":"JS 知识","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/base/js.md","filePath":"knowledge/base/js.md"}'),p={name:"knowledge/base/js.md"};function m(g,n,b,h,f,S){const t=s("Collapse");return d(),r("div",null,[n[20]||(n[20]=l("h1",{id:"js-知识",tabindex:"-1"},[u("JS 知识 "),l("a",{class:"header-anchor",href:"#js-知识","aria-label":"Permalink to “JS 知识”"},"​")],-1)),n[21]||(n[21]=l("h3",{id:"_1-js-闭包-如何理解",tabindex:"-1"},[u("1.JS 闭包，如何理解 "),l("a",{class:"header-anchor",href:"#_1-js-闭包-如何理解","aria-label":"Permalink to “1.JS 闭包，如何理解”"},"​")],-1)),e(t,null,{default:i(()=>[...n[0]||(n[0]=[l("p",null,[u("什么是闭包？ "),l("strong",null,"闭包是指一个函数能够记住并访问其词法作用域中的变量，即使该函数在其词法作用域之外执行。")],-1),l("p",null,[u("简单来说："),l("strong",null,"当一个函数内部定义了另一个函数，并且内部函数引用了外部函数的变量，就创建了一个闭包。")],-1),l("p",null,"闭包的实际应用",-1),l("ul",null,[l("li",null,"创建私有变量"),l("li",null,"在循环中使用闭包(解决引用问题)"),l("li",null,"模块模式")],-1),l("p",null,"闭包的工作原理 JavaScript 的作用域链机制使得闭包成为可能：",-1),l("ul",null,[l("li",null,"每个函数在创建时都会保存对其词法环境的引用"),l("li",null,"当函数执行时，它会沿着作用域链查找变量"),l("li",null,"即使外部函数执行完毕，只要内部函数仍然存在，外部函数的变量就不会被垃圾回收")],-1),l("p",null,"闭包风险",-1),l("ul",null,[l("li",null,"内存泄漏风险 ( 在不需要时手动解除引用)"),l("li",null,"性能考虑 过度使用闭包可能会影响性能，因为：需要维护额外的作用域链;变量查找时间可能增加;")],-1)])]),_:1}),n[22]||(n[22]=l("h3",{id:"_2-描述-event-loop-运行机制",tabindex:"-1"},[u("2.描述 Event Loop 运行机制 "),l("a",{class:"header-anchor",href:"#_2-描述-event-loop-运行机制","aria-label":"Permalink to “2.描述 Event Loop 运行机制”"},"​")],-1)),e(t,null,{default:i(()=>[...n[1]||(n[1]=[l("ol",null,[l("li",null,"背景 JavaScript 是 单线程 的：同一时刻只能执行一个任务。但浏览器/Node 需要同时处理用户输入、网络请求、定时器、渲染等。 👉 为了解决“同时处理多任务”的需求，JS 引入了 事件循环（Event Loop） 机制。")],-1),l("p",null,"Event Loop（事件循环）是 JavaScript 处理 异步操作 的核心机制。它允许 JavaScript 以 非阻塞 的方式执行代码，即使遇到 I/O 操作（如网络请求、定时器），也不会影响主线程继续执行其他任务。",-1),l("p",null,"三个核心关键概念",-1),l("ul",null,[l("li",null,"Call Stack（调用栈） JS 引擎执行代码时，按照函数调用的嵌套关系入栈/出栈。同步代码按顺序直接在栈中运行。"),l("li",null,"Task Queue（任务队列） 异步任务完成后，将回调放入队列，等待主线程空闲时取出执行。"),l("li",null,"Event Loop（事件循环） 事件循环不断检查调用栈是否为空，如果为空，就从队列取出一个任务放入栈中执行。这个过程周而复始。")],-1),l("p",null,"JS 中的任务按优先级分为 宏任务（Macrotask） 和 微任务（Microtask）。",-1),l("ul",null,[l("li",null,[l("p",null,"宏任务（Macrotask）"),l("ul",null,[l("li",null,"整体脚本 script"),l("li",null,"setTimeout / setInterval"),l("li",null,"setImmediate（Node）"),l("li",null,"I/O 回调"),l("li",null,"UI 渲染"),l("li",null,"JS 中用户输入（如 click、input、keydown 等 DOM 事件的回调）")])]),l("li",null,[l("p",null,"微任务（Microtask）"),l("ul",null,[l("li",null,"Promise.then / catch / finally"),l("li",null,"queueMicrotask"),l("li",null,"MutationObserver（浏览器）"),l("li",null,"process.nextTick（Node）")])])],-1),l("p",null,"规则： 每轮事件循环：",-1),l("ul",null,[l("li",null,"执行一个宏任务"),l("li",null,"执行所有微任务（直到清空微任务队列）"),l("li",null,"渲染（浏览器）"),l("li",null,"开始下一轮循环")],-1),l("p",null,[l("strong",null,"同步先执行，异步分队列；先宏后微，再渲染。")],-1),l("p",null,"Node.js：",-1),l("ul",null,[l("li",null,[l("strong",null,"process.nextTick 优先级高于 Promise 微任务")])],-1)])]),_:1}),n[23]||(n[23]=l("h3",{id:"_3-网页多标签页之间如何通讯-和-iframe-如何通讯",tabindex:"-1"},[u("3.网页多标签页之间如何通讯？和 iframe 如何通讯？ "),l("a",{class:"header-anchor",href:"#_3-网页多标签页之间如何通讯-和-iframe-如何通讯","aria-label":"Permalink to “3.网页多标签页之间如何通讯？和 iframe 如何通讯？”"},"​")],-1)),e(t,null,{default:i(()=>[...n[2]||(n[2]=[l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"特性"),l("th",null,[l("code",null,"BroadcastChannel")]),l("th",null,[l("code",null,"localStorage"),u(" + "),l("code",null,"storage"),u(" 事件")]),l("th",null,[l("code",null,"postMessage"),u(" + iframe / worker")])])]),l("tbody",null,[l("tr",null,[l("td",null,"是否需要刷新"),l("td",null,"否"),l("td",null,"否"),l("td",null,"否")]),l("tr",null,[l("td",null,"是否支持多 Tab"),l("td",null,"✅"),l("td",null,"✅"),l("td",null,"部分（需要 iframe/worker）")]),l("tr",null,[l("td",null,"是否易用"),l("td",null,"✅（直接发送消息）"),l("td",null,"中等（需要 JSON 序列化）"),l("td",null,"较复杂（需建立通道）")]),l("tr",null,[l("td",null,"是否跨域"),l("td",null,"❌（只能同源）"),l("td",null,"❌"),l("td",null,"可跨域（需正确设置 targetOrigin）")]),l("tr",null,[l("td",null,"性能"),l("td",null,"较好"),l("td",null,"一般（依赖 storage 事件）"),l("td",null,"较好")])])],-1)])]),_:1}),n[24]||(n[24]=l("h3",{id:"_4-前端常见的设计模式有哪些-以及应用场景",tabindex:"-1"},[u("4.前端常见的设计模式有哪些？以及应用场景 "),l("a",{class:"header-anchor",href:"#_4-前端常见的设计模式有哪些-以及应用场景","aria-label":"Permalink to “4.前端常见的设计模式有哪些？以及应用场景”"},"​")],-1)),e(t,null,{default:i(()=>[...n[3]||(n[3]=[l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"模式类型"),l("th",null,"设计模式"),l("th",null,"定义 / 核心思想"),l("th",null,"前端典型应用场景")])]),l("tbody",null,[l("tr",null,[l("td",null,[l("strong",null,"创建型")]),l("td",null,"工厂模式（Factory）"),l("td",null,"用一个工厂方法创建对象，解耦对象创建和使用"),l("td",null,"组件库动态创建组件（ButtonFactory）、Axios 不同配置实例")]),l("tr",null,[l("td"),l("td",null,"单例模式（Singleton）"),l("td",null,"保证类只有一个实例，并提供全局访问"),l("td",null,"全局 Store（Redux/Pinia）、全局弹窗/通知、全局缓存")]),l("tr",null,[l("td",null,[l("strong",null,"结构型")]),l("td",null,"装饰器模式（Decorator）"),l("td",null,"不改变对象本身，动态给对象添加功能"),l("td",null,"React 高阶组件（HOC）、TS 装饰器、函数增强（日志、权限）")]),l("tr",null,[l("td"),l("td",null,"代理模式（Proxy）"),l("td",null,"通过代理对象控制对目标对象访问"),l("td",null,"Vue3 响应式、请求缓存、防抖/节流、懒加载")]),l("tr",null,[l("td"),l("td",null,"适配器模式（Adapter）"),l("td",null,"将不兼容接口转换为可用接口"),l("td",null,"封装第三方 SDK、统一后端接口格式、浏览器 API 兼容")]),l("tr",null,[l("td",null,[l("strong",null,"行为型")]),l("td",null,"观察者模式（Observer）"),l("td",null,"对象状态改变时通知所有订阅者"),l("td",null,"DOM 事件监听、Vue2 响应式依赖收集")]),l("tr",null,[l("td"),l("td",null,"发布订阅模式（Pub/Sub）"),l("td",null,"将事件和回调解耦，发布者触发事件，订阅者响应事件"),l("td",null,"Redux / Vuex 的状态更新订阅、EventBus、跨组件通信/pinia")]),l("tr",null,[l("td"),l("td",null,"策略模式（Strategy）"),l("td",null,"封装一系列算法，可互换"),l("td",null,"表单验证策略、支付方式选择、动画策略")]),l("tr",null,[l("td"),l("td",null,"命令模式（Command）"),l("td",null,"将请求封装为对象，便于参数化和管理"),l("td",null,"富文本编辑器命令、Undo/Redo、Canvas 绘图命令")]),l("tr",null,[l("td",null,[l("strong",null,"前端特有")]),l("td",null,"组合模式（Composition）"),l("td",null,"通过组合而非继承实现功能复用"),l("td",null,"React children、Vue 插槽（Slot）、Hooks 组合逻辑")]),l("tr",null,[l("td"),l("td",null,"MVVM / 单向数据流"),l("td",null,"数据驱动视图，状态单向流动"),l("td",null,"Vue / Angular MVVM、React + Redux")])])],-1)])]),_:1}),n[25]||(n[25]=l("h3",{id:"_5-浏览器从输入-url-到显示网页的全过程",tabindex:"-1"},[u("5.浏览器从输入 url 到显示网页的全过程 "),l("a",{class:"header-anchor",href:"#_5-浏览器从输入-url-到显示网页的全过程","aria-label":"Permalink to “5.浏览器从输入 url 到显示网页的全过程”"},"​")],-1)),e(t),n[26]||(n[26]=l("h3",{id:"_6-从-0-搭建一个前端项目-需要考虑哪些方面",tabindex:"-1"},[u("6.从 0 搭建一个前端项目，需要考虑哪些方面 "),l("a",{class:"header-anchor",href:"#_6-从-0-搭建一个前端项目-需要考虑哪些方面","aria-label":"Permalink to “6.从 0 搭建一个前端项目，需要考虑哪些方面”"},"​")],-1)),e(t,null,{default:i(()=>[...n[4]||(n[4]=[l("p",null,"主要是框架/库, 工具链 和cicd 选择",-1),l("ul",null,[l("li",null,"技术选型：框架、状态管理、工具链、UI 组件库"),l("li",null,"项目架构：目录结构、模块化、路由、状态管理、接口管理"),l("li",null,"开发与运维：构建优化、测试、性能、安全、CI/CD")],-1)])]),_:1}),n[27]||(n[27]=l("h3",{id:"_7-ajax-并发请求控制",tabindex:"-1"},[u("7. ajax 并发请求控制 "),l("a",{class:"header-anchor",href:"#_7-ajax-并发请求控制","aria-label":"Permalink to “7.  ajax 并发请求控制”"},"​")],-1)),n[28]||(n[28]=l("p",null,"现有 30 个异步请求需要发送，但由于某些原因，我们必须将同一时刻并发请求数量控制在 5 个以内",-1)),e(t,null,{default:i(()=>[...n[5]||(n[5]=[l("div",{class:"language-"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"}),l("pre",{class:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabindex:"0",dir:"ltr"},[l("code",null,[l("span",{class:"line"},[l("span",null,"async function batchRequestAllSettled(tasks, batchSize = 5) {")]),u(`
`),l("span",{class:"line"},[l("span",null,"  const results = []")]),u(`
`),l("span",{class:"line"},[l("span")]),u(`
`),l("span",{class:"line"},[l("span",null,"  for (let i = 0; i < tasks.length; i += batchSize) {")]),u(`
`),l("span",{class:"line"},[l("span",null,"    const batch = tasks.slice(i, i + batchSize).map(fn => fn())")]),u(`
`),l("span",{class:"line"},[l("span",null,"    // 等待当前批次所有请求完成（成功或失败）")]),u(`
`),l("span",{class:"line"},[l("span",null,"    const batchResults = await Promise.allSettled(batch)")]),u(`
`),l("span",{class:"line"},[l("span",null,"    results.push(...batchResults)")]),u(`
`),l("span",{class:"line"},[l("span",null,"  }")]),u(`
`),l("span",{class:"line"},[l("span")]),u(`
`),l("span",{class:"line"},[l("span",null,"  return results")]),u(`
`),l("span",{class:"line"},[l("span",null,"}")]),u(`
`),l("span",{class:"line"},[l("span")]),u(`
`),l("span",{class:"line"},[l("span",null,"// 使用示例")]),u(`
`),l("span",{class:"line"},[l("span",null,"const urls = Array.from({ length: 30 }, (_, i) => `https://api.example.com/data/${i}`)")]),u(`
`),l("span",{class:"line"},[l("span",null,"const tasks = urls.map(url => () => fetch(url).then(res => res.json()))")]),u(`
`),l("span",{class:"line"},[l("span")]),u(`
`),l("span",{class:"line"},[l("span",null,"batchRequestAllSettled(tasks, 5).then(results => {")]),u(`
`),l("span",{class:"line"},[l("span",null,"  results.forEach((res, idx) => {")]),u(`
`),l("span",{class:"line"},[l("span",null,"    if (res.status === 'fulfilled') console.log(`任务 ${idx} 成功`, res.value)")]),u(`
`),l("span",{class:"line"},[l("span",null,"    else console.log(`任务 ${idx} 失败`, res.reason)")]),u(`
`),l("span",{class:"line"},[l("span",null,"  })")]),u(`
`),l("span",{class:"line"},[l("span",null,"})")])])])],-1)])]),_:1}),n[29]||(n[29]=l("h3",{id:"_8-线上出了严重-bug-你该如何解决",tabindex:"-1"},[u("8. 线上出了严重 bug 你该如何解决？ "),l("a",{class:"header-anchor",href:"#_8-线上出了严重-bug-你该如何解决","aria-label":"Permalink to “8. 线上出了严重 bug 你该如何解决？”"},"​")],-1)),e(t,null,{default:i(()=>[...n[6]||(n[6]=[l("p",null,[l("strong",null,"先止损 → 再排查 → 然后修复 → 最后复盘防再发")],-1),l("ul",null,[l("li",null,[u("第一要务: "),l("strong",null,"回滚，及时止损")]),l("li",null,"通知项目组成员，看谁最近有过上线—— 线上 bug 一般是最近一次上线导致的"),l("li",null,"在本地或测试环境浮现 bug，查找原因"),l("li",null,"修复，测试，重新上线"),l("li",null,[u("开"),l("strong",null,"复盘会议"),u("，以后如何规避此类问题 —— 总结经验教训")])],-1)])]),_:1}),n[30]||(n[30]=l("h3",{id:"_9-你如何保障代码质量",tabindex:"-1"},[u("9. 你如何保障代码质量？ "),l("a",{class:"header-anchor",href:"#_9-你如何保障代码质量","aria-label":"Permalink to “9. 你如何保障代码质量？”"},"​")],-1)),e(t,null,{default:i(()=>[...n[7]||(n[7]=[l("ul",null,[l("li",null,"配置统一的 eslint 和 prettier 规则，规范代码格式"),l("li",null,"尽量组织 code review"),l("li",null,"使用 Sentry 等平台进行线上错误报警，并及时修复问题")],-1)])]),_:1}),n[31]||(n[31]=l("h3",{id:"_10-esm-与-commonjs-的循环引用",tabindex:"-1"},[u("10. esm 与 CommonJS 的循环引用 "),l("a",{class:"header-anchor",href:"#_10-esm-与-commonjs-的循环引用","aria-label":"Permalink to “10. esm 与 CommonJS 的循环引用”"},"​")],-1)),e(t,null,{default:i(()=>[...n[8]||(n[8]=[l("ul",null,[l("li",null,"CommonJS 模块规范在遇到循环引用时,Node 会返回当前已执行部分的 exports 对象.(Node 通过 require.cache 缓存机制避免了无限递归)"),l("li",null,"ES Module（ESM）在循环引用时有“实时绑定（live binding）”机制, (静态分析 esm编译阶段就确定依赖关系，不是在运行时动态执行; 单例缓存：同一个模块只会被执行一次，并缓存结果; 实时绑定 (live binding)：import 的变量不是值拷贝，而是一个引用，对应 export 的内存位置。所以即使 export 后续被修改，import 端也能拿到最新的值。)")],-1)])]),_:1}),n[32]||(n[32]=l("h3",{id:"_11-esm-中-import-会发生什么",tabindex:"-1"},[u("11. esm 中 import 会发生什么? "),l("a",{class:"header-anchor",href:"#_11-esm-中-import-会发生什么","aria-label":"Permalink to “11. esm 中 import 会发生什么?”"},"​")],-1)),e(t,null,{default:i(()=>[...n[9]||(n[9]=[l("p",null,"ES Module (ESM) 的 import 是编译期就确定依赖关系;ESM 默认是 严格模式，并且是 异步加载",-1),l("p",null,[l("strong",null,"解析阶段（Parsing）=> 加载阶段 => 实例化阶段 => 执行阶段 => 缓存")],-1),l("ul",null,[l("li",null,"为每个模块创建 模块环境记录（Module Environment Record），里面存放变量绑定, 实时绑定:如果 export 的值后来被修改，"),l("li",null,"import 端也能感知。ESM 的缓存机制是基于 URL/路径唯一性，并且在 异步上下文中生效。"),l("li",null,"esm缓存生效场景: 同一个模块被多次 import; 循环依赖(缓存的“半成品”也会存起来，这样可以避免死循环);动态 import 多次;")],-1)])]),_:1}),n[33]||(n[33]=l("h3",{id:"_12-在-js-代码中避免内存泄漏的方法",tabindex:"-1"},[u("12. 在 JS 代码中避免内存泄漏的方法? "),l("a",{class:"header-anchor",href:"#_12-在-js-代码中避免内存泄漏的方法","aria-label":"Permalink to “12. 在 JS 代码中避免内存泄漏的方法?”"},"​")],-1)),e(t,null,{default:i(()=>[...n[10]||(n[10]=[l("ol",null,[l("li",null,"释放不再需要的引用(把对象置 null 或者移除属性，就能让 GC 正常回收。)"),l("li",null,"避免全局变量"),l("li",null,"小心闭包(闭包会一直保持引用,导致无法回收对象)"),l("li",null,"定时器 / 事件监听要清理"),l("li",null,"使用 WeakMap / WeakSet 存放临时对象"),l("li",null,"避免 JSON.stringify 大对象"),l("li",null,"复用对象 / 数组"),l("li",null,"按需加载数据"),l("li",null,"及时释放 DOM 引用")],-1)])]),_:1}),n[34]||(n[34]=l("h3",{id:"_13-es6-继承在前-实例在后",tabindex:"-1"},[u("13. es6 “继承在前，实例在后”? "),l("a",{class:"header-anchor",href:"#_13-es6-继承在前-实例在后","aria-label":"Permalink to “13. es6 “继承在前，实例在后”?”"},"​")],-1)),e(t,null,{default:i(()=>[...n[11]||(n[11]=[l("ul",null,[l("li",null,"new 子类发生什么: 创建子类实例对象 => 设置原型 => 父类构造函数执行 => 调用子类构造函数 => 子类构造函数继续执行"),l("li",null,"先创建空实例 → 调用子类 constructor → super() 调用父类 constructor → 父类属性挂载 → 回到子类挂载属性 → 实例返回。"),l("li",null,"ES6 的 class extends 就是对寄生组合继承的语法封装")],-1)])]),_:1}),n[35]||(n[35]=l("h3",{id:"_14-script-type-module-是什么效果",tabindex:"-1"},[u('14. script type="module" 是什么效果? '),l("a",{class:"header-anchor",href:"#_14-script-type-module-是什么效果","aria-label":'Permalink to “14. script type="module" 是什么效果?”'},"​")],-1)),e(t,null,{default:i(()=>[...n[12]||(n[12]=[l("ul",null,[l("li",null,[l("code",null,'<script type="module">'),u(" 会 异步下载和解析，等 HTML 解析完成后执行，按依赖顺序执行模块代码，类似加了 defer 的普通脚本，但支持模块化特性。")]),l("li",null,[l("code",null,'<script type="module" async>'),u(" 异步,下载完成立即执行,不保证顺序 (适合独立模块，不依赖 DOM，也不依赖其他模块执行顺序，比如统计脚本或广告脚本。)")])],-1)])]),_:1}),n[36]||(n[36]=l("h3",{id:"_15-文件的软链接与硬链接",tabindex:"-1"},[u("15. 文件的软链接与硬链接? "),l("a",{class:"header-anchor",href:"#_15-文件的软链接与硬链接","aria-label":"Permalink to “15. 文件的软链接与硬链接?”"},"​")],-1)),e(t,null,{default:i(()=>[...n[13]||(n[13]=[l("ul",null,[l("li",null,"硬链接 = 同一份文件的不同名字, 删除源文件,不影响数据，数据依然可访问,"),l("li",null,"软链接 = 指向另一个文件路径的快捷方式, 删除源文件,软链接链接失效")],-1),l("p",null,"文件系统中使用一个叫做 inode（索引节点） 的结构来记录文件的真实内容。",-1),l("ul",null,[l("li",null,"硬链接: 多个文件名共享同一个 inode。"),l("li",null,"软链接: 一个独立的文件，里面保存着目标文件的路径。(更像是 Windows 的快捷方式)")],-1)])]),_:1}),n[37]||(n[37]=l("h3",{id:"_16-js-原型链-作用是什么",tabindex:"-1"},[u("16.js 原型链, 作用是什么? "),l("a",{class:"header-anchor",href:"#_16-js-原型链-作用是什么","aria-label":"Permalink to “16.js 原型链, 作用是什么?”"},"​")],-1)),e(t,null,{default:i(()=>[...n[14]||(n[14]=[l("ul",null,[l("li",null,[l("p",null,[u("原型链？ 在 JavaScript 里，每个对象都有一个隐藏属性 [[Prototype]]（通常通过 "),l("strong",null,"proto"),u(" 访问）。当我们访问一个对象的属性/方法时，如果对象本身没有，JS 引擎就会顺着 [[Prototype]] 向上找。这条由 [[Prototype]] 串起来的链路，就叫 原型链。")])]),l("li",null,[l("p",null,"原型链的作用"),l("ul",null,[l("li",null,[u("核心作用就是实现继承和共享属性/方法。 "),l("ul",null,[l("li",null,"继承机制：子对象可以通过原型链继承父对象的方法/属性。"),l("li",null,"方法复用：所有实例共享同一个方法定义，避免每次 new 都复制一份。"),l("li",null,"动态扩展：可以在运行时给 prototype 添加方法，所有实例立刻可用")])])])])],-1),l("p",null,"原型链是 JS 实现继承的机制，通过逐层查找 [[Prototype]] 来实现属性/方法共享和复用。",-1)])]),_:1}),n[38]||(n[38]=l("h3",{id:"_17-web-components",tabindex:"-1"},[u("17. web components "),l("a",{class:"header-anchor",href:"#_17-web-components","aria-label":"Permalink to “17. web components”"},"​")],-1)),e(t,null,{default:i(()=>[...n[15]||(n[15]=[l("p",null,"Web Components 是一套 浏览器原生的前端组件技术标准，让开发者能创建可复用、封装、独立于框架的组件",-1),l("ul",null,[l("li",null,[l("p",null,"Custom Elements;Shadow DOM;HTML Templates;")]),l("li",null,[l("p",null,"继承 HTMLElement , 使用 customElements")]),l("li",null,[l("p",null,"生命周期"),l("ul",null,[l("li",null,"constructor → 元素实例化"),l("li",null,"connectedCallback → 添加到 DOM"),l("li",null,"disconnectedCallback → 从 DOM 移除"),l("li",null,"attributeChangedCallback → 被观察属性变化")])]),l("li",null,[l("p",null,"属性"),l("ul",null,[l("li",null,"HTML 属性与 JS 属性双向绑定"),l("li",null,"使用 observedAttributes + attributeChangedCallback"),l("li",null,"可以通过 getter/setter 做同步映射")])]),l("li",null,[l("p",null,"自定义事件"),l("ul",null,[l("li",null,"使用 dispatchEvent(new CustomEvent(...))"),l("li",null,"穿透 Shadow DOM → composed: true"),l("li",null,"冒泡 → bubbles: true"),l("li",null,"建议只传小对象或数据引用")])]),l("li",null,[l("p",null,"插槽"),l("ul",null,[l("li",null,"提供组件可插入自定义内容的能力"),l("li",null,[l("code",null,"<slot>"),u(' 默认内容，外部可用 slot="name" 覆盖')])])]),l("li",null,[l("p",null,"属性/事件/插槽封装模式（常用技巧）"),l("ul",null,[l("li",null,"formatProps → 统一解析属性"),l("li",null,"emit → 封装 dispatchEvent，像 Vue emit"),l("li",null,"BaseComponent → 封装生命周期、属性监听、事件分发、props 解析")])]),l("li",null,[l("p",null,"优点:"),l("ul",null,[l("li",null,"原生支持;真正的封装;可复用性;互操作性;长期可用性")])]),l("li",null,[l("p",null,"缺点:"),l("ul",null,[l("li",null,"生态和工具链;样式主题化困难;基础功能;SEO;")])]),l("li",null,[l("p",null,"优化:"),l("ul",null,[l("li",null,"使用 requestAnimationFrame 节流渲染"),l("li",null,"维护虚拟 DOM / shadow DOM patch"),l("li",null,"避免深度 DOM 查询，每次 render 只更新变化部分")])])],-1)])]),_:1}),n[39]||(n[39]=l("h3",{id:"_18-ts-类型推断原理",tabindex:"-1"},[u("18. ts 类型推断原理？ "),l("a",{class:"header-anchor",href:"#_18-ts-类型推断原理","aria-label":"Permalink to “18. ts 类型推断原理？”"},"​")],-1)),e(t,null,{default:i(()=>[...n[16]||(n[16]=[l("p",null,"类型推断（Type Inference）指的是 —— 当开发者没有显式标注类型时，TypeScript 编译器自动根据上下文推导变量、参数、函数返回值的类型",-1),l("p",null,"TypeScript 在编译阶段会：",-1),l("ul",null,[l("li",null,[l("p",null,"扫描变量声明、赋值、函数签名、返回值；")]),l("li",null,[l("p",null,"根据上下文建立一个“类型约束图”（constraint graph）；")]),l("li",null,[l("p",null,[u("利用"),l("strong",null,"控制流分析（Control Flow Analysis）"),u("更新类型的可变性；")])]),l("li",null,[l("p",null,"最终在不声明类型的情况下，自动推导出最合理的类型")]),l("li",null,[l("p",null,"当函数使用泛型时，TS 会从调用时的实参反向推导类型参数：")]),l("li",null,[l("p",null,"TS 类型系统支持从上下文反推表达式的类型，即“类型从左到右流动”：")]),l("li",null,[l("p",null,"TS 会在 if、switch、typeof、in、instanceof 等控制流语句中自动缩小类型：")])],-1),l("p",null,"ts 适合:",-1),l("ul",null,[l("li",null,"大型多人协作项目"),l("li",null,"SDK、组件库、Hooks 封装"),l("li",null,"安全重构 / 版本演进"),l("li",null,"智能提示和自文档化")],-1)])]),_:1}),n[40]||(n[40]=l("h3",{id:"_19-canvas-与-svg",tabindex:"-1"},[u("19. Canvas 与 SVG "),l("a",{class:"header-anchor",href:"#_19-canvas-与-svg","aria-label":"Permalink to “19. Canvas 与 SVG”"},"​")],-1)),e(t,null,{default:i(()=>[...n[17]||(n[17]=[l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"特性"),l("th",null,"Canvas"),l("th",null,"SVG")])]),l("tbody",null,[l("tr",null,[l("td",null,[l("strong",null,"渲染方式")]),l("td",null,"位图（Bitmap），直接绘制到画布像素上"),l("td",null,"矢量图形（Vector），每个元素是 DOM 节点")]),l("tr",null,[l("td",null,[l("strong",null,"核心原理")]),l("td",null,"JS 调用 Canvas API 绘制，结果写入画布缓冲区；渲染完成后无法直接操作已画元素"),l("td",null,"XML 描述图形，浏览器解析为 DOM 节点；元素可直接操作和绑定事件")]),l("tr",null,[l("td",null,[l("strong",null,"交互性")]),l("td",null,"需要手动管理元素状态和事件，复杂"),l("td",null,"高，可直接绑定事件、样式和动画")]),l("tr",null,[l("td",null,[l("strong",null,"性能")]),l("td",null,"高性能，适合大量元素和频繁重绘"),l("td",null,"元素数量多时性能下降，不适合上万级节点")]),l("tr",null,[l("td",null,[l("strong",null,"缩放")]),l("td",null,"放大可能模糊，需要重绘"),l("td",null,"矢量缩放无损失")]),l("tr",null,[l("td",null,[l("strong",null,"典型应用场景")]),l("td",null,"游戏、实时数据图表、粒子动画、图像处理"),l("td",null,"数据可视化中等规模图表、流程图、拓扑图、矢量图标、地图")]),l("tr",null,[l("td",null,[l("strong",null,"优点")]),l("td",null,"高性能、适合实时渲染和复杂动画"),l("td",null,"高可交互性、开发简单、支持矢量缩放")]),l("tr",null,[l("td",null,[l("strong",null,"缺点")]),l("td",null,"不可直接操作已绘制元素、事件管理复杂"),l("td",null,"渲染大量元素性能下降、不适合高频更新")])])],-1)])]),_:1}),n[41]||(n[41]=l("h3",{id:"_20-git-pull-与-git-fetch",tabindex:"-1"},[u("20. git pull 与 git fetch "),l("a",{class:"header-anchor",href:"#_20-git-pull-与-git-fetch","aria-label":"Permalink to “20. git pull 与 git fetch”"},"​")],-1)),e(t,null,{default:i(()=>[...n[18]||(n[18]=[l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"对比项"),l("th",null,[l("code",null,"git fetch")]),l("th",null,[l("code",null,"git pull")])])]),l("tbody",null,[l("tr",null,[l("td",null,[l("strong",null,"作用")]),l("td",null,"只从远程仓库拉取最新的提交记录和分支信息，不合并"),l("td",null,"从远程仓库拉取后，自动与本地分支进行合并（或 rebase）")]),l("tr",null,[l("td",null,[l("strong",null,"是否修改本地代码")]),l("td",null,"❌ 不会修改当前工作区或本地分支"),l("td",null,"✅ 会修改当前分支（触发 merge 或 rebase）")]),l("tr",null,[l("td",null,[l("strong",null,"是否更新远程追踪分支")]),l("td",null,[u("✅ 更新（如 "),l("code",null,"origin/main"),u("）")]),l("td",null,"✅ 更新（并合并到当前分支）")]),l("tr",null,[l("td",null,[l("strong",null,"安全性")]),l("td",null,"✅ 安全（不会改变当前代码）"),l("td",null,"⚠️ 有风险（可能产生冲突）")]),l("tr",null,[l("td",null,[l("strong",null,"命令形式")]),l("td",null,[l("code",null,"git fetch [remote] [branch]")]),l("td",null,[l("code",null,"git pull [remote] [branch]")])]),l("tr",null,[l("td",null,[l("strong",null,"实际等价操作")]),l("td",null,"—"),l("td",null,[l("code",null,"git fetch"),u(" + "),l("code",null,"git merge FETCH_HEAD")])]),l("tr",null,[l("td",null,[l("strong",null,"适用场景")]),l("td",null,"想先查看远程更新，不立即合并；或用于手动合并策略"),l("td",null,"想直接更新到最新版本（自动合并）")]),l("tr",null,[l("td",null,[l("strong",null,"可见效果")]),l("td",null,[u("更新 "),l("code",null,".git"),u(" 内部的远程分支信息")]),l("td",null,"同时更新远程信息并更新工作区")]),l("tr",null,[l("td",null,[l("strong",null,"是否可能冲突")]),l("td",null,"❌ 不会冲突"),l("td",null,"⚠️ 可能发生合并冲突")]),l("tr",null,[l("td",null,[l("strong",null,"常用组合命令")]),l("td",null,[l("code",null,"git fetch origin main && git log HEAD..origin/main")]),l("td",null,[l("code",null,"git pull origin main")])])])],-1)])]),_:1}),n[42]||(n[42]=l("h3",{id:"_21-git-merge-与-git-rebase",tabindex:"-1"},[u("21. git merge 与 git rebase "),l("a",{class:"header-anchor",href:"#_21-git-merge-与-git-rebase","aria-label":"Permalink to “21. git merge 与 git rebase”"},"​")],-1)),e(t,null,{default:i(()=>[...n[19]||(n[19]=[l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"对比项"),l("th",null,[l("code",null,"git merge")]),l("th",null,[l("code",null,"git rebase")])])]),l("tbody",null,[l("tr",null,[l("td",null,[l("strong",null,"主要作用")]),l("td",null,"合并两个分支的历史记录，生成一个新的“合并提交”"),l("td",null,"将一个分支的提交重新“嫁接”到另一个分支上")]),l("tr",null,[l("td",null,[l("strong",null,"历史结构")]),l("td",null,"保留分叉历史（产生合并节点）"),l("td",null,"线性化历史（重写提交）")]),l("tr",null,[l("td",null,[l("strong",null,"是否生成新提交")]),l("td",null,[u("✅ 会生成一个新的 "),l("em",null,"merge commit")]),l("td",null,"⚠️ 重新生成一批新的提交（commit hash 改变）")]),l("tr",null,[l("td",null,[l("strong",null,"提交历史结果")]),l("td",null,"历史复杂，但真实反映开发过程"),l("td",null,"历史干净，像一条直线")]),l("tr",null,[l("td",null,[l("strong",null,"是否修改提交哈希")]),l("td",null,"❌ 不会改变已有提交的哈希"),l("td",null,"✅ 所有 rebase 的提交哈希都会改变")]),l("tr",null,[l("td",null,[l("strong",null,"是否易冲突")]),l("td",null,"⚠️ 可能在合并时冲突一次"),l("td",null,"⚠️ 每个提交应用时都可能冲突")]),l("tr",null,[l("td",null,[l("strong",null,"安全性")]),l("td",null,"✅ 安全（不会重写历史）"),l("td",null,"⚠️ 可能破坏共享历史（不建议在公共分支上用）")]),l("tr",null,[l("td",null,[l("strong",null,"适用场景")]),l("td",null,"保留真实开发分支结构（例如多人合作）"),l("td",null,"自己分支上整理历史，让日志更清晰")]),l("tr",null,[l("td",null,[l("strong",null,"常见命令")]),l("td",null,[l("code",null,"git merge feature")]),l("td",null,[l("code",null,"git rebase main")])]),l("tr",null,[l("td",null,[l("strong",null,"结果历史示意")]),l("td",null,"分叉 + 合并节点 🪵"),l("td",null,"一条直线 🚀")]),l("tr",null,[l("td",null,[l("strong",null,"是否影响他人")]),l("td",null,"❌ 不会（提交哈希不变）"),l("td",null,"⚠️ 若已推送，会影响他人分支同步")])])],-1)])]),_:1}),n[43]||(n[43]=o("",2))])}const x=a(p,[["render",m]]);export{c as __pageData,x as default};
