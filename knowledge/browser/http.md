


### 1. http2的首部压缩

- 为什么要压缩首部？
  - HTTP/1.1 的每个请求都会携带大量重复的首部. 这些头部在同一个连接中 几乎每次都一样，比如 User-Agent、Cookie、Accept。HTTP/2 引入 首部压缩（Header Compression） 来减少这种重复，提高传输效率。

- HTTP/2 首部压缩机制：HPACK

| 机制                          | 说明                                                   |
| --------------------------- | ---------------------------------------------------- |
| **静态表（Static Table）**       | 内置常见头部字段，如 `:method`, `:path`, `:status` 等；用索引代替字符串。 |
| **动态表（Dynamic Table）**      | 在连接中缓存已发送的头部；后续请求只需引用索引。                             |
| **霍夫曼编码（Huffman Encoding）** | 对字符串部分再进行霍夫曼编码，进一步压缩体积。                              |

- HPACK 的压缩原理图

| 步骤 | 动作     | 效果                               |
| -- | ------ | -------------------------------- |
| 1  | 查静态表   | 常用字段直接用编号（如 `:method: GET` = #2） |
| 2  | 查动态表   | 最近请求过的头字段从表中引用                   |
| 3  | 发送差异数据 | 只发送新字段或变化部分                      |
| 4  | 霍夫曼编码  | 对字符串再压缩                          |
| ✅  | 结果     | 头部数据量可减少 60–90%                  |


HTTP/2 的首部压缩机制（HPACK）通过静态表、动态表和霍夫曼编码三种方式，实现头部字段的高效压缩与重用，大幅减少网络传输开销。

### 2. tcp 断开4次挥手

<Collapse>

TCP 是全双工的. 全双工（Full-duplex）：
 - 即双方可以同时发送和接收数据。
 - 所以连接断开时，双方都要单独关闭各自的发送方向。


假设：客户端（主动关闭连接）服务器（被动关闭连接）

通信结束时，断开过程如下：

| 步骤 | 方向        | 报文标志位   | 说明                   |
| -- | --------- | ------- | -------------------- |
| ①  | 客户端 → 服务器 | `FIN=1` | 客户端请求关闭发送通道          |
| ②  | 服务器 → 客户端 | `ACK=1` | 服务器确认接收              |
| ③  | 服务器 → 客户端 | `FIN=1` | 服务器也关闭发送通道           |
| ④  | 客户端 → 服务器 | `ACK=1` | 客户端确认接收，进入 TIME_WAIT |


```
客户端 (Client)                             服务器 (Server)
------------------                          ------------------

   ESTABLISHED                                  ESTABLISHED
        |                                              |
        | ① FIN=1, seq=u                              |
        |--------------------------------------------->|
        |                                              |
        |                           收到 FIN, 发 ACK=1, ack=u+1
        | ②                                            |
        |<---------------------------------------------|
        |                                              |
        |                           服务器继续处理剩余数据
        |                                              |
        |                           ③ FIN=1, seq=v    |
        |<---------------------------------------------|
        | ④ ACK=1, ack=v+1                             |
        |--------------------------------------------->|
        |                                              |
   TIME_WAIT(等待2MSL)                          CLOSED
        |
   连接彻底关闭
```


客户端最后要 等待 2×MSL（Maximum Segment Lifetime） 时间，约几十秒。

作用：
- 确保服务器收到最终 ACK
  - 若 ACK 丢失，服务器会重发 FIN。
  - 客户端在 TIME_WAIT 状态还能重发 ACK。

- 防止旧连接残余报文影响新连接
  - 等待 MSL 确保网络中旧包都过期。

1. 为什么关闭要四次，而不是三次？
因为 TCP 是全双工：
 - 一方关闭发送，不代表另一方也关闭；
 - 必须双方都各自发送 FIN，确认关闭。

2. 为什么客户端要 TIME_WAIT？

防止最后的 ACK 丢失，确保连接彻底关闭。
另外，避免旧连接的数据干扰新连接。

3. 为什么是 “2MSL”？

因为：
一个 MSL 是一个报文在网络中能存活的最长时间；
等 2×MSL，确保往返的所有旧报文都消失。

4. 如果服务器先关闭会怎样？

流程相同，只是角色对调。
谁主动关闭，谁就经历 TIME_WAIT。

</Collapse>


### 3. 是什么队头阻塞

<Collapse>

队头阻塞就是“队列第一个请求卡住，后面全被拖延”。HTTP/3 通过 QUIC 彻底缓解了这个问题。



</Collapse>


### 其他

- HTTP/1.1 
  - 特点: 持久连接 (Keep-Alive);管道化 (Pipelining);多连接并发;头部冗余;
  - 问题: 队头阻塞、连接利用率低、头部冗余。
- HTTP2 
  - 特点: 二进制分帧 (Binary Framing);多路复用 (Multiplexing);头部压缩 (HPACK);服务端推送 (Server Push);
  - 改进点：减少延迟、提升带宽利用率。
  - 问题: 因为仍然基于 TCP，丢包时所有流都要等，TCP 层仍然存在 队头阻塞
- HTTP/3
  - 特点: 基于 QUIC 协议（UDP 上实现）;内置 TLS 1.3 加密;更快的连接建立;多路复用天然支持;


- TLS/SSL: 加密（防止窃听）;身份认证（确认服务端身份）;完整性校验（防止篡改）

- HTTPS 是在 HTTP 与 TCP 之间加入了TLS/SSL层，保证了通信的安全性。它通过数字证书验证服务器身份，用非对称加密实现安全的密钥交换，然后使用对称加密进行高效的数据传输。TLS 1.3 相比 TLS 1.2，减少了握手延迟并提升了安全性。

- TLS 握手过程: ClientHello(浏览器发起握手，请求支持的加密算法、随机数), ServerHello(服务器选择加密算法，返回随机数和 数字证书（包含公钥）),验证证书(浏览器验证证书是否可信（CA 签发、域名匹配、未过期）), 密钥交换(浏览器用服务器公钥加密一个“对称会话密钥”，发给服务器。服务器用私钥解密，拿到对称密钥。), 建立安全通信(后续通信用对称加密（如 AES, ECC），保证性能)

- TCP 特点: 传输控制协议：面向连接的，可靠的，基于字节流的传输层通信协议.(基于连接的,字节流,流量缓冲,可靠的传输服务,拥塞控制)

- SYN: 握手, ACK 应答, FIN 断开