#!/usr/bin/env node

const fs = require('fs/promises')
const path = require('path')
const ROOT = path.resolve(__dirname, '..')
const SOURCE_DIRS = ['ai', 'algorithm', 'book', 'interview', 'knowledge'].map((dir) =>
  path.join(ROOT, dir)
)
const BASE_PATH = '/myKMS'
const OUTPUT_FILE = path.join(ROOT, '.vitepress/theme/data/questions.generated.ts')

const SECTION_REGEX = /^###\s+([^\n]+)\n([\s\S]*?)(?=^###\s+|(?![\s\S]))/gm
const R_CONTROL = /[\u0000-\u001f]/g
const R_SPECIAL = /[\s~`!@#$%^&*()\-_+=[\]{}|\\;:"'“”‘’<>,.?/]+/g
const R_COMBINING = /[\u0300-\u036F]/g
const COLLAPSE_REGEX = /<Collapse>([\s\S]*?)<\/Collapse>/i
let markdownRendererPromise

async function main() {
  const markdownFiles = []
  for (const dir of SOURCE_DIRS) {
    const exists = await pathExists(dir)
    if (!exists) continue
    const files = await collectMarkdownFiles(dir)
    markdownFiles.push(...files)
  }

  let nextId = 1
  const questions = []

  for (const filePath of markdownFiles.sort()) {
    const relativePath = path.relative(ROOT, filePath)
    const routePath = `${BASE_PATH}/${relativePath.replace(/\\/g, '/').replace(/\.md$/i, '')}`
    const content = await fs.readFile(filePath, 'utf-8')
    const normalizedContent = content.replace(/\r\n/g, '\n')
    const sections = extractSections(normalizedContent)

    for (const section of sections) {
      const collapseContent = extractCollapse(section.body)
      if (!collapseContent) continue

      const answerBlocks = buildAnswerBlocks(collapseContent)
      if (!answerBlocks.length) continue

      const answerHtml = []
      for (const block of answerBlocks) {
        const rendered = await renderMarkdown(block)
        answerHtml.push(rendered.trim())
      }

      const questionText = toQuestionText(section.heading)
      const slug = toSlug(section.heading)
      const reference = `${routePath}#${slug}`

      questions.push({
        id: nextId++,
        question: questionText,
        answer: answerBlocks,
        answerHtml,
        reference,
        source: routePath
      })
    }
  }

  await writeOutput(questions)
  console.log(`[generate-questions] collected ${questions.length} question(s).`)
}

async function pathExists(targetPath) {
  try {
    await fs.access(targetPath)
    return true
  } catch {
    return false
  }
}

async function collectMarkdownFiles(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true })
  const files = []

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name)
    if (entry.isDirectory()) {
      const nested = await collectMarkdownFiles(fullPath)
      files.push(...nested)
    } else if (entry.isFile() && entry.name.endsWith('.md')) {
      files.push(fullPath)
    }
  }

  return files
}

function extractSections(content) {
  SECTION_REGEX.lastIndex = 0
  const sections = []
  let match
  while ((match = SECTION_REGEX.exec(content)) !== null) {
    sections.push({
      heading: match[1].trim(),
      body: match[2].trim()
    })
  }
  return sections
}

function extractCollapse(sectionBody) {
  const collapseMatch = sectionBody.match(COLLAPSE_REGEX)
  if (!collapseMatch) return null
  return collapseMatch[1].trim()
}

function buildAnswerBlocks(rawContent) {
  const lines = rawContent.split('\n')
  const blocks = []
  let buffer = []
  let insideCode = false

  const pushBuffer = () => {
    if (!buffer.length) return
    const text = buffer.join('\n').trim()
    if (text) {
      blocks.push(text)
    }
    buffer = []
  }

  for (const rawLine of lines) {
    const line = rawLine.replace(/\r/g, '')
    const trimmed = line.trim()

    if (trimmed.startsWith('```')) {
      if (insideCode) {
        buffer.push(line)
        pushBuffer()
        insideCode = false
      } else {
        pushBuffer()
        insideCode = true
        buffer.push(line)
      }
      continue
    }

    if (insideCode) {
      buffer.push(line)
      continue
    }

    if (!trimmed) {
      pushBuffer()
      continue
    }

    buffer.push(line)
  }
  pushBuffer()

  return blocks
}

function toQuestionText(heading) {
  return heading.replace(/^\d+[.)、]?\s*/, '').trim() || heading.trim()
}

function toSlug(heading) {
  const normalized = heading
    .normalize('NFKD')
    .replace(R_COMBINING, '')
    .replace(R_CONTROL, '')
    .replace(R_SPECIAL, '-')
    .replace(/-{2,}/g, '-')
    .replace(/^-+|-+$/g, '')
    .replace(/^(\d)/, '_$1')
    .toLowerCase()

  return normalized || '_section'
}

async function renderMarkdown(content) {
  const renderer = await getMarkdownRenderer()
  return renderer.render(content)
}

async function getMarkdownRenderer() {
  if (!markdownRendererPromise) {
    markdownRendererPromise = import('vitepress').then(({ createMarkdownRenderer }) =>
      createMarkdownRenderer(ROOT)
    )
  }
  return markdownRendererPromise
}

async function writeOutput(questionList) {
  const header = `// This file is auto-generated by scripts/generate-questions.js. Do not edit manually.\nimport type { Question } from './questionTypes'\n\n`
  const body = `export const questions: Question[] = ${JSON.stringify(questionList, null, 2)}\n`
  await fs.mkdir(path.dirname(OUTPUT_FILE), { recursive: true })
  await fs.writeFile(OUTPUT_FILE, header + body, 'utf-8')
}

main().catch((error) => {
  console.error('[generate-questions] failed:', error)
  process.exit(1)
})


const all=(s) => {
  const a=s.split('');
  let arr=[];
  const loop = (a,s, n=3) => {
    if (a.length===n) {
      arr.push(a);
      return ;
    }
    for(let i=s;i<a.length;i++){
      arr.push(a[i]);
      loop(arr,i+1);
      a.pop();
    }
  }
  loop([],0);
  return arr;
}