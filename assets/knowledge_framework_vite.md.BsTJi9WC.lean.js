import{_ as a,I as d,c as n,o as r,ah as l,J as s,w as o,j as t}from"./chunks/framework.fGi7qB65.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/framework/vite.md","filePath":"knowledge/framework/vite.md"}'),g={name:"knowledge/framework/vite.md"};function u(f,e,p,c,x,y){const i=d("Collapse");return r(),n("div",null,[e[1]||(e[1]=l("",20)),s(i,null,{default:o(()=>[...e[0]||(e[0]=[t("p",null,"修改代码 → 浏览器自动更新 → 状态不丢失",-1),t("p",null,"基本工作原理",-1),t("ol",null,[t("li",null,"开发服务器启动时：Vite 会用 ES Module 的方式向浏览器提供源码。"),t("li",null,"文件变动：Vite 通过 chokidar 监听文件改动。"),t("li",null,"HMR 通知：Vite Dev Server 用 WebSocket 通知浏览器“某个模块变了”。type:'update', updates 更新的文件内容"),t("li",null,"模块替换：浏览器端的 Vite HMR 客户端会：尝试只替换改动的模块（比如 .vue 组件、.css 文件）。如i18n.json 文件修改, 会刷新页面"),t("li",null,"import.meta.hot 可以手动控制 HMR 行为"),t("li",null,"Vite 内部维护一份 模块依赖图,向上传播，找接受更新的模块, 如果无法安全替换（比如入口文件改了），就会触发 整页刷新。")],-1),t("p",null,"Webpack HMR:基本原理一致, 开发时需要 打包，生成 bundle.js, 因为有打包过程，HMR 会比 Vite 慢",-1),t("p",null,"为什么 Vite 的 HMR 比 Webpack 快？",-1),t("ol",null,[t("li",null,"Vite 基于 原生 ESM，不用重新打整个 bundle。"),t("li",null,"改动时只编译改动文件（按需编译）。"),t("li",null,"Webpack 需要走完整的打包流程，依赖图越大更新越慢。"),t("li",null,"所以在大项目里，Webpack 热更新可能要几秒，而 Vite 通常 <100ms。")],-1),t("p",null,"Vite 如何实现 React/Vue 的状态保留热更新？",-1),t("ol",null,[t("li",null,"React：通过 @vitejs/plugin-react 集成 react-refresh，在替换组件时保留 Hook 状态。"),t("li",null,"Vue：通过 @vitejs/plugin-vue，在替换 .vue 组件时保留组件实例的响应式状态。"),t("li",null,"本质：框架层插件拦截 HMR 更新过程，执行“局部替换 + 状态迁移”。")],-1),t("p",null,"Vite HMR 可能带来的问题？",-1),t("ol",null,[t("li",null,"内存泄漏：模块替换时没清理事件监听 / 定时器。"),t("li",null,"调试复杂度：和实际生产行为不一致（生产中没有 HMR）。"),t("li",null,"兼容性问题：某些第三方库没有 HMR 支持，只能整页刷新")],-1)])]),_:1}),e[2]||(e[2]=l("",3))])}const k=a(g,[["render",u]]);export{h as __pageData,k as default};
