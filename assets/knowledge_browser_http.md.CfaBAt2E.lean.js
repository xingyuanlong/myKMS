import{_ as s,I as i,c as d,o as p,j as l,J as a,ah as r,a as n,w as e}from"./chunks/framework.fGi7qB65.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/browser/http.md","filePath":"knowledge/browser/http.md"}'),o={name:"knowledge/browser/http.md"};function T(h,u,c,P,S,m){const t=i("Collapse");return p(),d("div",null,[u[6]||(u[6]=l("h3",{id:"_1-http2的首部压缩",tabindex:"-1"},[n("1. http2的首部压缩 "),l("a",{class:"header-anchor",href:"#_1-http2的首部压缩","aria-label":"Permalink to “1. http2的首部压缩”"},"​")],-1)),a(t,null,{default:e(()=>[...u[0]||(u[0]=[l("ul",null,[l("li",null,[l("p",null,"为什么要压缩首部？"),l("ul",null,[l("li",null,"HTTP/1.1 的每个请求都会携带大量重复的首部. 这些头部在同一个连接中 几乎每次都一样，比如 User-Agent、Cookie、Accept。HTTP/2 引入 首部压缩（Header Compression） 来减少这种重复，提高传输效率。")])]),l("li",null,[l("p",null,"HTTP/2 首部压缩机制：HPACK")])],-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"机制"),l("th",null,"说明")])]),l("tbody",null,[l("tr",null,[l("td",null,[l("strong",null,"静态表（Static Table）")]),l("td",null,[n("内置常见头部字段，如 "),l("code",null,":method"),n(", "),l("code",null,":path"),n(", "),l("code",null,":status"),n(" 等；用索引代替字符串。")])]),l("tr",null,[l("td",null,[l("strong",null,"动态表（Dynamic Table）")]),l("td",null,"在连接中缓存已发送的头部；后续请求只需引用索引。")]),l("tr",null,[l("td",null,[l("strong",null,"霍夫曼编码（Huffman Encoding）")]),l("td",null,"对字符串部分再进行霍夫曼编码，进一步压缩体积。")])])],-1),l("ul",null,[l("li",null,"HPACK 的压缩原理图")],-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"步骤"),l("th",null,"动作"),l("th",null,"效果")])]),l("tbody",null,[l("tr",null,[l("td",null,"1"),l("td",null,"查静态表"),l("td",null,[n("常用字段直接用编号（如 "),l("code",null,":method: GET"),n(" = #2）")])]),l("tr",null,[l("td",null,"2"),l("td",null,"查动态表"),l("td",null,"最近请求过的头字段从表中引用")]),l("tr",null,[l("td",null,"3"),l("td",null,"发送差异数据"),l("td",null,"只发送新字段或变化部分")]),l("tr",null,[l("td",null,"4"),l("td",null,"霍夫曼编码"),l("td",null,"对字符串再压缩")]),l("tr",null,[l("td",null,"✅"),l("td",null,"结果"),l("td",null,"头部数据量可减少 60–90%")])])],-1),l("p",null,[l("strong",null,"HTTP/2 的首部压缩机制（HPACK）通过静态表、动态表和霍夫曼编码三种方式，实现头部字段的高效压缩与重用，大幅减少网络传输开销。")],-1)])]),_:1}),u[7]||(u[7]=l("h3",{id:"_2-tcp-断开4次挥手",tabindex:"-1"},[n("2. tcp 断开4次挥手 "),l("a",{class:"header-anchor",href:"#_2-tcp-断开4次挥手","aria-label":"Permalink to “2. tcp 断开4次挥手”"},"​")],-1)),a(t,null,{default:e(()=>[...u[1]||(u[1]=[l("p",null,"TCP 是全双工的. 全双工（Full-duplex）：",-1),l("ul",null,[l("li",null,"即双方可以同时发送和接收数据。"),l("li",null,"所以连接断开时，双方都要单独关闭各自的发送方向。")],-1),l("p",null,"假设：客户端（主动关闭连接）服务器（被动关闭连接）",-1),l("p",null,"通信结束时，断开过程如下：",-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"步骤"),l("th",null,"方向"),l("th",null,"报文标志位"),l("th",null,"说明")])]),l("tbody",null,[l("tr",null,[l("td",null,"①"),l("td",null,"客户端 → 服务器"),l("td",null,[l("code",null,"FIN=1")]),l("td",null,"客户端请求关闭发送通道")]),l("tr",null,[l("td",null,"②"),l("td",null,"服务器 → 客户端"),l("td",null,[l("code",null,"ACK=1")]),l("td",null,"服务器确认接收")]),l("tr",null,[l("td",null,"③"),l("td",null,"服务器 → 客户端"),l("td",null,[l("code",null,"FIN=1")]),l("td",null,"服务器也关闭发送通道")]),l("tr",null,[l("td",null,"④"),l("td",null,"客户端 → 服务器"),l("td",null,[l("code",null,"ACK=1")]),l("td",null,"客户端确认接收，进入 TIME_WAIT")])])],-1),l("div",{class:"language-"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"}),l("pre",{class:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabindex:"0",dir:"ltr"},[l("code",null,[l("span",{class:"line"},[l("span",null,"客户端 (Client)                             服务器 (Server)")]),n(`
`),l("span",{class:"line"},[l("span",null,"------------------                          ------------------")]),n(`
`),l("span",{class:"line"},[l("span")]),n(`
`),l("span",{class:"line"},[l("span",null,"   ESTABLISHED                                  ESTABLISHED")]),n(`
`),l("span",{class:"line"},[l("span",null,"        |                                              |")]),n(`
`),l("span",{class:"line"},[l("span",null,"        | ① FIN=1, seq=u                              |")]),n(`
`),l("span",{class:"line"},[l("span",null,"        |--------------------------------------------->|")]),n(`
`),l("span",{class:"line"},[l("span",null,"        |                                              |")]),n(`
`),l("span",{class:"line"},[l("span",null,"        |                           收到 FIN, 发 ACK=1, ack=u+1")]),n(`
`),l("span",{class:"line"},[l("span",null,"        | ②                                            |")]),n(`
`),l("span",{class:"line"},[l("span",null,"        |<---------------------------------------------|")]),n(`
`),l("span",{class:"line"},[l("span",null,"        |                                              |")]),n(`
`),l("span",{class:"line"},[l("span",null,"        |                           服务器继续处理剩余数据")]),n(`
`),l("span",{class:"line"},[l("span",null,"        |                                              |")]),n(`
`),l("span",{class:"line"},[l("span",null,"        |                           ③ FIN=1, seq=v    |")]),n(`
`),l("span",{class:"line"},[l("span",null,"        |<---------------------------------------------|")]),n(`
`),l("span",{class:"line"},[l("span",null,"        | ④ ACK=1, ack=v+1                             |")]),n(`
`),l("span",{class:"line"},[l("span",null,"        |--------------------------------------------->|")]),n(`
`),l("span",{class:"line"},[l("span",null,"        |                                              |")]),n(`
`),l("span",{class:"line"},[l("span",null,"   TIME_WAIT(等待2MSL)                          CLOSED")]),n(`
`),l("span",{class:"line"},[l("span",null,"        |")]),n(`
`),l("span",{class:"line"},[l("span",null,"   连接彻底关闭")])])])],-1),l("p",null,"客户端最后要 等待 2×MSL（Maximum Segment Lifetime） 时间，约几十秒。",-1),l("p",null,"作用：",-1),l("ul",null,[l("li",null,[l("p",null,"确保服务器收到最终 ACK"),l("ul",null,[l("li",null,"若 ACK 丢失，服务器会重发 FIN。"),l("li",null,"客户端在 TIME_WAIT 状态还能重发 ACK。")])]),l("li",null,[l("p",null,"防止旧连接残余报文影响新连接"),l("ul",null,[l("li",null,"等待 MSL 确保网络中旧包都过期。")])])],-1),l("ol",null,[l("li",null,"为什么关闭要四次，而不是三次？ 因为 TCP 是全双工：")],-1),l("ul",null,[l("li",null,"一方关闭发送，不代表另一方也关闭；"),l("li",null,"必须双方都各自发送 FIN，确认关闭。")],-1),l("ol",{start:"2"},[l("li",null,"为什么客户端要 TIME_WAIT？")],-1),l("p",null,"防止最后的 ACK 丢失，确保连接彻底关闭。 另外，避免旧连接的数据干扰新连接。",-1),l("ol",{start:"3"},[l("li",null,"为什么是 “2MSL”？")],-1),l("p",null,"因为： 一个 MSL 是一个报文在网络中能存活的最长时间； 等 2×MSL，确保往返的所有旧报文都消失。",-1),l("ol",{start:"4"},[l("li",null,"如果服务器先关闭会怎样？")],-1),l("p",null,"流程相同，只是角色对调。 谁主动关闭，谁就经历 TIME_WAIT。",-1)])]),_:1}),u[8]||(u[8]=l("h3",{id:"_3-什么是队头阻塞",tabindex:"-1"},[n("3. 什么是队头阻塞 "),l("a",{class:"header-anchor",href:"#_3-什么是队头阻塞","aria-label":"Permalink to “3. 什么是队头阻塞”"},"​")],-1)),a(t,null,{default:e(()=>[...u[2]||(u[2]=[l("p",null,"队头阻塞就是“队列第一个请求卡住，后面全被拖延”。HTTP/3 通过 QUIC 彻底缓解了这个问题。",-1)])]),_:1}),u[9]||(u[9]=l("h3",{id:"_4-http-2-多路复用",tabindex:"-1"},[n("4. http 2 多路复用 "),l("a",{class:"header-anchor",href:"#_4-http-2-多路复用","aria-label":"Permalink to “4. http 2 多路复用”"},"​")],-1)),a(t,null,{default:e(()=>[...u[3]||(u[3]=[l("p",null,"HTTP/1.1 每个请求都必须建立在一个 TCP 连接上。虽然它支持“Keep-Alive”长连接，但仍然有两个性能瓶颈：",-1),l("ul",null,[l("li",null,"队头阻塞（Head-of-Line Blocking）: 一个连接中，请求是串行执行的。前一个响应没回来，后面的请求必须等。"),l("li",null,"多连接并发受限: 浏览器为同一域名通常只能同时开 6 个 TCP 连接，多了也被限制。"),l("li",null,"📦 头部重复传输: 每次请求都要携带大量相同的 Header（如 cookie、user-agent）。")],-1),l("p",null,"在一个 TCP 连接上，同时并发多个 HTTP 请求与响应。",-1),l("p",null,"工作方式：",-1),l("ol",null,[l("li",null,"所有请求和响应都被拆分成小块（frame）。"),l("li",null,"每个请求分配一个唯一的 Stream ID。"),l("li",null,"这些 frame 被交错（交织）发送，在同一个 TCP 连接中同时传输。"),l("li",null,"接收端再根据 Stream ID 把它们拼回原样。")],-1),l("p",null,"举个例子： 假设浏览器要加载三个资源：",-1),l("div",{class:"language-"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"}),l("pre",{class:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabindex:"0",dir:"ltr"},[l("code",null,[l("span",{class:"line"},[l("span",null,"index.html")]),n(`
`),l("span",{class:"line"},[l("span",null,"style.css")]),n(`
`),l("span",{class:"line"},[l("span",null,"main.js")])])])],-1),l("p",null,"HTTP/1.1：",-1),l("ul",null,[l("li",null,"3 个请求需要占用 3 个 TCP 连接；"),l("li",null,"或者 1 个连接按顺序：html → css → js；"),l("li",null,"前面的慢了，后面的全卡住（队头阻塞）。")],-1),l("p",null,"HTTP/2：",-1),l("ul",null,[l("li",null,"所有请求共用 1 个 TCP 连接；"),l("li",null,"三个请求的 frame 被交错发送；"),l("li",null,"谁先返回数据就先解析，完全并行。")],-1),l("p",null,"多路复用消除了 HTTP 层阻塞，但 TCP 层仍可能受丢包影响。",-1),l("p",null,[l("strong",null,"HTTP/2 多路复用 = 一个连接里同时传多条请求流，互不阻塞，性能飞升。")],-1)])]),_:1}),u[10]||(u[10]=l("h3",{id:"_5-dns-协议",tabindex:"-1"},[n("5. DNS 协议 "),l("a",{class:"header-anchor",href:"#_5-dns-协议","aria-label":"Permalink to “5. DNS 协议”"},"​")],-1)),a(t,null,{default:e(()=>[...u[4]||(u[4]=[l("p",null,"DNS（Domain Name System） 是一个将 域名 ↔ IP 地址 相互映射的分布式系统。",-1),l("p",null,"因为：用户容易记住 www.example.com;计算机只能识别 93.184.216.34;DNS 让我们可以使用域名访问网站，系统自动帮你找到正确的 IP。",-1),l("p",null,"DNS 解析的完整流程:",-1),l("ul",null,[l("li",null,"浏览器缓存: 先查本地 DNS 缓存（比如上次访问过)"),l("li",null,"操作系统缓存: 如果浏览器里没有，就问操作系统的 DNS 缓存。"),l("li",null,"hosts 文件: 操作系统先查 hosts 文件，看看是否有手动配置。"),l("li",null,"本地 DNS 服务器（递归解析器）: 一般由 ISP（网络运营商）提供，比如 8.8.8.8（Google）、114.114.114.114（中国电信）。"),l("li",null,"递归查询（DNS 服务器帮你查到底）")],-1),l("p",null,"DNS 通常使用 UDP 53 端口（查询），TCP 用于传输大数据量（如区域传送）。",-1),l("p",null,"每条 DNS 记录都有一个 TTL（Time To Live） 值，比如 300 秒。",-1)])]),_:1}),u[11]||(u[11]=l("h3",{id:"_6-html-script-defer-与async",tabindex:"-1"},[n("6. html script defer 与async "),l("a",{class:"header-anchor",href:"#_6-html-script-defer-与async","aria-label":"Permalink to “6. html script defer 与async”"},"​")],-1)),a(t,null,{default:e(()=>[...u[5]||(u[5]=[l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"特性"),l("th",null,[l("code",null,"<script async> ")]),l("th",null,[l("code",null,"<script defer>")])])]),l("tbody",null,[l("tr",null,[l("td",null,"加载时机 (Loading)"),l("td",null,"立即加载（与 HTML 解析并行）"),l("td",null,"立即加载（与 HTML 解析并行）")]),l("tr",null,[l("td",null,"执行时机 (Execution)"),l("td",null,"文件下载完成后立即执行"),l("td",null,"等待整个 HTML 文档解析完成后再执行")]),l("tr",null,[l("td",null,"执行顺序"),l("td",null,"不保证顺序。哪个文件先下载完，哪个先执行。"),l("td",null,"保证顺序。按在文档中出现的顺序依次执行。")]),l("tr",null,[l("td",null,"是否阻塞 HTML"),l("td",null,"会。文件执行时会暂停 HTML 解析。"),l("td",null,"不会。保证在 HTML 解析完成后才执行。")]),l("tr",null,[l("td",null,"适用场景"),l("td",null,"适用于独立脚本，不依赖 DOM，也不被其他脚本依赖（如统计脚本）。"),l("td",null,"适用于依赖 DOM 或被其他 defer 脚本依赖的脚本（如应用主逻辑脚本）。")])])],-1)])]),_:1}),u[12]||(u[12]=r("",2))])}const f=s(o,[["render",T]]);export{b as __pageData,f as default};
