

## 🧠 一、生命周期与架构机制

### **1️⃣ 小程序的启动流程是什么？从打开到渲染第一个页面发生了什么？**

**考点：** 启动机制、AppService 与 WebView 分层、渲染进程通信

**答题要点：**

* 小程序加载 `app.js` → 注册全局 App；
* 按路径加载页面 JSON / WXML / WXSS；
* 创建逻辑层（JSCore）；
* 创建视图层（WebView）；
* 逻辑层与视图层通过 **bridge 通信**；
* 初始化数据后，调用 `onLaunch` → `onShow` → 页面 `onLoad` → `onReady`。

> **进阶问法：** 为什么首次打开小程序比二次打开慢？
> **答：** 首次加载需要网络请求资源，二次打开可走缓存（代码包 + 启动冷启动优化）。

---

## ⚙️ 二、数据通信与性能

### **2️⃣ 为什么频繁 setData 会卡？怎么优化？**

**考点：** 数据传输机制、性能瓶颈、虚拟列表

**要点：**

* `setData` 会通过 JSBridge 发送 JSON 数据；
* 序列化 + 跨线程通信代价高；
* 高频或大数据量更新（>100KB）会导致掉帧；
* 优化：合并更新、虚拟列表、局部状态、节流/防抖、拆组件。

---

## 📦 三、渲染机制与组件化

### **3️⃣ 小程序组件通信有哪些方式？**

**考点：** 组件解耦与架构设计

**答题要点：**

* 父子通信：`properties` + `triggerEvent`
* 页面与组件通信：`selectComponent`
* 跨组件通信：`EventChannel`、全局状态（Vuex / Pinia / MobX）
* 兄弟组件通信：事件总线、全局 store、或通过父组件中转
* 第三方封装：`mitt`、`PubSubJS` 等

---

### **4️⃣ WXML 渲染机制和 diff 更新原理？**

**考点：** 虚拟 DOM 概念、小程序框架层 Diff 策略

**要点：**

* 小程序维护虚拟节点树；
* setData 触发 diff；
* 仅变更差异部分节点；
* 渲染层异步更新；
* 和 React Diff 类似但通信层不同（跨线程）。

---

## 🧩 四、框架与架构设计

### **5️⃣ 你如何设计一个可复用的表单组件？**

**考点：** 通用组件化、可配置性

**要点：**

* 使用 `component`；
* 通过 `properties` 接收字段配置；
* 通过 `triggerEvent('change', value)` 向外传值；
* 支持校验（rules）、默认值、slot 自定义；
* 可通过配置驱动表单渲染。

> **加分答法：** 封装统一的 `Form` 容器 + `FormItem` 子组件，支持 JSON Schema 动态渲染。

---

## 🧭 五、网络与缓存机制

### **6️⃣ 小程序中请求并发限制是多少？如何突破？**

**考点：** 网络层限制与请求队列管理

**答题要点：**

* 同域名并发请求数限制为 **10 个**；
* 超出会被挂起；
* 优化方式：

  * 请求队列；
  * 请求合并；
  * 延迟加载；
  * WebSocket 保持长连接。

---

### **7️⃣ 本地缓存机制与限制？**

**考点：** `wx.setStorage` 与容量限制

**答题要点：**

* 同步与异步 API：`wx.setStorageSync`、`wx.getStorageSync`
* 单个 key 不能超过 **1MB**；
* 总容量约 **10MB**；
* 超出容量可能失败；
* 优化方式：索引表、分片缓存、清理无用数据。

---

## 🧰 六、运行环境与兼容性

### **8️⃣ 小程序中 JS 运行环境与浏览器的主要区别？**

**考点：** JSCore 特性、API 缺失

**要点：**

* 小程序不运行在浏览器；
* 没有 DOM、window、document；
* 不支持 BOM API（如 alert、localStorage）；
* 使用 JSCore；
* 使用微信提供的 API（wx.*）；
* 没有 ES 模块系统（需构建时打包）。

所有页面的脚本逻辑都跑在同一个JsCore线程，页面使用setTimeout或者setInterval的定时器，然后跳转到其他页面时，这些定时器并没有被清除，需要开发者自己在页面离开的时候进行清理

只要保持一个原则就可以提高小程序的渲染性能：每次只设置需要改变的最小单位数据。

---

## 🧩 七、跨端与框架对比

### **9️⃣ 说说你对 Taro、uni-app、原生小程序的理解与对比**

**考点：** 跨端方案、框架优缺点

| 框架                    | 优点                     | 缺点              |
| --------------------- | ---------------------- | --------------- |
| **原生小程序**             | 原生性能好，API 完整           | 开发效率低，生态小       |
| **Taro**              | React 语法，跨端（H5、RN、小程序） | 构建复杂，部分组件兼容性需适配 |
| **uni-app**           | Vue 语法，生态大             | 编译层较厚，调试成本高     |
| **Remax / Chameleon** | 支持 React/Vue 同构        | 维护者少            |

---

## 🧮 八、性能与工程优化

### **10️⃣ 你做过哪些小程序性能优化？从哪些维度入手？**

**考点：** 全面性能优化策略（开发者工具面板 + 架构优化）

**答题要点（可分层答）**

#### 🔹 结构层

* 分包加载（主包 < 2MB）
* 独立分包、预下载包

#### 🔹 渲染层

* 虚拟列表、懒加载、骨架屏
* 减少 setData 次数和体积
* 合理使用 scroll-view 而不是 page scroll

#### 🔹 网络层

* CDN 静态资源；
* 请求合并；
* 缓存（ETag、Storage）；
* 异步懒加载。

#### 🔹 构建层

* 开启压缩、Tree-Shaking；
* 减少无用依赖；
* 利用插件如 webpack-bundle-analyzer。




页面路由触发方式及页面生命周期函数的对应关系


| 路由方式   | 触发时机                         | 路由前页面生命周期 | 路由后页面生命周期     |
| ---------- | -------------------------------- | ------------------ | ---------------------- |
| 初始化     | 小程序打开的第一个页面           | —                  | onLoad, onShow         |
| 打开新页面 | 调用 API wx.navigateTo           | onHide             | onLoad, onShow         |
| 页面重定向 | 调用 API wx.redirectTo           | onUnload           | onLoad, onShow         |
| 页面返回   | 调用 API wx.navigateBack         | onUnload           | onShow                 |
| Tab 切换   | 调用 API wx.switchTab            | 请参考表3-6         | 请参考表3-6             |
| 重启动     | 调用 API wx.reLaunch             | onUnload           | onLoad, onShow         |



| 当前页面               | 路由后页面           | 触发的生命周期（按顺序）                             |
| ---------------------- | -------------------- | --------------------------------------------------- |
| A                      | A                    | 无                                                  |
| A                      | B                    | A.onHide(), B.onLoad(), B.onShow()                  |
| A                      | B (再次打开)         | A.onHide(), B.onShow()                              |
| C                      | A                    | C.onUnload(), A.onShow()                            |
| C                      | B                    | C.onUnload(), B.onLoad(), B.onShow()                |
| D                      | B                    | D.onUnload(), C.onUnload(), B.onLoad(), B.onShow()  |
| D (从转发进入)         | A                    | D.onUnload(), A.onLoad(), A.onShow()                |
| D (从转发进入)         | B                    | D.onUnload(), B.onLoad(), B.onShow()                |



优化建议: 
启动:
分包

数据通信优化:
1.不要过于频繁调用setData，应考虑将多次setData合并成一次setData调用；
2.数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示且数据结构比较复杂或包含长字符串，则不应使用setData来设置这些数据；
3.与界面渲染无关的数据最好不要设置在data中，可以考虑设置在page对象的其他字段下。

事件优化:
1.去掉不必要的事件绑定（WXML中的bind和catch），从而减少通信的数据量和次数；
2.事件绑定时需要传输target和currentTarget的dataset，因而不要在节点的data前缀属性中放置过大的数据


主要的优化策略可以归纳为三点：精简代码，降低WXML结构和JS代码的复杂性；合理使用setData调用，减少setData次数和数据量；必要时使用分包优化


 ### 页面实现watch

```js
// 手写工具
watch(key, handler) {
  let val = this.data[key]
  Object.defineProperty(this.data, key, {
    configurable: true,
    enumerable: true,
    get() { return val },
    set(newVal) {
      val = newVal
      handler.call(this, newVal)
    }
  })
},
onLoad() {
  this.watch('name', function(newVal) {
    console.log('name change', newVal)
  })
}


```

性能:
启动时性能和运行时性能

代码包体积优化:
1. 合理使用分包加载
2. 避免非必要的全局自定义组件和插件
3. 控制代码包内的资源文件
4. 及时清理无用代码和资源


代码注入优化:
1. 使用按需注入
2. 启动过程中减少同步 API 的调用
3. 避免启动过程进行复杂运算

首屏渲染优化:
1. 使用「按需注入」和「用时注入」
2. 启用「初始渲染缓存」
3. 避免引用未使用的自定义组件
4. 精简首屏数据
5. 提前首屏数据请求
6. 缓存请求数据
7. 骨架屏


1. 合理规划版本发布




合理使用 setData:
- data 应只包括渲染相关的数据
- 控制 setData 的频率
- 选择合适的 setData 范围
- setData 应只传发生变化的数据
- 控制后台态页面的 setData

渲染性能优化:
- 适当监听页面或组件的 scroll 事件
- 选择高性能的动画实现方式
- 使用 IntersectionObserver 监听元素曝光
- 控制 WXML 节点数量和层级
- 控制在 Page 构造时传入的自定义数据量


页面切换优化:
- 避免在 onHide/onUnload 执行耗时操作
- 首屏渲染优化
- 提前发起数据请求
- 控制预加载下个页面的时机


资源加载优化:
- 控制图片资源的大小
- 避免滥用 image 组件的 widthFix/heightFix 模式


内存优化:
- 合理使用分包加载
- 使用按需注入和用时注入
- 内存分析
- 处理内存告警

小程序常见的内存泄露问题
- 小程序长期持有页面实例，导致页面实例和引用的组件无法正常销毁
  - 页面实例被未解绑的事件监听引用
  - 页面实例被页面外变量或全局变量引用
  - 页面实例被异步回调长时间引用

- 事件监听未及时解绑
- 未清理的定时器  



