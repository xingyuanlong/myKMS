
### 1. http2的首部压缩

<Collapse>

- 为什么要压缩首部？
  - HTTP/1.1 的每个请求都会携带大量重复的首部. 这些头部在同一个连接中 几乎每次都一样，比如 User-Agent、Cookie、Accept。HTTP/2 引入 首部压缩（Header Compression） 来减少这种重复，提高传输效率。

- HTTP/2 首部压缩机制：HPACK

| 机制                          | 说明                                                   |
| --------------------------- | ---------------------------------------------------- |
| **静态表（Static Table）**       | 内置常见头部字段，如 `:method`, `:path`, `:status` 等；用索引代替字符串。 |
| **动态表（Dynamic Table）**      | 在连接中缓存已发送的头部；后续请求只需引用索引。                             |
| **霍夫曼编码（Huffman Encoding）** | 对字符串部分再进行霍夫曼编码，进一步压缩体积。                              |

- HPACK 的压缩原理图

| 步骤 | 动作     | 效果                               |
| -- | ------ | -------------------------------- |
| 1  | 查静态表   | 常用字段直接用编号（如 `:method: GET` = #2） |
| 2  | 查动态表   | 最近请求过的头字段从表中引用                   |
| 3  | 发送差异数据 | 只发送新字段或变化部分                      |
| 4  | 霍夫曼编码  | 对字符串再压缩                          |
| ✅  | 结果     | 头部数据量可减少 60–90%                  |

**HTTP/2 的首部压缩机制（HPACK）通过静态表、动态表和霍夫曼编码三种方式，实现头部字段的高效压缩与重用，大幅减少网络传输开销。**

</Collapse>

### 2. tcp 断开4次挥手

<Collapse>

TCP 是全双工的. 全双工（Full-duplex）：

- 即双方可以同时发送和接收数据。
- 所以连接断开时，双方都要单独关闭各自的发送方向。

假设：客户端（主动关闭连接）服务器（被动关闭连接）

通信结束时，断开过程如下：

| 步骤 | 方向        | 报文标志位   | 说明                   |
| -- | --------- | ------- | -------------------- |
| ①  | 客户端 → 服务器 | `FIN=1` | 客户端请求关闭发送通道          |
| ②  | 服务器 → 客户端 | `ACK=1` | 服务器确认接收              |
| ③  | 服务器 → 客户端 | `FIN=1` | 服务器也关闭发送通道           |
| ④  | 客户端 → 服务器 | `ACK=1` | 客户端确认接收，进入 TIME_WAIT |

```
客户端 (Client)                             服务器 (Server)
------------------                          ------------------

   ESTABLISHED                                  ESTABLISHED
        |                                              |
        | ① FIN=1, seq=u                              |
        |--------------------------------------------->|
        |                                              |
        |                           收到 FIN, 发 ACK=1, ack=u+1
        | ②                                            |
        |<---------------------------------------------|
        |                                              |
        |                           服务器继续处理剩余数据
        |                                              |
        |                           ③ FIN=1, seq=v    |
        |<---------------------------------------------|
        | ④ ACK=1, ack=v+1                             |
        |--------------------------------------------->|
        |                                              |
   TIME_WAIT(等待2MSL)                          CLOSED
        |
   连接彻底关闭
```

客户端最后要 等待 2×MSL（Maximum Segment Lifetime） 时间，约几十秒。

作用：

- 确保服务器收到最终 ACK
  - 若 ACK 丢失，服务器会重发 FIN。
  - 客户端在 TIME_WAIT 状态还能重发 ACK。

- 防止旧连接残余报文影响新连接
  - 等待 MSL 确保网络中旧包都过期。

1. 为什么关闭要四次，而不是三次？
因为 TCP 是全双工：

- 一方关闭发送，不代表另一方也关闭；
- 必须双方都各自发送 FIN，确认关闭。

2. 为什么客户端要 TIME_WAIT？

防止最后的 ACK 丢失，确保连接彻底关闭。
另外，避免旧连接的数据干扰新连接。

3. 为什么是 “2MSL”？

因为：
一个 MSL 是一个报文在网络中能存活的最长时间；
等 2×MSL，确保往返的所有旧报文都消失。

4. 如果服务器先关闭会怎样？

流程相同，只是角色对调。
谁主动关闭，谁就经历 TIME_WAIT。

</Collapse>

### 3. 什么是队头阻塞

<Collapse>

队头阻塞就是“队列第一个请求卡住，后面全被拖延”。HTTP/3 通过 QUIC 彻底缓解了这个问题。

</Collapse>

### 4. http 2 多路复用

<Collapse>

HTTP/1.1 每个请求都必须建立在一个 TCP 连接上。虽然它支持“Keep-Alive”长连接，但仍然有两个性能瓶颈：

- 队头阻塞（Head-of-Line Blocking）: 一个连接中，请求是串行执行的。前一个响应没回来，后面的请求必须等。
- 多连接并发受限: 浏览器为同一域名通常只能同时开 6 个 TCP 连接，多了也被限制。
- 📦 头部重复传输: 每次请求都要携带大量相同的 Header（如 cookie、user-agent）。

在一个 TCP 连接上，同时并发多个 HTTP 请求与响应。

工作方式：

1. 所有请求和响应都被拆分成小块（frame）。
2. 每个请求分配一个唯一的 Stream ID。
3. 这些 frame 被交错（交织）发送，在同一个 TCP 连接中同时传输。
4. 接收端再根据 Stream ID 把它们拼回原样。

举个例子：
假设浏览器要加载三个资源：

```
index.html
style.css
main.js

```

HTTP/1.1：

- 3 个请求需要占用 3 个 TCP 连接；
- 或者 1 个连接按顺序：html → css → js；
- 前面的慢了，后面的全卡住（队头阻塞）。

HTTP/2：

- 所有请求共用 1 个 TCP 连接；
- 三个请求的 frame 被交错发送；
- 谁先返回数据就先解析，完全并行。

多路复用消除了 HTTP 层阻塞，但 TCP 层仍可能受丢包影响。

**HTTP/2 多路复用 = 一个连接里同时传多条请求流，互不阻塞，性能飞升。**

</Collapse>


### 5. DNS 协议

<Collapse>

DNS（Domain Name System） 是一个将 域名 ↔ IP 地址 相互映射的分布式系统。


因为：用户容易记住 www.example.com;计算机只能识别 93.184.216.34;DNS 让我们可以使用域名访问网站，系统自动帮你找到正确的 IP。

DNS 解析的完整流程:

- 浏览器缓存: 先查本地 DNS 缓存（比如上次访问过)
- 操作系统缓存: 如果浏览器里没有，就问操作系统的 DNS 缓存。
- hosts 文件: 操作系统先查 hosts 文件，看看是否有手动配置。
- 本地 DNS 服务器（递归解析器）: 一般由 ISP（网络运营商）提供，比如 8.8.8.8（Google）、114.114.114.114（中国电信）。
- 递归查询（DNS 服务器帮你查到底）

DNS 通常使用 UDP 53 端口（查询），TCP 用于传输大数据量（如区域传送）。

每条 DNS 记录都有一个 TTL（Time To Live） 值，比如 300 秒。


</Collapse>


### 6. html script defer 与async


<Collapse>


| 特性             | `<script async> `                                          | `<script defer>`                                                    |
| ---------------- | -------------------------------------------------------- | ------------------------------------------------------------------ |
| 加载时机 (Loading) | 立即加载（与 HTML 解析并行）                                | 立即加载（与 HTML 解析并行）                                         |
| 执行时机 (Execution) | 文件下载完成后立即执行                                      | 等待整个 HTML 文档解析完成后再执行                                    |
| 执行顺序          | 不保证顺序。哪个文件先下载完，哪个先执行。                     | 保证顺序。按在文档中出现的顺序依次执行。                               |
| 是否阻塞 HTML     | 会。文件执行时会暂停 HTML 解析。                              | 不会。保证在 HTML 解析完成后才执行。                                   |
| 适用场景          | 适用于独立脚本，不依赖 DOM，也不被其他脚本依赖（如统计脚本）。      | 适用于依赖 DOM 或被其他 defer 脚本依赖的脚本（如应用主逻辑脚本）。         |


</Collapse>


### 7. HTTP/3

<Collapse>

**HTTP/3 = HTTP/2 + QUIC(UDP)**

HTTP/3 是继 HTTP/2 之后的下一代超文本传输协议。它的核心变化是：**不再基于 TCP，而是基于 QUIC（UDP 之上的新协议）。**

| 协议           | 传输层           | 特点            | 存在问题           |
| ------------ | ------------- | ------------- | -------------- |
| **HTTP/1.1** | TCP           | 简单、可靠         | 多连接、阻塞严重       |
| **HTTP/2**   | TCP           | 多路复用、头部压缩     | TCP 队头阻塞无法彻底解决 |
| **HTTP/3**   | **UDP（QUIC）** | 多路复用、内置加密、低延迟 | 部分老设备不兼容 UDP   |


QUIC（UDP）的优势

QUIC 直接运行在 UDP 之上，自己实现可靠传输 + 拥塞控制 + 加密：
- 消除队头阻塞：每个流独立传输，不互相影响
- 1-RTT 握手（甚至 0-RTT）
- 连接可迁移（基于 Connection ID）
- 内置 TLS 1.3 加密（强制 HTTPS）

```
// HTTP/2
HTTP/2
  ↓
  TLS
  ↓
  TCP
  ↓
  IP

// HTTP/3
HTTP/3
  ↓
  QUIC (内含TLS 1.3 + 可靠传输)
  ↓
  UDP
  ↓
  IP

```

</Collapse>



### 8. nginx proxy_pass 与location 结尾加不加 / 对路径的影响

<Collapse>

**尾斜杠“决定路径拼接规则”** ,location 和 proxy_pass 的结尾 是否带 /，直接决定了 Nginx 如何拼接请求路径。

proxy_pass 加不加 /:

- 不加 /：location 匹配的路径会被完整拼接到 proxy_pass 地址后（适合后端接口路径与前端请求路径完全一致的场景）。
- 加 /：location 匹配的路径会被替换为 /，仅将剩余路径拼接到 proxy_pass 地址后（适合需要简化后端接口路径的场景）。

参考: 
|  情形 | `location` 配置 | `proxy_pass` 配置        | 请求示例       | 转发给上游的路径                 | 说明                          |
| :-: | :------------ | :--------------------- | :--------- | :----------------------- | :-------------------------- |
|  1  | `/api`（不带斜杠）  | `http://backend`（不带斜杠） | `/api/foo` | `http://backend/api/foo` | 保留原始路径 `/api/foo`。          |
|  2  | `/api`（不带斜杠）  | `http://backend/`（带斜杠） | `/api/foo` | `http://backend//foo`    | 去除 `/api` 前缀后拼接，产生双斜杠。      |
|  3  | `/api/`（带斜杠）  | `http://backend`（不带斜杠） | `/api/foo` | `http://backend/api/foo` | 保留 `/api/` 前缀。              |
|  4  | `/api/`（带斜杠）  | `http://backend/`（带斜杠） | `/api/foo` | `http://backend/foo`     | 去除 `/api/` 前缀后拼接，结果 `/foo`。 |


</Collapse>


### 9. nginx多域名隔离, 同域名不同路径映射

<Collapse>

Nginx 可以通过 include 指令或虚拟主机（vhost）实现前端多环境（如开发、测试、生产）的隔离部署，同时针对同域名不同路径的映射场景，需要处理路径重写和资源引用问题

多环境隔离的核心是为不同环境（如 dev、test、prod）配置独立的 Nginx 规则，避免互相干扰。
1. 基于 include 指令的多环境配置（推荐）
  - 适合单服务器部署多个环境，通过拆分配置文件实现隔离，便于维护。
  - 也适合单服务部署多域名环境

2. 基于虚拟主机（vhost）的多环境配置
```nginx
http {
    # 开发环境（域名区分）
    server {
        listen 80;
        server_name dev.example.com;  # 开发环境域名
        root /path/to/frontend/dev;
        # ... 其他配置（路由、代理等）
    }

    # 测试环境（端口区分）
    server {
        listen 8081;  # 测试环境端口
        server_name localhost;
        root /path/to/frontend/test;
        # ... 其他配置
    }

    # 生产环境（HTTPS）
    server {
        listen 443 ssl;
        server_name example.com;  # 生产环境域名
        root /path/to/frontend/prod;
        # ... SSL 配置和其他生产环境特有的规则
    }
}
```

同域名不同路径映射的重写问题及解决方案

当多个前端应用部署在同一域名的不同路径下（如 example.com/app1、example.com/app2），需要解决路径映射和资源引用的问题。

```nginx
server {
    listen 80;
    server_name example.com;
    root /var/www;  # 父目录

    # 应用 A：匹配 /app1 路径
    location /app1 {
        # 实际文件目录为 /var/www/app1
        alias /var/www/app1;  # 注意：这里用 alias 而非 root（关键区别）
        index index.html;

        # 解决 History 路由刷新 404
        try_files $uri $uri/ /app1/index.html;
    }

    # 应用 B：匹配 /app2 路径
    location /app2 {
        alias /var/www/app2;
        index index.html;
        try_files $uri $uri/ /app2/index.html;
    }
}
```
关键区别：alias vs root

root /var/www：请求 /app1/static/css.css 会映射到 /var/www/app1/static/css.css（拼接完整路径）。
alias /var/www/app1：请求 /app1/static/css.css 会直接映射到 /var/www/app1/static/css.css（替换 /app1 为实际目录），更适合子路径部署。

</Collapse>





### 其他

- HTTP/1.1
  - 特点: 持久连接 (Keep-Alive);管道化 (Pipelining);多连接并发;头部冗余;
  - 问题: 队头阻塞、连接利用率低、头部冗余。
- HTTP2
  - 特点: 二进制分帧 (Binary Framing);多路复用 (Multiplexing);头部压缩 (HPACK);服务端推送 (Server Push);
  - 改进点：减少延迟、提升带宽利用率。
  - 问题: 因为仍然基于 TCP，丢包时所有流都要等，TCP 层仍然存在 队头阻塞
- HTTP/3
  - 特点: 基于 QUIC 协议（UDP 上实现）;内置 TLS 1.3 加密;更快的连接建立;多路复用天然支持;

- TLS/SSL: 加密（防止窃听）;身份认证（确认服务端身份）;完整性校验（防止篡改）

- HTTPS 是在 HTTP 与 TCP 之间加入了TLS/SSL层，保证了通信的安全性。它通过数字证书验证服务器身份，用非对称加密实现安全的密钥交换，然后使用对称加密进行高效的数据传输。TLS 1.3 相比 TLS 1.2，减少了握手延迟并提升了安全性。

- TLS 握手过程: ClientHello(浏览器发起握手，请求支持的加密算法、随机数), ServerHello(服务器选择加密算法，返回随机数和 数字证书（包含公钥）),验证证书(浏览器验证证书是否可信（CA 签发、域名匹配、未过期）), 密钥交换(浏览器用服务器公钥加密一个“对称会话密钥”，发给服务器。服务器用私钥解密，拿到对称密钥。), 建立安全通信(后续通信用对称加密（如 AES, ECC），保证性能)

- TCP 特点: 传输控制协议：面向连接的，可靠的，基于字节流的传输层通信协议.(基于连接的,字节流,流量缓冲,可靠的传输服务,拥塞控制)

- SYN: 握手, ACK 应答, FIN 断开
