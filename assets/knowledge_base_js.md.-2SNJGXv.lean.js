import{_ as i,I as r,c as d,o,ah as u,J as e,j as l,w as s,a as n}from"./chunks/framework.fGi7qB65.js";const S=JSON.parse('{"title":"JS 知识","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/base/js.md","filePath":"knowledge/base/js.md"}'),p={name:"knowledge/base/js.md"};function c(h,t,m,b,g,k){const a=r("Collapse");return o(),d("div",null,[t[7]||(t[7]=u("",41)),e(a,null,{default:s(()=>[...t[0]||(t[0]=[l("p",null,"(ES Module (ESM) 的 import 是编译期就确定依赖关系;ESM 默认是 严格模式，并且是 异步加载)",-1),l("p",null,[l("strong",null,"解析阶段（Parsing）=> 加载阶段 => 实例化阶段 => 执行阶段 => 缓存")],-1),l("ul",null,[l("li",null,"为每个模块创建 模块环境记录（Module Environment Record），里面存放变量绑定, 实时绑定:如果 export 的值后来被修改，"),l("li",null,"import 端也能感知。ESM 的缓存机制是基于 URL/路径唯一性，并且在 异步上下文中生效。"),l("li",null,"esm缓存生效场景: 同一个模块被多次 import; 循环依赖(缓存的“半成品”也会存起来，这样可以避免死循环);动态 import 多次;")],-1)])]),_:1}),t[8]||(t[8]=l("h3",{id:"_12-在-js-代码中避免内存泄漏的方法",tabindex:"-1"},[n("12. 在 JS 代码中避免内存泄漏的方法? "),l("a",{class:"header-anchor",href:"#_12-在-js-代码中避免内存泄漏的方法","aria-label":"Permalink to “12. 在 JS 代码中避免内存泄漏的方法?”"},"​")],-1)),e(a,null,{default:s(()=>[...t[1]||(t[1]=[l("ol",null,[l("li",null,"释放不再需要的引用(把对象置 null 或者移除属性，就能让 GC 正常回收。)"),l("li",null,"避免全局变量"),l("li",null,"小心闭包(闭包会一直保持引用,导致无法回收对象)"),l("li",null,"定时器 / 事件监听要清理"),l("li",null,"使用 WeakMap / WeakSet 存放临时对象"),l("li",null,"避免 JSON.stringify 大对象"),l("li",null,"复用对象 / 数组"),l("li",null,"按需加载数据"),l("li",null,"及时释放 DOM 引用")],-1)])]),_:1}),t[9]||(t[9]=l("h3",{id:"_13-es6-继承在前-实例在后",tabindex:"-1"},[n("13. es6 “继承在前，实例在后”? "),l("a",{class:"header-anchor",href:"#_13-es6-继承在前-实例在后","aria-label":"Permalink to “13. es6 “继承在前，实例在后”?”"},"​")],-1)),e(a,null,{default:s(()=>[...t[2]||(t[2]=[l("ul",null,[l("li",null,"new 子类发生什么: 创建子类实例对象 => 设置原型 => 父类构造函数执行 => 调用子类构造函数 => 子类构造函数继续执行"),l("li",null,"先创建空实例 → 调用子类 constructor → super() 调用父类 constructor → 父类属性挂载 → 回到子类挂载属性 → 实例返回。"),l("li",null,"ES6 的 class extends 就是对寄生组合继承的语法封装")],-1)])]),_:1}),t[10]||(t[10]=l("h3",{id:"_14-script-type-module-是什么效果",tabindex:"-1"},[n('14. script type="module" 是什么效果? '),l("a",{class:"header-anchor",href:"#_14-script-type-module-是什么效果","aria-label":'Permalink to “14. script type="module" 是什么效果?”'},"​")],-1)),e(a,null,{default:s(()=>[...t[3]||(t[3]=[l("ul",null,[l("li",null,[l("code",null,'<script type="module">'),n(" 会 异步下载和解析，等 HTML 解析完成后执行，按依赖顺序执行模块代码，类似加了 defer 的普通脚本，但支持模块化特性。")]),l("li",null,[l("code",null,'<script type="module" async>'),n(" 异步,下载完成立即执行,不保证顺序 (适合独立模块，不依赖 DOM，也不依赖其他模块执行顺序，比如统计脚本或广告脚本。)")])],-1)])]),_:1}),t[11]||(t[11]=l("h3",{id:"_15-文件的软链接与硬链接",tabindex:"-1"},[n("15. 文件的软链接与硬链接? "),l("a",{class:"header-anchor",href:"#_15-文件的软链接与硬链接","aria-label":"Permalink to “15. 文件的软链接与硬链接?”"},"​")],-1)),e(a,null,{default:s(()=>[...t[4]||(t[4]=[l("ul",null,[l("li",null,"硬链接 = 同一份文件的不同名字, 删除源文件,不影响数据，数据依然可访问,"),l("li",null,"软链接 = 指向另一个文件路径的快捷方式, 删除源文件,软链接链接失效")],-1),l("p",null,"文件系统中使用一个叫做 inode（索引节点） 的结构来记录文件的真实内容。",-1),l("ul",null,[l("li",null,"硬链接: 多个文件名共享同一个 inode。"),l("li",null,"软链接: 一个独立的文件，里面保存着目标文件的路径。(更像是 Windows 的快捷方式)")],-1)])]),_:1}),t[12]||(t[12]=l("h3",{id:"_16-js-原型链-作用是什么",tabindex:"-1"},[n("16.js 原型链, 作用是什么? "),l("a",{class:"header-anchor",href:"#_16-js-原型链-作用是什么","aria-label":"Permalink to “16.js 原型链, 作用是什么?”"},"​")],-1)),e(a,null,{default:s(()=>[...t[5]||(t[5]=[l("ul",null,[l("li",null,[l("p",null,[n("原型链？ 在 JavaScript 里，每个对象都有一个隐藏属性 [[Prototype]]（通常通过 "),l("strong",null,"proto"),n(" 访问）。当我们访问一个对象的属性/方法时，如果对象本身没有，JS 引擎就会顺着 [[Prototype]] 向上找。这条由 [[Prototype]] 串起来的链路，就叫 原型链。")])]),l("li",null,[l("p",null,"原型链的作用"),l("ul",null,[l("li",null,[n("核心作用就是实现继承和共享属性/方法。 "),l("ul",null,[l("li",null,"继承机制：子对象可以通过原型链继承父对象的方法/属性。"),l("li",null,"方法复用：所有实例共享同一个方法定义，避免每次 new 都复制一份。"),l("li",null,"动态扩展：可以在运行时给 prototype 添加方法，所有实例立刻可用")])])])])],-1),l("p",null,"原型链是 JS 实现继承的机制，通过逐层查找 [[Prototype]] 来实现属性/方法共享和复用。",-1)])]),_:1}),t[13]||(t[13]=l("h3",{id:"_17-web-components",tabindex:"-1"},[n("17. web components "),l("a",{class:"header-anchor",href:"#_17-web-components","aria-label":"Permalink to “17. web components”"},"​")],-1)),e(a,null,{default:s(()=>[...t[6]||(t[6]=[l("p",null,"Web Components 是一套 浏览器原生的前端组件技术标准，让开发者能创建可复用、封装、独立于框架的组件",-1),l("ul",null,[l("li",null,[l("p",null,"Custom Elements;Shadow DOM;HTML Templates;")]),l("li",null,[l("p",null,"继承 HTMLElement , 使用 customElements")]),l("li",null,[l("p",null,"生命周期"),l("ul",null,[l("li",null,"constructor → 元素实例化"),l("li",null,"connectedCallback → 添加到 DOM"),l("li",null,"disconnectedCallback → 从 DOM 移除"),l("li",null,"attributeChangedCallback → 被观察属性变化")])]),l("li",null,[l("p",null,"属性"),l("ul",null,[l("li",null,"HTML 属性与 JS 属性双向绑定"),l("li",null,"使用 observedAttributes + attributeChangedCallback"),l("li",null,"可以通过 getter/setter 做同步映射")])]),l("li",null,[l("p",null,"自定义事件"),l("ul",null,[l("li",null,"使用 dispatchEvent(new CustomEvent(...))"),l("li",null,"穿透 Shadow DOM → composed: true"),l("li",null,"冒泡 → bubbles: true"),l("li",null,"建议只传小对象或数据引用")])]),l("li",null,[l("p",null,"插槽"),l("ul",null,[l("li",null,"提供组件可插入自定义内容的能力"),l("li",null,[l("code",null,"<slot>"),n(' 默认内容，外部可用 slot="name" 覆盖')])])]),l("li",null,[l("p",null,"属性/事件/插槽封装模式（常用技巧）"),l("ul",null,[l("li",null,"formatProps → 统一解析属性"),l("li",null,"emit → 封装 dispatchEvent，像 Vue emit"),l("li",null,"BaseComponent → 封装生命周期、属性监听、事件分发、props 解析")])]),l("li",null,[l("p",null,"优点:"),l("ul",null,[l("li",null,"原生支持;真正的封装;可复用性;互操作性;长期可用性")])]),l("li",null,[l("p",null,"缺点:"),l("ul",null,[l("li",null,"生态和工具链;样式主题化困难;基础功能;SEO;")])]),l("li",null,[l("p",null,"优化:"),l("ul",null,[l("li",null,"使用 requestAnimationFrame 节流渲染"),l("li",null,"维护虚拟 DOM / shadow DOM patch"),l("li",null,"避免深度 DOM 查询，每次 render 只更新变化部分")])])],-1)])]),_:1}),t[14]||(t[14]=l("h2",{id:"其他",tabindex:"-1"},[n("其他 "),l("a",{class:"header-anchor",href:"#其他","aria-label":"Permalink to “其他”"},"​")],-1)),t[15]||(t[15]=l("ul",null,[l("li",null,"12px 的字体只能满足 37.6% 用户的阅读体验，但如果我们将字体放大到 14px，就可以保证大约 77% 的显示器用户处于比较好的阅读体验"),l("li",null,"h5 开发尺寸可以使用 750 * 1350")],-1))])}const x=i(p,[["render",c]]);export{S as __pageData,x as default};
