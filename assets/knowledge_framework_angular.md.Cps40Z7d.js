import{_ as n,c as s,o as e,j as a,ah as t,a as i,t as p}from"./chunks/framework.fGi7qB65.js";const m=JSON.parse('{"title":"Angular","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/framework/angular.md","filePath":"knowledge/framework/angular.md"}'),r={name:"knowledge/framework/angular.md"};function o(u,l,d,c,g,f){return e(),s("div",null,[l[0]||(l[0]=a("h1",{id:"angular",tabindex:"-1"},[i("Angular "),a("a",{class:"header-anchor",href:"#angular","aria-label":"Permalink to “Angular”"},"​")],-1)),l[1]||(l[1]=a("h2",{id:"学习笔记",tabindex:"-1"},[i("学习笔记 "),a("a",{class:"header-anchor",href:"#学习笔记","aria-label":"Permalink to “学习笔记”"},"​")],-1)),a("ol",null,[a("li",null,'元素绑定动态属性使用[xxx], 绑定事件(click)="handle()", 使用 @if @for '+p()+" 等 @for 的时候使用 track 关键子绑定HTML",1)]),l[2]||(l[2]=t(`<ul><li>track 表达式允许 Angular 维护数据与页面上的 DOM 节点之间的关系。这使得 Angular 能够在数据更改时执行最少的必要 DOM 操作，从而优化性能。</li></ul><ol start="2"><li><p>父组件使用子组件, 需要 imports 子组件, 再在template内写子组件的selector</p></li><li><p>子组件获取props 使用 input() 模板使用则用xxx(), 子组件向上触发props的事件需要定义output(), 然后使用 emit 触发</p></li><li><p>Deferrable Views 可延迟视图</p><ul><li>使用 @defer 块包装注释组件以延迟加载它。</li><li>可以设置 @placeholder @loading 2个都可以设置最小时间minimum</li><li>@defer (on viewport) 添加视口触发器，以便内容在进入视口后延迟加载。</li><li></li></ul></li><li><p>NgOptimizedImage 指令可以优化图像</p></li></ol><ul><li>NgOptimizedImage 指令要求每张图片都同时具有width height这两个尺寸属性。 或者使用 fill 属性</li><li>LCP 元素是页面加载时屏幕上最大的图形元素。为了优化加载时间，请务必为“主图”或任何其他您认为可能属于 LCP 元素的图片添加 priority 属性。</li><li>可以使用providers, provideImgixLoader 指定图片加载器</li></ul><ol start="6"><li>路由使用 routerLink 跳转</li></ol><p>7.表单有2种形式:模板驱动和响应式</p><ul><li>使用 FormsModule模块; [(ngModel)] 指令完成双向绑定</li><li>使用 ReactiveFormsModule 模块, 通过 [formGroup]=&quot;profileForm&quot; 与整个form 绑定</li><li>表单验证使用 Validators 模块</li></ul><ol start="8"><li>依赖注入 (DI) 是 Angular 框架最强大的功能之一。依赖注入是指 Angular 在运行时为应用程序提供所需资源的能力。依赖项可以是服务或其他资源。</li></ol><ul><li><p>依赖注入可以用来值初始化类属性()</p></li><li><p>Angular 服务是用于封装和共享业务逻辑、工具类、数据访问和跨组件通信的类</p><ul><li>当一个组件需要一个服务时，它不会自己创建这个服务，而是在构造函数中声明它需要这个服务。Angular 的 DI 系统会自动提供一个单例（Singleton）的服务实例给组件使用。</li></ul></li></ul><ol start="9"><li><p>管道是用于在模板中转换数据的函数。通常，管道是“纯”函数，不会产生副作用。Angular 有许多实用的内置管道，你可以导入它们并在组件中使用。也可以创建自定义管道。</p></li><li><p>Styling components 样式组件</p></li></ol><ul><li>惰性加载组件下也会惰性加载</li><li>每个组件都有一个视图封装设置，用于确定框架如何限定组件样式的作用域。视图封装模式有三种： Emulated 、 ShadowDom 和 None</li><li>默认Emulated</li><li>::ng-deep 默认不封装, 变为全局样式, 不建议</li><li>ShadowDom 组件变成有风险</li><li>None 变成全局样式</li><li>支持引入外部样式. 外部样式不受模拟视图封装的影响</li></ul><p>11.输入 input() 类似props</p><ul><li>输入可以设置必须</li><li>输入可以设置转化函数</li><li>转化类型</li><li>内置转换: 将值强制转换为布尔值和数字</li><li>指定 alias 选项来更改模板中输入的名称</li></ul><p>模型输入是一种特殊类型的输入，它使组件能够将新值传播回其父组件。类似双向绑定</p><ol start="12"><li>自定义事件 output</li></ol><ul><li>与输入类似</li><li>通过 emit 触发</li></ul><ol start="13"><li><p>ng-content 类似vue3 插槽, react children</p><ul><li>支持嵌套, 默认值</li></ul></li><li><p>host 就是绑定到HTML 上的属性, 支持 style 属性绑定(css), 绑定是同步变化的 宿主元素就是你的“组件”或“指令”所依附的那个 DOM 元素。</p></li><li><p>生命周期</p></li></ol><ul><li>constructor</li><li>ngOnInit 组件的初始化逻辑, 仅执行一次,发起 API 请求、设置基于 @Input 的内部状态、订阅 Observables</li><li>ngOnChanges 响应来自父组件的数据变化</li><li>ngAfterViewInit 仅执行一次 在组件的视图 (Template) 及其所有子组件都完全初始化和渲染之后, 需要操作 DOM 的逻辑</li><li>ngOnDestroy 仅执行一次, 清理工作，防止内存泄漏</li></ul><ol start="16"><li><p>ViewChild 可以直接操作子组件的方法, 读取html</p></li><li><p>继承 Inheritance</p></li></ol><ul><li><p>继承组件 用于抽象出通用的组件逻辑, 子类基础</p></li><li><p>继承服务</p></li><li><p>继承了什么？</p><ul><li>类属性 (如 isLoading, form)</li><li>类方法 (如 resetForm(), ngOnDestroy)</li><li>@Input 和 @Output 装饰器</li><li>生命周期钩子 (如 ngOnInit, ngOnDestroy)</li></ul></li><li><p>不能继承什么?</p><ul><li>@Component 装饰器元数据： <ul><li>template 或 templateUrl 不会被继承。子组件必须提供自己的模板。</li><li>styles 或 styleUrls 不会被继承。</li><li>selector 不会被继承。</li><li>providers 不会被继承</li></ul></li></ul></li></ul><ol start="18"><li>自定义元素 用于将 Angular 组件打包成原生 Web Components 标准的自定义元素。</li></ol><p>它的核心目的是：让你在任何 HTML 环境（包括原生 JavaScript 应用、React、Vue、WordPress 等）中使用 Angular 组件，而不需要完整的 Angular 运行时环境。</p><p>@Input()属性 =&gt; HTML 属性 (Attributes) 和 DOM 属性 (Properties) @Output() 事件 =&gt; @Output() 事件 公共方法 =&gt; DOM 方法</p><ol start="19"><li>信号是对某个值的包装，当该值发生变化时，它会通知相关的消费者。信号可以包含任何值，从原始值到复杂的数据结构。</li></ol><ul><li>computed 计算是惰性求职的</li><li>effect 可以监听信号的变化, 只能定义在constructor, 可以通过其选项将 Injector 传递给 effect</li><li>effect只能在注入上下文 （可以访问 inject 函数的地方）中创建</li><li>effect 函数参数, 函数第一个参数为 onCleanup 清除副作用函数</li></ul><h3 id="angular-的-signals-底层原理是啥" tabindex="-1">Angular 的 Signals 底层原理是啥 <a class="header-anchor" href="#angular-的-signals-底层原理是啥" aria-label="Permalink to “Angular 的 Signals 底层原理是啥”">​</a></h3><p>Angular Signals 的底层本质是一套“精细依赖追踪（fine-grained reactivity）”系统，基于 值引用 + 订阅关系 + 派发更新 的机制，类似于 Reactivity Core (Vue 3) 和 SolidJS 的实现。</p><table tabindex="0"><thead><tr><th>名称</th><th>作用</th><th>类比</th></tr></thead><tbody><tr><td><code>signal()</code></td><td>创建一个可观察的值（源）</td><td>Vue 的 <code>ref()</code></td></tr><tr><td><code>computed()</code></td><td>派生值，自动追踪依赖的 signal</td><td>Vue 的 <code>computed()</code></td></tr><tr><td><code>effect()</code></td><td>产生副作用，监听信号变化</td><td>Vue 的 <code>watchEffect()</code> / SolidJS 的 <code>createEffect()</code></td></tr></tbody></table><p>Signal 的内部数据结构:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>class Signal&lt;T&gt; {</span></span>
<span class="line"><span>  private value: T;</span></span>
<span class="line"><span>  private subscribers = new Set&lt;Effect&gt;();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  get(): T {</span></span>
<span class="line"><span>    // 在依赖追踪阶段，注册依赖</span></span>
<span class="line"><span>    if (currentComputation) {</span></span>
<span class="line"><span>      currentComputation.dependencies.add(this);</span></span>
<span class="line"><span>      this.subscribers.add(currentComputation);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return this.value;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  set(newValue: T) {</span></span>
<span class="line"><span>    if (newValue !== this.value) {</span></span>
<span class="line"><span>      this.value = newValue;</span></span>
<span class="line"><span>      // 通知所有依赖此 signal 的副作用重新执行</span></span>
<span class="line"><span>      for (const eff of this.subscribers) {</span></span>
<span class="line"><span>        eff.schedule();</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>solidjs</p>`,30))])}const b=n(r,[["render",o]]);export{m as __pageData,b as default};
