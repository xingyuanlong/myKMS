<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>个人知识库</title>
    <meta name="description" content="个人知识库">
    <meta name="generator" content="VitePress v2.0.0-alpha.12">
    <link rel="preload stylesheet" href="/myKMS/assets/style.BNxtA7kc.css" as="style">
    <link rel="preload stylesheet" href="/myKMS/vp-icons.css" as="style">
    
    <script type="module" src="/myKMS/assets/app.CkxRFsqJ.js"></script>
    <link rel="preload" href="/myKMS/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/myKMS/assets/chunks/theme.fgKfk125.js">
    <link rel="modulepreload" href="/myKMS/assets/chunks/framework.fGi7qB65.js">
    <link rel="modulepreload" href="/myKMS/assets/interview_2025.md.B3xFHujW.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-304c8b69><!--[--><!--]--><!--[--><span tabindex="-1" data-v-fcbfc0e0></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-fcbfc0e0>Skip to content</a><!--]--><!----><header class="VPNav" data-v-304c8b69 data-v-d5bf7c8e><div class="VPNavBar" data-v-d5bf7c8e data-v-8eab0e6d><div class="wrapper" data-v-8eab0e6d><div class="container" data-v-8eab0e6d><div class="title" data-v-8eab0e6d><div class="VPNavBarTitle has-sidebar" data-v-8eab0e6d data-v-d4488dd0><a class="title" href="/myKMS/" data-v-d4488dd0><!--[--><!--]--><!----><span data-v-d4488dd0>个人知识库</span><!--[--><!--]--></a></div></div><div class="content" data-v-8eab0e6d><div class="content-body" data-v-8eab0e6d><!--[--><!--]--><div class="VPNavBarSearch search" data-v-8eab0e6d><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-8eab0e6d data-v-020be4db><span id="main-nav-aria-label" class="visually-hidden" data-v-020be4db> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/myKMS/" tabindex="0" data-v-020be4db data-v-815115f5><!--[--><span data-v-815115f5>Home</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/myKMS/interview/code.html" tabindex="0" data-v-020be4db data-v-815115f5><!--[--><span data-v-815115f5>面试</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/myKMS/knowledge/framework/react.html" tabindex="0" data-v-020be4db data-v-815115f5><!--[--><span data-v-815115f5>框架</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/myKMS/knowledge/browser/http.html" tabindex="0" data-v-020be4db data-v-815115f5><!--[--><span data-v-815115f5>浏览器</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-8eab0e6d data-v-3f90c1a5><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-3f90c1a5 data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-8eab0e6d data-v-ef6192dc data-v-a1a7286e><!--[--><a class="VPSocialLink no-icon" href="https://github.com/xingyuanlong/myKMS" aria-label="github" target="_blank" rel="me noopener" data-v-a1a7286e data-v-32d78712><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-8eab0e6d data-v-f953d92f data-v-d8fae6e2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-d8fae6e2><span class="vpi-more-horizontal icon" data-v-d8fae6e2></span></button><div class="menu" data-v-d8fae6e2><div class="VPMenu" data-v-d8fae6e2 data-v-fcd1d7a8><!----><!--[--><!--[--><!----><div class="group" data-v-f953d92f><div class="item appearance" data-v-f953d92f><p class="label" data-v-f953d92f>Appearance</p><div class="appearance-action" data-v-f953d92f><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-f953d92f data-v-be9742d9 data-v-b4ccac88><span class="check" data-v-b4ccac88><span class="icon" data-v-b4ccac88><!--[--><span class="vpi-sun sun" data-v-be9742d9></span><span class="vpi-moon moon" data-v-be9742d9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-f953d92f><div class="item social-links" data-v-f953d92f><div class="VPSocialLinks social-links-list" data-v-f953d92f data-v-a1a7286e><!--[--><a class="VPSocialLink no-icon" href="https://github.com/xingyuanlong/myKMS" aria-label="github" target="_blank" rel="me noopener" data-v-a1a7286e data-v-32d78712><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-8eab0e6d data-v-6bee1efd><span class="container" data-v-6bee1efd><span class="top" data-v-6bee1efd></span><span class="middle" data-v-6bee1efd></span><span class="bottom" data-v-6bee1efd></span></span></button></div></div></div></div><div class="divider" data-v-8eab0e6d><div class="divider-line" data-v-8eab0e6d></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-304c8b69 data-v-5ae341c6><div class="container" data-v-5ae341c6><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-5ae341c6><span class="vpi-align-left menu-icon" data-v-5ae341c6></span><span class="menu-text" data-v-5ae341c6>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-5ae341c6 data-v-e28a51a6><button data-v-e28a51a6>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-304c8b69 data-v-e0eef791><div class="curtain" data-v-e0eef791></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-e0eef791><span class="visually-hidden" id="sidebar-aria-label" data-v-e0eef791> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0" data-v-a84b7c21 data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h2 class="text" data-v-6b36a2fd>基础知识</h2><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/base/js.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>js</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/base/nodejs.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>node</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0 has-active" data-v-a84b7c21 data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h2 class="text" data-v-6b36a2fd>interview</h2><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/interview/2025.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>2025</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/interview/code.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>code</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/interview/index.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>开放性问题</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0" data-v-a84b7c21 data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h2 class="text" data-v-6b36a2fd>框架</h2><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/framework/react.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>react</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/framework/vue.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>vue</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/framework/vite.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>工程化</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/framework/electron.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>electron</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0" data-v-a84b7c21 data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h2 class="text" data-v-6b36a2fd>浏览器</h2><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/browser/index.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>browser</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/browser/http.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>http</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/knowledge/browser/webSecurity.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>web安全</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0" data-v-a84b7c21 data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h2 class="text" data-v-6b36a2fd>读书笔记</h2><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/book/vue_1.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>vue.js 设计与实践</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0" data-v-a84b7c21 data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h2 class="text" data-v-6b36a2fd>算法</h2><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/algorithm/index.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>总</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-a84b7c21><section class="VPSidebarItem level-0" data-v-a84b7c21 data-v-6b36a2fd><div class="item" role="button" tabindex="0" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><h2 class="text" data-v-6b36a2fd>AI</h2><!----></div><div class="items" data-v-6b36a2fd><!--[--><div class="VPSidebarItem level-1 is-link" data-v-6b36a2fd data-v-6b36a2fd><div class="item" data-v-6b36a2fd><div class="indicator" data-v-6b36a2fd></div><a class="VPLink link link" href="/myKMS/ai/index.html" data-v-6b36a2fd><!--[--><p class="text" data-v-6b36a2fd>ai</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-304c8b69 data-v-2652e39a><div class="VPDoc has-sidebar has-aside" data-v-2652e39a data-v-d668f7cc><!--[--><!--]--><div class="container" data-v-d668f7cc><div class="aside" data-v-d668f7cc><div class="aside-curtain" data-v-d668f7cc></div><div class="aside-container" data-v-d668f7cc><div class="aside-content" data-v-d668f7cc><div class="VPDocAside" data-v-d668f7cc data-v-cb998dce><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-cb998dce data-v-c8b19031><div class="content" data-v-c8b19031><div class="outline-marker" data-v-c8b19031></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-c8b19031>页面导航</div><ul class="VPDocOutlineItem root" data-v-c8b19031 data-v-b7d7ef80><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-cb998dce></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-d668f7cc><div class="content-container" data-v-d668f7cc><!--[--><!--]--><main class="main" data-v-d668f7cc><div style="position:relative;" class="vp-doc _myKMS_interview_2025" data-v-d668f7cc><div><p>pr</p><h3 id="_1-react-vue-有什么区别和相似" tabindex="-1">1. react vue 有什么区别和相似 <a class="header-anchor" href="#_1-react-vue-有什么区别和相似" aria-label="Permalink to “1. react vue 有什么区别和相似”">​</a></h3><p>对比:</p><ul><li><p>vue 编译+运行时框架, react 运行时, 所以vue 再编译时能够做很多优化(如静态标记和动态提升), react 更注重运行时, react 19 也有 React Compiler 编译优化. (svelte 纯编译 )</p></li><li><p>React：UI 库（Library），专注于 视图层，其它路由/状态管理等靠社区生态（React Router、Redux）。 Vue：渐进式框架（Framework），提供了从视图到路由、状态管理（Vue Router、Pinia/Vuex）的完整解决方案。</p></li><li><p>语法与编程范式:</p><ul><li>React：以 JavaScript/TypeScript 为核心，用 JSX 描述 UI。 更偏向函数式编程，鼓励用 Hooks 管理状态、副作用。</li><li>Vue：提供 单文件组件 (SFC)，分为 <code>&lt;template&gt; + &lt;script&gt; + &lt;style&gt;</code>。 更接近声明式和模板式编程，容易上手</li></ul></li><li><p>数据绑定</p><ul><li>React：单向数据流，props → 子组件，更新需要 setState 或 useState。</li><li>Vue：双向数据绑定 (v-model)，适合表单场景，逻辑简洁。</li></ul></li><li><p>性能优化</p><ul><li>React：依靠 shouldComponentUpdate / React.memo / useMemo / useCallback。</li><li>Vue：通过 响应式系统（Proxy + Effect 追踪依赖），自动追踪更新；还可以用 v-once、computed 优化</li></ul></li><li><p>状态管理</p><ul><li>React：依赖外部库（Redux、MobX、Zustand、Recoil 等），灵活但碎片化。</li><li>Vue：官方提供 Vuex（Vue2）/ Pinia（Vue3），统一、集成度高</li></ul></li><li><p>底层区别:</p></li></ul><p>1.核心思想</p><ul><li>React <ol><li>核心是函数式 + 状态驱动 UI：UI = f(state)。</li><li>关注数据不可变和纯函数更新。</li><li>React 本身是渲染库，路由/状态管理等能力由社区提供。</li></ol></li><li>Vue <ol><li>核心是响应式系统 + 模板编译：通过响应式追踪 + 渲染函数驱动更新。</li><li>偏向声明式与命令式相结合，易上手。</li><li>Vue 是一个完整的框架，提供更多开箱即用的能力。</li></ol></li></ul><ol start="2"><li><p>响应式机制</p><ul><li>React: 没有内置响应式，靠 useState/useReducer 触发组件更新。每次 setState 会触发组件重新渲染，然后通过虚拟 DOM diff 决定哪些节点需要更新。数据变化 → 全量渲染 → Diff → 最小化 DOM 更新。</li><li>Vue: Vue 2 使用 Object.defineProperty，Vue 3 使用 Proxy；通过精确的依赖追踪，只有用到字段的组件或计算属性会订阅该字段。数据变化 → 精确找到依赖它的组件/模板 → 只更新必要部分。</li></ul></li><li><p>虚拟 DOM &amp; 渲染</p><ul><li>React: 使用 Fiber 架构（从 v16 开始）。每个组件对应一个 Fiber 节点，支持异步可中断渲染（time slicing、并发模式），强调调度与优先级，确保 UI 流畅。</li><li>Vue: Vue 3 借助编译期优化和 Block Tree（静态提升 + 动态节点追踪）。模板在编译时划分为“静态节点 + 动态节点”，更新时只 diff 动态部分。Vue 3.6 引入的 Vapor Mode 甚至尝试跳过虚拟 DOM，生成更精确的更新代码。</li></ul></li><li><p>调度机制</p><ul><li>React：有完整的 Scheduler，支持优先级队列（用户交互优先、网络渲染延后）和并发渲染（Concurrent Mode）。</li><li>Vue：内置异步队列 + nextTick，保证数据更新合并（批量刷新），调度相对简单，不区分复杂优先级。</li></ul></li><li><p>渲染层抽象</p><ul><li>React: ReactDOM 是一个渲染器，底层渲染器可替换（React Native、Ink、three-fiber），通过 Reconciler + Renderer 解耦。</li><li>Vue: Vue 3 同样有 Renderer 抽象（runtime-core + runtime-dom），官方维护 DOM 渲染器及其它平台的渲染器，但 React 在多端渲染生态上更成熟。</li></ul></li><li><p>生态设计</p><ul><li>React：小核 + 强社区，灵活且可扩展（例如 React Native、Next.js、Remix 等）。</li><li>Vue：整体框架理念，内置响应式和编译器，适合小团队和中台项目，使用体验更统一。</li></ul></li></ol><p>相似性</p><ul><li>都是 UI 层框架，专注视图</li><li>都基于 数据驱动视图</li><li>都通过 虚拟 DOM 进行高效 DOM 更新</li><li>都是 组件化开发，支持递归组合</li><li>父 → 子（props）单向数据流 保证数据可预测性</li><li>都有 生命周期钩子</li><li>都支持 SSR / SSG / CSR 混合渲染</li><li>都在追求 更细粒度更新和并发渲染</li><li>都支持跨平台渲染</li></ul><h3 id="_2-qiankun" tabindex="-1">2.qiankun <a class="header-anchor" href="#_2-qiankun" aria-label="Permalink to “2.qiankun”">​</a></h3><ul><li><p>js 隔离: 1.SnapshotSandbox（快照沙箱）: 在应用切换前，把 window 的状态做一份快照。子应用运行时，修改的全局变量只保存在自己的快照里。卸载子应用时，还原 window。缺点：只能同时激活一个子应用（适合单实例场景）。</p><p>2.ProxySandbox（代理沙箱） 基于 ES6 Proxy 拦截子应用对全局对象的读写。每个子应用有一个独立的代理对象作为 window，实际访问 window.xxx 时，会优先读写子应用自己的代理上下文。多个子应用可并行运行，互不影响。</p><p>qiankun 默认在支持 Proxy 的浏览器下使用这个方案</p></li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>const fakeWindow = {};</span></span>
<span class="line"><span>const proxy = new Proxy(window, {</span></span>
<span class="line"><span>        get(target, key) {</span></span>
<span class="line"><span>        return key in fakeWindow ? fakeWindow[key] : target[key];</span></span>
<span class="line"><span>},</span></span>
<span class="line"><span>set(target, key, value) {</span></span>
<span class="line"><span>        fakeWindow[key] = value;</span></span>
<span class="line"><span>        return true;</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>});</span></span></code></pre></div><ul><li><p>样式隔离:</p><ol><li>严格样式隔离: Shadow DOM 兼容性不好</li><li>实验性样式隔离（样式前缀）:通过 ScopedCSS 插件，在运行时动态给子应用 CSS 加上前缀（比如 [data-qiankun=&quot;xxx&quot;]）。确保样式只影响当前子应用的 DOM。原理类似 Vue 的 scoped 样式，但是在运行时做。</li><li>css BEM, PostCSS 插件</li></ol></li></ul><h3 id="_3-amis-表单联动" tabindex="-1">3. amis 表单联动 <a class="header-anchor" href="#_3-amis-表单联动" aria-label="Permalink to “3. amis 表单联动”">​</a></h3><ol><li>给某个表单项绑定 onChange，当值变化时更新另一个表单项。</li><li>如果是展示或可用性联动 visibleOn / disabledOn</li></ol><h3 id="_4-vite-插件" tabindex="-1">4.vite 插件 <a class="header-anchor" href="#_4-vite-插件" aria-label="Permalink to “4.vite 插件”">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>import type { Plugin } from &#39;vite&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function myPlugin(options?): Plugin {</span></span>
<span class="line"><span>  return {</span></span>
<span class="line"><span>    name: &#39;my-plugin&#39;,  // **必须**有 name，方便调试</span></span>
<span class="line"><span>    // enforce: &#39;pre&#39; 或 &#39;post&#39;（可选），指定此插件执行顺序</span></span>
<span class="line"><span>    config(config, { command }) {</span></span>
<span class="line"><span>      // 修改 Vite / Rollup 配置（可选）</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>    configResolved(resolvedConfig) {</span></span>
<span class="line"><span>      // 当最终 config 确定后执行</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>    resolveId(source, importer) {</span></span>
<span class="line"><span>      // 自定义模块解析逻辑</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>    load(id) {</span></span>
<span class="line"><span>      // 如果你要“自己加载一个模块”，返回内容</span></span>
<span class="line"><span>      // 否则返回 null 让后续钩子 /默认流程处理</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>    transform(code, id) {</span></span>
<span class="line"><span>      // 转换模块源代码，返回 { code, map } 或 string</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>    handleHotUpdate(ctx) {</span></span>
<span class="line"><span>      // 在开发服务下，处理 HMR 热更新逻辑</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>    // 构建阶段钩子</span></span>
<span class="line"><span>    buildStart() { },</span></span>
<span class="line"><span>    generateBundle(options, bundle, isWrite) { },</span></span>
<span class="line"><span>    writeBundle() { },</span></span>
<span class="line"><span>    closeBundle() { },</span></span>
<span class="line"><span>  };</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>// 替换模板的一个字</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>export default function replaceTextPlugin(options = { search: &#39;FOO&#39;, replace: &#39;BAR&#39; }) {</span></span>
<span class="line"><span>  return {</span></span>
<span class="line"><span>    name: &#39;vite-plugin-replace-text&#39;,</span></span>
<span class="line"><span>    enforce: &#39;pre&#39;,</span></span>
<span class="line"><span>    transform(code, id) {</span></span>
<span class="line"><span>      if (/\.(js|ts|jsx|tsx)$/.test(id)) {</span></span>
<span class="line"><span>        return code.replace(new RegExp(options.search, &#39;g&#39;), options.replace);</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>      return null;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  };</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>// 统计TODO</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>import fs from &#39;fs&#39;;</span></span>
<span class="line"><span>import path from &#39;path&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>export function vitePluginTodo() {</span></span>
<span class="line"><span>  const todos = [];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  function scanFile(filePath) {</span></span>
<span class="line"><span>    const code = fs.readFileSync(filePath, &#39;utf-8&#39;);</span></span>
<span class="line"><span>    const lines = code.split(&#39;\n&#39;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    lines.forEach((line, index) =&gt; {</span></span>
<span class="line"><span>      const todoMatch = line.match(/\/\/\s*TODO\s*:(.*)/i) </span></span>
<span class="line"><span>                     || line.match(/\/\*\s*TODO\s*:(.*)\*\//i);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      if (todoMatch) {</span></span>
<span class="line"><span>        todos.push({</span></span>
<span class="line"><span>          file: path.relative(process.cwd(), filePath),</span></span>
<span class="line"><span>          line: index + 1,</span></span>
<span class="line"><span>          content: todoMatch[1].trim(),</span></span>
<span class="line"><span>        });</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>    });</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  function scanDir(dir) {</span></span>
<span class="line"><span>    const entries = fs.readdirSync(dir, { withFileTypes: true });</span></span>
<span class="line"><span>    for (const entry of entries) {</span></span>
<span class="line"><span>      const fullPath = path.join(dir, entry.name);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      if (entry.isDirectory()) {</span></span>
<span class="line"><span>        if (entry.name === &#39;node_modules&#39; || entry.name.startsWith(&#39;.&#39;)) continue;</span></span>
<span class="line"><span>        scanDir(fullPath);</span></span>
<span class="line"><span>      } else if (/\.(ts|js|tsx|jsx|vue)$/.test(entry.name)) {</span></span>
<span class="line"><span>        scanFile(fullPath);</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  console.log(&#39;vite-plugin-todo&#39;);</span></span>
<span class="line"><span>  return {</span></span>
<span class="line"><span>    name: &#39;vite-plugin-todo&#39;,</span></span>
<span class="line"><span>    apply: &#39;build&#39;,</span></span>
<span class="line"><span>    buildStart() {</span></span>
<span class="line"><span>      console.log(&#39;vite-plugin-todo buildStart&#39;);</span></span>
<span class="line"><span>      todos.length = 0;</span></span>
<span class="line"><span>      scanDir(process.cwd());</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>    closeBundle() {</span></span>
<span class="line"><span>      if (todos.length &gt; 0) {</span></span>
<span class="line"><span>        console.log(&#39;\n💡 TODO List:&#39;);</span></span>
<span class="line"><span>        todos.forEach(todo =&gt; {</span></span>
<span class="line"><span>          console.log(`${todo.file}:${todo.line} - ${todo.content}`);</span></span>
<span class="line"><span>        });</span></span>
<span class="line"><span>      } else {</span></span>
<span class="line"><span>        console.log(&#39;\n✅ No TODO found.&#39;);</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  };</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="_5-webpack-和-vite-的区别" tabindex="-1">5. webpack 和 vite 的区别 <a class="header-anchor" href="#_5-webpack-和-vite-的区别" aria-label="Permalink to “5. webpack 和 vite 的区别”">​</a></h3><ol><li>Webpack：老牌的 打包器，把所有依赖打包成一个或多个 bundle。</li><li>Vite：新一代 前端构建工具，开发环境利用浏览器的 原生 ES 模块 (ESM)，生产环境用 Rollup 打包。</li></ol><p>1.开发模式 Webpack： 启动时必须 先打包整个项目，再启动 dev server。 启动速度和项目体积成正比。 Vite： 启动时 不打包业务代码，依赖用 esbuild 预构建，源码按需编译。 启动速度几乎和项目体积无关，大型项目也能秒开。</p><pre><code>    👉 一句话：Webpack = 打包后再跑，Vite = 边跑边编译。
</code></pre><ol start="2"><li><p>热更新（HMR） webpack：基于打包产物 diff，大型项目热更新会卡顿。 Vite：直接基于 ESM 精确替换模块，更新速度更快。</p></li><li><p>生产构建 Webpack：开发和生产都用自家打包逻辑。 Vite：开发用 esbuild + ESM，生产用 Rollup 打包（Tree-shaking 更强，但生态不如 Webpack 丰富）。</p></li><li><p>配置与生态 Webpack：配置复杂但灵活。loader + plugin 生态极其成熟。 Vite：开箱即用，配置简单。插件体系基于 Rollup，生态在快速增长。</p></li></ol><p>Webpack 是基于打包的老牌全能工具，功能强大但启动和热更新慢；Vite 利用 ESM 和 esbuild，开发体验好、速度快，生产打包用 Rollup。</p><h3 id="_6-react-fiber-架构" tabindex="-1">6. React Fiber 架构 <a class="header-anchor" href="#_6-react-fiber-架构" aria-label="Permalink to “6. React Fiber 架构”">​</a></h3><p>Fiber 是 React 对 虚拟 DOM 渲染机制的重写，它的核心目标是：支持可中断的渲染和任务优先级调度，从而改善大型应用的渲染性能和用户体验。简单理解就是：把更新任务拆成可中断的小单元，按优先级调度执行。</p><p>Fiber 的数据结构: Fiber 是一个链表/树形结构，每个 Fiber 节点对应一个 React 元素或组件。</p><p>双阶段渲染（两阶段 Reconciliation）:Fiber 实现了 可中断渲染，把渲染分为两个阶段：</p><ul><li>Render 阶段（Reconciliation, 构建 Fiber 树，比较新旧 Fiber 树，生成 effect list（要更新的副作用列表）。可以中断、按优先级切分任务。不直接修改 DOM。</li><li>Commit 阶段:遍历 effect list，将副作用应用到真实 DOM。是同步执行的，一旦开始就不能中断。包括挂载、更新、删除 DOM.</li></ul><p>调度与优先级:Fiber 内置 任务调度器，任务分为不同优先级：同步任务（高优先级，如点击事件);动画任务异步任务（低优先级，如网络请求完成后的渲染）通过分片（time slicing）和 requestIdleCallback / requestAnimationFrame，保证 UI 不被阻塞</p><ul><li><p>Fiber 为什么要出现？</p><ul><li>为了解决 React 15 的同步渲染阻塞问题，支持可中断渲染和任务优先级。</li></ul></li><li><p>Fiber 树 vs 虚拟 DOM 树区别？</p><ul><li>虚拟 DOM 树只表示 UI 元素结构。</li><li>Fiber 树表示元素 + 组件 + 更新状态 + 优先级 + 副作用列表，更复杂。</li></ul></li><li><p>Render 阶段和 Commit 阶段有什么区别？</p><ul><li>Render 阶段：可中断、生成 effect list，不触碰 DOM。</li><li>Commit 阶段：同步执行、应用 effect，修改真实 DOM</li></ul></li></ul><hr><p>jc</p><h3 id="_7-单点登录" tabindex="-1">7. 单点登录: <a class="header-anchor" href="#_7-单点登录" aria-label="Permalink to “7. 单点登录:”">​</a></h3><p>用户在一个系统上登录后，就能无感知地访问其他关联系统，无需再次登录。</p><ul><li><p>统一身份认证中心（Identity Provider, IdP）</p><ul><li>用户只在认证中心登录一次。</li><li>认证中心负责验证用户名/密码、签发令牌（如 JWT、SAML、OAuth2 Token）。</li></ul></li><li><p>业务系统（Service Provider, SP）</p><ul><li>用户访问业务系统时，业务系统会跳转到认证中心校验。</li><li>认证成功后，认证中心返回一个「登录凭证」（Token / Ticket）。</li><li>业务系统验证凭证后，允许用户访问。</li></ul></li><li><p>Cookie + Session（早期）</p><ul><li>依赖共享 Cookie（要求同域或二级域名一致）。</li><li>局限性大，不适合跨域。</li></ul></li><li><p>Token（JWT / OAuth2 / OpenID Connect）（主流）</p><ul><li>用户认证成功后，认证中心签发 Token。</li><li>各系统通过 Token 识别用户，支持跨域、跨平台。</li></ul></li></ul><h3 id="_8-状态管理redux-mobx-pinna-设计模式是啥-区别是啥" tabindex="-1">8.状态管理redux mobx pinna 设计模式是啥？区别是啥 <a class="header-anchor" href="#_8-状态管理redux-mobx-pinna-设计模式是啥-区别是啥" aria-label="Permalink to “8.状态管理redux mobx pinna 设计模式是啥？区别是啥”">​</a></h3><table tabindex="0"><thead><tr><th>维度</th><th>Redux</th><th>MobX</th><th>Pinia</th></tr></thead><tbody><tr><td>状态更新方式</td><td>不可变 + reducer</td><td>可变 + observable</td><td>可变 + reactive</td></tr><tr><td>阅读 /可预测性</td><td>高（统一入口）</td><td>较低（更新处散落）</td><td>较中等 /接近 Vue 响应式方式</td></tr><tr><td>异步 /副作用管理</td><td>通过中间件（thunk / saga）</td><td>action / reaction / autorun</td><td>普通 action + 插件 /订阅</td></tr><tr><td>模块化</td><td>使用 reducer 组合拆分</td><td>多 store / classes</td><td>天生模块 store</td></tr><tr><td>学习成本</td><td>较高</td><td>较低</td><td>中等（依赖 Vue 响应式理解）</td></tr><tr><td>调试工具 / 时间旅行</td><td>强支持（Redux DevTools）</td><td>有 MobX DevTools、reaction 日志等</td><td>Pinia Devtools /插件支持</td></tr><tr><td>适合场景</td><td>大型复杂状态，团队协作</td><td>快速开发、响应性重 UI</td><td>Vue 应用 / Composition API 生态</td></tr></tbody></table><table tabindex="0"><thead><tr><th>库</th><th>核心模式</th><th>特点</th></tr></thead><tbody><tr><td>Redux</td><td>发布-订阅 + 单例模式 + 函数式编程</td><td>可预测、严格、样板代码多</td></tr><tr><td>MobX</td><td>观察者模式 + 响应式 + 面向对象(OOP)</td><td>简洁直观、自动追踪依赖、灵活</td></tr><tr><td>Pinia</td><td>观察者模式 + 依赖注入 + 组合模式</td><td>结合 Vue3 响应式系统，轻量优雅</td></tr></tbody></table><p>观察者模式 与 发布-订阅模式（格式化）</p><table tabindex="0"><thead><tr><th>模式</th><th>是否有中介</th><th>耦合度</th><th>典型场景</th></tr></thead><tbody><tr><td>观察者模式 (Observer)</td><td>❌ 没有中介</td><td>相对紧耦合</td><td>UI 响应数据变化（如 Vue2）</td></tr><tr><td>发布-订阅模式 (Pub/Sub)</td><td>✅ 有中介</td><td>松耦合</td><td>事件总线、跨模块通信、消息队列</td></tr></tbody></table><p>概念要点：</p><ul><li><p>观察者模式（Observer）</p><ul><li>结构：有一个目标对象（Subject），维护观察者列表；状态变化时主动通知所有观察者。</li><li>特点：点对点通知，被观察者需要知道其观察者；适合一对多、紧密协作场景。</li></ul></li><li><p>发布-订阅模式（Publish‑Subscribe）</p><ul><li>结构：引入消息中间件/事件中心，发布者发布事件到中间件，订阅者从中间件订阅事件。</li><li>特点：发布者与订阅者解耦，扩展性强，适合多对多和跨模块通信。</li></ul></li></ul><p>对比总结：</p><ul><li>耦合：Observer 更紧耦合（Subject 知道 observers）；Pub/Sub 更松耦合（通过中介解耦）。</li><li>可扩展性：Pub/Sub 更易扩展和复用；Observer 更简单、直接，适合 UI 内部数据驱动场景。</li></ul><p>观察者模式（简要结构示例）</p><ul><li>Subject: 维护 observers 列表，提供 register / unregister / notify 方法。</li><li>Observer: 实现 update 接口，接收通知并更新自身。</li></ul><p>发布-订阅模式（简要结构示例）</p><ul><li>EventBus（中介）: on / off / emit。</li><li>发布者: emit(event, payload)。</li><li>订阅者: on(event, handler)。</li></ul><h3 id="_9-如果一个项目-使用了antd-组件库-又使用了antd-2次开发组件库-会不会有问题" tabindex="-1">9. 如果一个项目 使用了antd 组件库, 又使用了antd 2次开发组件库 会不会有问题 <a class="header-anchor" href="#_9-如果一个项目-使用了antd-组件库-又使用了antd-2次开发组件库-会不会有问题" aria-label="Permalink to “9. 如果一个项目 使用了antd 组件库, 又使用了antd 2次开发组件库 会不会有问题”">​</a></h3><ol><li>样式冲突, 可以通过修改命名前缀区分</li><li>ConfigProvider 全局化配置也可能会冲突</li></ol><h3 id="_10-页面卡顿-内存泄露排查" tabindex="-1">10. 页面卡顿，内存泄露排查 <a class="header-anchor" href="#_10-页面卡顿-内存泄露排查" aria-label="Permalink to “10. 页面卡顿，内存泄露排查”">​</a></h3><table tabindex="0"><thead><tr><th>现象</th><th>原因可能性</th></tr></thead><tbody><tr><td>页面卡顿 / 帧率低 /响应迟钝</td><td>JS 执行时间过长、频繁重绘/重排、布局触发、事件处理阻塞、定时器或循环、垃圾回收暂停</td></tr><tr><td>内存持续上涨不降 /长时间运行后越来越慢</td><td>内存泄漏：一些对象、DOM、回调、事件监听器、定时器等未被释放仍被引用</td></tr></tbody></table><table tabindex="0"><thead><tr><th>阶段</th><th>目标</th><th>使用工具</th><th>主要操作</th><th>关键观察点</th><th>可能问题 /风险</th></tr></thead><tbody><tr><td><strong>1️⃣ 确认问题</strong></td><td>复现卡顿或内存异常的场景</td><td>浏览器、用户日志、监控平台</td><td>收集用户反馈、复现路径、操作步骤</td><td>卡顿是否规律出现 / 内存是否持续上涨</td><td>确认是性能问题而非业务阻塞</td></tr><tr><td><strong>2️⃣ 初步检测</strong></td><td>判断是卡顿还是内存泄漏</td><td>Chrome DevTools → <strong>Performance Monitor</strong></td><td>观察 FPS、CPU、JS Heap、DOM Node 数量变化</td><td>Heap、Node 数持续上升</td><td>存在潜在泄漏或渲染过频</td></tr><tr><td><strong>3️⃣ 拍快照分析</strong></td><td>捕获堆内对象状态</td><td>DevTools → <strong>Memory → Heap Snapshot</strong></td><td>操作前 / 操作后各拍一份快照</td><td>Retained Size / Detached DOM Trees</td><td>未被释放的 DOM / 对象被引用</td></tr><tr><td><strong>4️⃣ 对比快照</strong></td><td>找出泄漏源头</td><td>Memory → <strong>Comparison 视图</strong></td><td>比较两份快照差异</td><td>哪些对象 / 节点数量持续增加</td><td>确认泄漏对象及增长趋势</td></tr><tr><td><strong>5️⃣ 引用链分析</strong></td><td>找出被谁持有</td><td>Memory → <strong>Retainers / Object References</strong></td><td>追踪泄漏对象的引用路径</td><td>闭包、全局变量、事件监听、定时器</td><td>典型 JS 引用未释放</td></tr><tr><td><strong>6️⃣ 修复验证</strong></td><td>移除引用 / 优化逻辑</td><td>代码修改 + 重测</td><td>清理事件、取消定时器、销毁监听、优化响应式</td><td>重新运行监控，确认 Heap 稳定</td><td>内存回收正常、卡顿消失</td></tr><tr><td><strong>7️⃣ 性能优化</strong></td><td>防止再次发生</td><td>Performance 面板 + Lighthouse</td><td>分析长任务（&gt;50ms）和渲染瓶颈</td><td>Recalculate Style / Layout / Paint 频率</td><td>渲染层优化、减少阻塞 JS</td></tr><tr><td><strong>8️⃣ 持续监控</strong></td><td>监控上线表现</td><td>性能监控 SDK（如 Sentry、WebVitals）</td><td>采集 FPS / Heap / 页面耗时数据</td><td>长时间运行后趋势</td><td>提前发现潜在泄漏</td></tr></tbody></table><h3 id="_11-定位白屏的常见原因" tabindex="-1">11.定位白屏的常见原因 <a class="header-anchor" href="#_11-定位白屏的常见原因" aria-label="Permalink to “11.定位白屏的常见原因”">​</a></h3><ul><li><p>1.JavaScript 错误导致渲染中断</p><ul><li>症状：控制台报错，页面无法正常渲染。</li><li>也可能接口返回异常数据或前端未兼容数据</li></ul></li><li><p>2.关键资源加载失败</p><ul><li>症状：页面依赖的 CSS、JS、图片等资源未加载，导致页面样式或功能缺失。</li></ul></li><li><p>3.页面渲染逻辑异常</p><ul><li>症状：页面结构正常，但内容未渲染。</li><li>排查方法： <ul><li>检查 JavaScript 渲染逻辑，确认数据是否正确传递和处理。</li><li>使用断点调试，逐步执行代码，查看变量值和执行流程。</li></ul></li></ul></li><li><p>4.浏览器兼容性问题</p><ul><li>症状：特定浏览器或版本下页面白屏。</li><li>排查方法：</li><li>使用 Can I Use 等工具，检查所用特性在目标浏览器中的支持情况。</li><li>添加适当的 Polyfill，确保功能在旧版浏览器中可用</li></ul></li><li><ol start="5"><li>网络环境或权限问题</li></ol><ul><li>症状：在特定网络环境下（如公司内网）页面白屏。</li><li>排查方法： <ul><li>检查 Content Security Policy（CSP）设置，确保没有阻止资源加载。</li><li>确认没有被防火墙或安全软件拦截</li></ul></li></ul></li><li><p>6.白屏检测方案</p><ul><li><p>方案一：检测根节点是否渲染：通过检查根节点是否有内容，判断页面是否白屏。</p></li><li><p>方案二：Mutation Observer 监听 DOM 变化：监听页面 DOM 变化，判断页面是否渲染。</p></li><li><p>方案三：页面截图检测：对比页面截图与纯白图片，判断页面是否白屏。</p></li><li><p>方案四：采样对比：在页面中采样多个点，判断是否有元素渲染。</p></li><li><p>步骤：</p><ul><li>1.生成随机坐标点：在页面的宽度和高度范围内生成多个随机坐标点。</li><li>2.检查坐标点处的元素：使用 document.elementFromPoint(x, y) 方法获取指定坐标点处的最上层元素。</li><li>3.判断元素是否可见：检查获取到的元素是否存在且可见。</li></ul></li></ul></li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>function isElementRendered(sampleCount = 10) {</span></span>
<span class="line"><span>    let visibleCount = 0;</span></span>
<span class="line"><span>    for (let i = 0; i &lt; sampleCount; i++) {</span></span>
<span class="line"><span>        const x = Math.random() * window.innerWidth;</span></span>
<span class="line"><span>        const y = Math.random() * window.innerHeight;</span></span>
<span class="line"><span>        const element = document.elementFromPoint(x, y);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if (element &amp;&amp; element.offsetParent !== null) {</span></span>
<span class="line"><span>            visibleCount++;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return visibleCount / sampleCount &gt; 0.5; // 如果超过一半的采样点有可见元素，认为页面已渲染</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="_12-浏览器事件循环-网络请求是宏任务吗" tabindex="-1">12.浏览器事件循环，网络请求是宏任务吗？ <a class="header-anchor" href="#_12-浏览器事件循环-网络请求是宏任务吗" aria-label="Permalink to “12.浏览器事件循环，网络请求是宏任务吗？”">​</a></h3><p>是的，浏览器中的网络请求（如使用 fetch 或 XMLHttpRequest）属于宏任务（macrotask）。</p><p>调用栈（Call Stack）：执行同步代码。 - 宏任务队列（Macrotask Queue）：存放宏任务的回调函数，例如 setTimeout、setInterval、DOM 事件、网络请求, UI 渲染等。 - 微任务队列（Microtask Queue）：存放微任务的回调函数，例如 Promise.then、MutationObserver 等。</p><p>事件循环的执行顺序如下：</p><ul><li>执行调用栈中的同步代码。</li><li>执行微任务队列中的所有任务，直到队列为空。</li><li>从宏任务队列中取出一个任务执行。</li><li>更新渲染（如果需要）。</li><li>重复上述步骤</li></ul><h3 id="_13-页面的线程" tabindex="-1">13. 页面的线程 <a class="header-anchor" href="#_13-页面的线程" aria-label="Permalink to “13. 页面的线程”">​</a></h3><table tabindex="0"><thead><tr><th>线程名称</th><th>职责</th><th>是否并行</th><th>示例说明</th></tr></thead><tbody><tr><td><strong>主线程（Main Thread）</strong></td><td>执行 JS、解析 HTML、计算样式、布局（layout）、绘制（paint）</td><td>❌ 单线程</td><td>JS 运行、DOM 操作、重排、重绘都在此执行</td></tr><tr><td><strong>渲染线程 / 合成线程（Compositor Thread）</strong></td><td>接收绘制指令，合成图层生成最终画面</td><td>✅ 可并行</td><td>负责 GPU 合成层的渲染，保证流畅动画</td></tr><tr><td><strong>光栅化线程（Raster Thread）</strong></td><td>把图层位图栅格化（交给 GPU 绘制）</td><td>✅ 多线程</td><td>将合成层绘制成像素输出</td></tr><tr><td><strong>网络线程（Network Thread）</strong></td><td>处理网络请求（HTTP、WebSocket、fetch）</td><td>✅ 独立</td><td>不受主线程阻塞，可同时并发多个请求</td></tr><tr><td><strong>IO 线程（Browser Process）</strong></td><td>管理文件、Cookie、缓存、输入输出等</td><td>✅ 独立</td><td>负责硬盘 / 系统层交互</td></tr><tr><td><strong>定时器线程（Timer Thread）</strong></td><td>管理定时器（setTimeout / setInterval）</td><td>✅ 独立</td><td>到期后把回调放回主线程事件队列执行</td></tr><tr><td><strong>Web Worker 线程</strong></td><td>执行耗时 JS 计算（不操作 DOM）</td><td>✅ 多线程</td><td>后台计算、大文件处理、AI、解析任务</td></tr><tr><td><strong>Service Worker 线程</strong></td><td>拦截请求、缓存资源、推送等</td><td>✅ 独立</td><td>PWA 核心线程，生命周期独立于页面</td></tr><tr><td><strong>GPU 线程（GPU Process）</strong></td><td>负责页面绘制、图像合成、3D 渲染</td><td>✅ 独立</td><td>合成层最终交由 GPU 渲染输出</td></tr></tbody></table><p><strong>JS、DOM、CSSOM、Layout、Paint、事件响应、垃圾回收（GC）都在主线程中执行。</strong></p><p>因此：当 JS 执行时间过长时（例如死循环 / 大量同步逻辑），会阻塞渲染 → 页面卡顿。当频繁修改 DOM、触发布局重排（Reflow）、重绘（Repaint）时，主线程负载增加 → FPS 下降。</p><p>✅ 这就是为什么浏览器看似“多线程”，但 JS 执行仍是单线程的根本原因：JS 与渲染共用主线程，为了避免线程竞争 DOM。</p><h3 id="_14-ts-type-interface" tabindex="-1">14.ts type interface <a class="header-anchor" href="#_14-ts-type-interface" aria-label="Permalink to “14.ts type interface”">​</a></h3><ul><li><p>interface：适用于定义对象的结构，支持声明合并和扩展，便于面向对象编程。(推荐interface)</p></li><li><p>type：适用于定义联合类型、交叉类型、元组等复杂类型，提供更强的表达能力</p></li></ul><table tabindex="0"><thead><tr><th>对比维度</th><th><code>interface</code></th><th><code>type</code></th></tr></thead><tbody><tr><td><strong>语义</strong></td><td>描述“对象的结构”或“类的契约”</td><td>可定义任意类型（对象、联合、交叉、原始类型等）</td></tr><tr><td><strong>扩展方式</strong></td><td>通过 <code>extends</code> 继承</td><td>通过 <code>&amp;</code>（交叉类型）组合</td></tr><tr><td><strong>可合并性（声明合并）</strong></td><td>✅ 可以多次定义同名接口，自动合并</td><td>❌ 不可重复声明同名 type</td></tr><tr><td><strong>能定义的类型范围</strong></td><td>仅限对象、函数、类结构</td><td>✅ 可定义联合类型、交叉类型、条件类型、元组等</td></tr><tr><td><strong>实现关系</strong></td><td>类（class）可实现（<code>implements</code>）接口</td><td>类不能直接实现 <code>type</code></td></tr><tr><td><strong>复杂类型表达</strong></td><td>不支持直接定义联合、映射等复杂类型</td><td>✅ 支持高级类型语法（联合、条件、映射等）</td></tr><tr><td><strong>兼容性</strong></td><td>更适合定义公共 API（库、类）</td><td>更灵活，适合组合与函数类型</td></tr><tr><td><strong>编译后表现</strong></td><td>不会生成 JS 代码，仅用于类型检查</td><td>同样仅存在于类型层</td></tr></tbody></table><table tabindex="0"><thead><tr><th>场景</th><th>推荐类型</th><th>理由</th></tr></thead><tbody><tr><td>定义对象结构 / 类契约</td><td><code>interface</code></td><td>语义更清晰、支持声明合并</td></tr><tr><td>定义联合、交叉、映射类型</td><td><code>type</code></td><td>表达力更强</td></tr><tr><td>在公共库、类型声明文件中</td><td><code>interface</code></td><td>更好扩展性</td></tr><tr><td>内部工具类型、组合类型</td><td><code>type</code></td><td>更灵活简洁</td></tr></tbody></table><h3 id="_15-ts-泛型" tabindex="-1">15. ts 泛型 <a class="header-anchor" href="#_15-ts-泛型" aria-label="Permalink to “15. ts 泛型”">​</a></h3><p>泛型（Generics） 是一种强大的特性，允许在定义函数、接口或类时不预先指定具体的类型，而在使用时再指定类型，从而实现类型的复用和灵活性。 泛型使得代码在处理不同类型的数据时，仍能保持类型安全。</p><p>泛型的优势</p><ul><li><p>类型安全：在编译时进行类型检查，避免运行时错误。</p></li><li><p>代码复用：编写与特定类型无关的通用代码，提高代码的复用性。</p></li><li><p>灵活性：根据实际需要指定类型，适应不同的数据类型和数据结构。</p></li><li><p>高级: 泛型约束, 默认泛型类型, 泛型与联合类型,</p></li><li><p>函数重载: 所谓函数重载就是同一个函数，根据传递的参数不同，会有不同的表现形式</p></li><li><p>never是其它类型(null undefined)的子类型，代表不会出现的值</p></li></ul><h3 id="_16-从输入-url-到页面渲染的完整流程-说出自己的理解" tabindex="-1">16. 从输入 URL 到页面渲染的完整流程, 说出自己的理解 <a class="header-anchor" href="#_16-从输入-url-到页面渲染的完整流程-说出自己的理解" aria-label="Permalink to “16. 从输入 URL 到页面渲染的完整流程, 说出自己的理解”">​</a></h3><h3 id="_17-web安全" tabindex="-1">17. web安全 <a class="header-anchor" href="#_17-web安全" aria-label="Permalink to “17. web安全”">​</a></h3><p><a href="/myKMS/knowledge/browser/webSecurity.html">web安全</a></p><ol><li>xss</li><li>csrf</li><li>点击劫持</li><li>token</li><li>sql注入</li><li>文件上传</li><li>认证与权限</li><li>加密算法</li><li>ddos</li><li>爬虫</li><li>服务器安全</li></ol><h3 id="_18-防爬虫" tabindex="-1">18. 防爬虫 <a class="header-anchor" href="#_18-防爬虫" aria-label="Permalink to “18. 防爬虫”">​</a></h3><pre><code>1. 使用验证码
2. 设置访问频率限制
3. 使用 User-Agent 检测
4. 动态内容加载
5. IP 黑名单
6. 使用 Token 验证
</code></pre><h3 id="_19-缓存" tabindex="-1">19. 缓存 <a class="header-anchor" href="#_19-缓存" aria-label="Permalink to “19. 缓存”">​</a></h3><p>浏览器 / 缓存层（代理、CDN）会将服务器响应保存起来，当下次请求相同资源时可直接从缓存中返回，而不必到服务器取。这样可以减少网络延迟和服务器负荷。</p><ul><li><p>新鲜度判断（Freshness） vs 验证（Validation）</p><ul><li>新鲜（Fresh）：在有效期内，缓存可直接返回给客户端。</li><li>陈旧（Stale）：资源已过有效期，需要验证是否更新（例如通过 ETag / Last-Modified）或强制重新下载。</li></ul><p>验证机制：客户端发送条件请求（If-None-Match, If-Modified-Since），服务器如资源未变返回 304 Not Modified 让客户端继续用缓存。</p></li><li><p>缓存作用域</p><ul><li><p>私有缓存（Private Cache）：如浏览器本地缓存，仅对单个用户可见。</p></li><li><p>共享缓存（Shared Cache / Proxy / CDN）：CDN / 代理服务器等中间缓存，可被多个用户共享。对于涉及用户隐私或基于 cookie 的响应，要限制这类缓存</p></li></ul></li><li><p>no-cache ≠ “不缓存” —— 它允许缓存储存，但使用前必须验证。</p></li><li><p>no-store 是“不储存”的真正指令，但不会清除已经缓存的旧数据。</p></li><li><p>Expires 比较老旧，现代多数场景用 cache-control 的 max-age。</p></li></ul><hr><p>zx</p><h3 id="_20-组件-key-改变和-props-改变有什么区别" tabindex="-1">20. 组件 key 改变和 props 改变有什么区别 <a class="header-anchor" href="#_20-组件-key-改变和-props-改变有什么区别" aria-label="Permalink to “20. 组件 key 改变和 props 改变有什么区别”">​</a></h3><table tabindex="0"><thead><tr><th>变化类型</th><th>对组件实例的影响</th><th>生命周期</th><th>state 是否保留</th><th>主要使用场景</th></tr></thead><tbody><tr><td><strong>key 改变</strong></td><td><strong>卸载旧组件 → 挂载新组件</strong>（实例被销毁并重建）</td><td>先触发旧组件的 <code>componentWillUnmount</code> / <code>useEffect</code> 的 cleanup，再触发新组件的 <code>constructor</code> → <code>render</code> → <code>useEffect</code></td><td><strong>不会保留</strong>（因为是全新实例）</td><td>当需要强制重新初始化组件（比如重置表单、重新加载数据）</td></tr><tr><td><strong>props 改变（key 不变）</strong></td><td><strong>复用原组件实例</strong></td><td>触发 <code>shouldComponentUpdate</code>（如有）/ <code>render</code> / 更新后的 <code>useEffect</code></td><td><strong>会保留</strong>（除非代码主动重置）</td><td>正常的属性更新：列表内容变化、UI 随数据更新</td></tr></tbody></table><h4 id="核心思想" tabindex="-1">核心思想 <a class="header-anchor" href="#核心思想" aria-label="Permalink to “核心思想”">​</a></h4><ul><li>key 是身份标签：一变就换人（卸载 + 重建）。</li><li>props 是输入数据：只变数据，不换人（实例保留）。</li></ul><h5 id="一句话总结" tabindex="-1">一句话总结 <a class="header-anchor" href="#一句话总结" aria-label="Permalink to “一句话总结”">​</a></h5><ul><li>需要强制重新初始化组件（如清空表单、重新加载动画）时，用 key；</li><li>仅需更新组件展示的数据时，修改 props 即可。</li></ul><h4 id="深入-props-引用没变-vs-引用改变" tabindex="-1">深入: props 引用没变 vs 引用改变 <a class="header-anchor" href="#深入-props-引用没变-vs-引用改变" aria-label="Permalink to “深入: props 引用没变 vs 引用改变”">​</a></h4><ul><li><p>props 引用没变</p><ul><li>父组件重新渲染，但 data 对象引用没变。</li><li>React 认为 props 没有变化，子组件如果是 React.memo，不会重新渲染。</li><li>state 保留，useEffect 依赖不会触发（如果依赖该 prop）。</li></ul></li><li><p>props 引用改变</p><ul><li>每次父组件渲染都会生成新对象。</li><li>即使内容相同，引用改变 → React 认为 props 改变。</li><li>React.memo 会触发重新渲染。</li><li>useEffect 依赖该 prop 也会重新执行。</li></ul></li></ul><h3 id="_26-react-form-里面非受控组件-如何对应上值的改变" tabindex="-1">26. react form 里面非受控组件 如何对应上值的改变 <a class="header-anchor" href="#_26-react-form-里面非受控组件-如何对应上值的改变" aria-label="Permalink to “26. react form 里面非受控组件 如何对应上值的改变”">​</a></h3><table tabindex="0"><thead><tr><th>方式</th><th>数据存放</th><th>值变化的响应</th><th>外部值改变时</th></tr></thead><tbody><tr><td>受控组件</td><td>React state</td><td><code>onChange</code> → setState → 重新渲染</td><td>直接受 state 驱动，值自动更新</td></tr><tr><td>非受控组件</td><td>DOM 元素内部</td><td>通过 <code>ref</code> 读取</td><td>需要用 <code>ref.current.value = ...</code> 手动更新</td></tr></tbody></table><p>总结</p><ul><li>非受控组件默认不会随着 props 变化而更新。</li><li>如果想同步外部变化： <ul><li>用 ref + useEffect 直接赋值给 DOM。</li><li>或者通过改变 key 来强制重建。</li><li>如果频繁需要同步外部数据，最好改用 受控组件</li></ul></li></ul><h3 id="_27-antd-form是如何控制内部组件的value的" tabindex="-1">27. antd form是如何控制内部组件的value的 <a class="header-anchor" href="#_27-antd-form是如何控制内部组件的value的" aria-label="Permalink to “27. antd form是如何控制内部组件的value的”">​</a></h3><p>基于 v4+ 分析</p><h5 id="总体设计思路" tabindex="-1">总体设计思路 <a class="header-anchor" href="#总体设计思路" aria-label="Permalink to “总体设计思路”">​</a></h5><p>Antd Form 并不是简单地把 <code>&lt;Form.Item&gt;</code> 里的 <code>&lt;Input&gt;</code> 当作受控组件包一层，而是自己实现了一套 “表单状态管理 + 受控注入” 机制。 核心：</p><ul><li>Form 内部维护一个 FormStore（字段名 → 值 的状态）。</li><li>每个 <code>&lt;Form.Item&gt;</code> 都会通过 Context 注册到 FormStore。</li><li>FormStore 变化后，通过 Context + forceUpdate 通知对应 Form.Item 重新渲染。</li><li>Form.Item 渲染时，会把 value 和 onChange 注入到子组件，实现受控。</li></ul><p>典型用法:</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Form</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> form</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{form} </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">initialValues</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{{ username: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Tom&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Form.Item</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;username&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Form.Item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Form</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>对应关系：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Form</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;           —— 维护 FormStore（字段状态）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   │</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   └─&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FormContext.Provider</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;  —— 提供 Store 和订阅方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        │</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        └─&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Form.Item</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;username&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; —— 注册字段</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              │</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              └─ cloneElement(&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;, {value, onChange})</span></span></code></pre></div><ol><li>流程详解</li></ol><ul><li><ol><li>FormStore</li></ol><ul><li>Form 创建时，内部有一个 store = {} 保存所有字段的值。</li><li>提供方法： <ul><li>getFieldValue(name) / getFieldsValue()</li><li>setFieldValue(name, value)</li><li>subscribe(callback) 订阅字段变化</li><li>Form.useForm() 返回的就是对这个 Store 的引用</li></ul></li></ul></li><li><p>2.Form.Item 注册字段</p><ul><li><code>&lt;Form.Item name=&quot;username&quot;&gt;</code> 渲染时，会通过 Context 把 name 注册到 Store。</li><li>它会订阅对应字段，当该字段值变化时触发 forceUpdate() 来重新渲染该 Item。</li></ul></li><li><ol start="3"><li>克隆子节点注入受控属性</li></ol><ul><li>渲染时，Form.Item 会用 React.cloneElement 给子组件（如 <code>&lt;Input /&gt;</code>）注入：</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: store[name],</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  onChange</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newValue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e.target </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e.target.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    store.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setFieldValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name, newValue);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>这样，子组件（比如 antd Input）变成了 FormStore 受控的受控组件。</li><li><em><strong>自定义组件支持接收value,onChange属性即可</strong></em></li><li>如果原本子组件自己也传了 value 和 onChange，Form.Item 会合并，但以 Form 为主。</li><li>因此，用 antd Form 时，不需要再手动写 value 和 onChange。</li></ul></li><li><ol start="4"><li>触发更新</li></ol><ul><li>用户在 Input 中输入： <ul><li><ol><li>Input 调用 onChange → store.setFieldValue(name, newValue)</li></ol></li><li><ol start="2"><li>Store 更新值后通知所有订阅者（相关 Form.Item）</li></ol></li><li><ol start="3"><li>对应 Form.Item forceUpdate()，重新渲染，给 Input 新的 value</li></ol></li><li>从而保证 Input 的显示值始终与 FormStore 中的值同步。</li></ul></li></ul></li><li><p>5.特殊场景</p><ul><li>initialValues：初始渲染时写入 Store，Form.Item 会读取。</li><li>setFieldsValue / resetFields：调用这些 API 时直接改 Store → 通知订阅 → 触发 Form.Item 更新。</li><li>dependencies：依赖项变化时重新渲染 Form.Item。</li><li>shouldUpdate：控制 Form.Item 是否重新渲染。</li></ul></li></ul><p>受控与非受控的对比</p><table tabindex="0"><thead><tr><th>特性</th><th>普通非受控表单</th><th>antd Form 内部机制</th></tr></thead><tbody><tr><td>值存放</td><td>DOM（通过 defaultValue）</td><td>FormStore（JS 对象）</td></tr><tr><td>组件更新</td><td>用户输入不会触发 React 重新渲染</td><td>每次输入都更新 Store 并触发 Form.Item 重渲染</td></tr><tr><td>外部控制</td><td>需要 ref 手动更新 DOM</td><td>用 <code>form.setFieldsValue()</code> 即可更新所有字段</td></tr></tbody></table><p>👉 可以认为： <strong>Antd Form 把所有字段都变成了受控组件，并用集中式 Store 管理。</strong></p><p><strong>总结</strong></p><ul><li>核心机制：<strong>集中式 FormStore 管理所有字段。</strong></li><li>关键手段：Form.Item 通过 Context 注册并订阅字段变化。</li><li>数据流： <ul><li>外部调用 setFieldsValue 或用户输入 → 更新 Store → 通知 Form.Item → 渲染子组件 → 子组件显示最新值。</li></ul></li><li>因此，antd Form 里的 Input、Select、Checkbox 等都是受控的，值完全由 FormStore 决定。</li></ul></div></div></main><footer class="VPDocFooter" data-v-d668f7cc data-v-1bcd8184><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-1bcd8184><span class="visually-hidden" id="doc-footer-aria-label" data-v-1bcd8184>Pager</span><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link prev" href="/myKMS/knowledge/base/nodejs.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>Previous page</span><span class="title" data-v-1bcd8184>node</span><!--]--></a></div><div class="pager" data-v-1bcd8184><a class="VPLink link pager-link next" href="/myKMS/interview/code.html" data-v-1bcd8184><!--[--><span class="desc" data-v-1bcd8184>Next page</span><span class="title" data-v-1bcd8184>code</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"ai_index.md\":\"DQUCvY3T\",\"algorithm_index.md\":\"DaoRZT4R\",\"api-examples.md\":\"COM88OYJ\",\"book_vue_1.md\":\"TUX_Qmzn\",\"index.md\":\"DzlC3Yeh\",\"interview_2025.md\":\"B3xFHujW\",\"interview_code.md\":\"D8kLOLcd\",\"interview_index.md\":\"DVAw2bmQ\",\"knowledge_base_js.md\":\"-2SNJGXv\",\"knowledge_base_nodejs.md\":\"d42vHt6y\",\"knowledge_browser_http.md\":\"qs5JB1ws\",\"knowledge_browser_index.md\":\"BEQio_1q\",\"knowledge_browser_websecurity.md\":\"CgjZWxgO\",\"knowledge_framework_electron.md\":\"B1fhL-LC\",\"knowledge_framework_react.md\":\"Bgfd4g-U\",\"knowledge_framework_vite.md\":\"BKUB8zV7\",\"knowledge_framework_vue.md\":\"BJBqfouA\",\"readme.md\":\"BuMoeJj1\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"个人知识库\",\"description\":\"个人知识库\",\"base\":\"/myKMS/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"Home\",\"link\":\"/\"},{\"text\":\"面试\",\"link\":\"/interview/code\"},{\"text\":\"框架\",\"link\":\"/knowledge/framework/react\"},{\"text\":\"浏览器\",\"link\":\"/knowledge/browser/http\"}],\"sidebar\":[{\"text\":\"基础知识\",\"items\":[{\"text\":\"js\",\"link\":\"/knowledge/base/js\"},{\"text\":\"node\",\"link\":\"/knowledge/base/nodejs\"}]},{\"text\":\"interview\",\"items\":[{\"text\":\"2025\",\"link\":\"/interview/2025\"},{\"text\":\"code\",\"link\":\"/interview/code\"},{\"text\":\"开放性问题\",\"link\":\"/interview/index\"}]},{\"text\":\"框架\",\"items\":[{\"text\":\"react\",\"link\":\"/knowledge/framework/react\"},{\"text\":\"vue\",\"link\":\"/knowledge/framework/vue\"},{\"text\":\"工程化\",\"link\":\"/knowledge/framework/vite\"},{\"text\":\"electron\",\"link\":\"/knowledge/framework/electron\"}]},{\"text\":\"浏览器\",\"items\":[{\"text\":\"browser\",\"link\":\"/knowledge/browser/index\"},{\"text\":\"http\",\"link\":\"/knowledge/browser/http\"},{\"text\":\"web安全\",\"link\":\"/knowledge/browser/webSecurity\"}]},{\"text\":\"读书笔记\",\"items\":[{\"text\":\"vue.js 设计与实践\",\"link\":\"/book/vue_1\"}]},{\"text\":\"算法\",\"items\":[{\"text\":\"总\",\"link\":\"/algorithm/index\"}]},{\"text\":\"AI\",\"items\":[{\"text\":\"ai\",\"link\":\"/ai/index\"}]}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/xingyuanlong/myKMS\"}],\"outline\":{\"level\":[2,3],\"label\":\"页面导航\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false,\"additionalConfig\":{}}");</script>
    
  </body>
</html>