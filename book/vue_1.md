# vue.js 设计与实践 霍春阳

计算机的所有东西都是人做出来的，别人能想得出来的，我也一定能想得出来，在计算机里头，没有任何黑魔法，所有的东西，只不过是我现在不知道而已，总有一天，我会把所有的细节，所有的内部的东西全都搞明白的。

## 框架设计

1. HTML Attributes 的作用是设置与之对应的 DOM Properties 的初始值。一旦值改变，那么 DOM Properties始终存储着当前值，而通过 getAttribute 函数得到的仍然是初始值.

```
<input id="inp" value="hello">
<script>
  const el = document.getElementById('inp');
  console.log(el.getAttribute('value')); // "hello" —— attribute 的初始值
  console.log(el.value);                // "hello" —— property 当前状态（初始也一样）

  // 用户在输入框中更改内容 / 脚本更改：
  el.value = "world";
  console.log(el.value);                // "world" —— property 变了
  console.log(el.getAttribute('value')); // 仍然 "hello" —— attribute 没被自动改

  // 如果你手动改 attribute：
  el.setAttribute('value', 'foo');
  console.log(el.getAttribute('value')); // "foo"
  console.log(el.value);                 // 此时 el.value 仍是 "world"（不被属性写覆盖）
</script>
```

- 性能与逻辑清晰
- 表单重置机制
- 避免无限同步 / 循环

**Attribute = 初始 / 静态配置**

**Property = 当前 / 动态状态**

**属性给默认值，属性变状态；状态变不改属性，除非你手动改属性。**

**框架的设计是一门权衡的艺术**

2. 命令式框架(原生 DOM 操作) 与 声明式框架(React / Vue)

现代前端框架为什么倾向声明式

- 状态和 UI 之间的映射更清晰，业务代码和展示代码分离。
- 开发效率高，写少量代码就能描述复杂的 UI。
- 减少手动 DOM 操作带来的 Bug。
- 响应式 /虚拟 DOM /Diff 算法等使得框架可以高效地管理 DOM 更新，使声明式在性能上可行。

声明书关注结果
声明式的性能消耗=找出差异的性能消耗+直接更新的性能消耗

-----

3. 框架: 运行时, 编译时, 运行时加编译时(react 本身是运行时, vue 运行+编译, selvet编译)

- 编译时（Compile-time / build time）：框架在构建阶段（即开发／打包时）就把模板 / 视图 /指令 /绑定逻辑转换成最终可执行 JS／渲染函数／DOM 操作代码的过程。
- 运行时（Runtime）：框架在浏览器中真正执行的时候才处理模板、指令、绑定、差异更新、渲染等逻辑。

| 类别   | 编译阶段做什么               | 运行阶段做什么                | 优势             | 缺点                | 代表框架                        |
| ---- | --------------------- | ---------------------- | -------------- | ----------------- | --------------------------- |
| 纯运行时 | 很少或不做模板预处理            | 模板解析、指令解释、绑定、更新        | 灵活性高、运行时可以动态模板 | 性能较差、包体积大         | 旧版 Vue、AngularJS 等          |
| 纯编译时 | 模板全部转换为可执行代码 / DOM 操作 | 几乎不做模板解析/指令解释，只做最小运行逻辑 | 运行效率高、体积小      | 动态能力弱，难以支持运行时模板变化 | Svelte 等                    |
| 混合型  | 模板编译、静态优化、指令预处理       | 响应式、绑定、差异更新、事件处理等      | 性能 + 灵活性兼顾     | 实现复杂、设计权衡难        | Vue + React + Angular 等现代框架 |

---

4. 框架设计核心要素:

- 提升开发体验
- 控制框架代码体积
- 框架要有良好的tree-sharking
- 应该输出什么产物
- 特性开关
- 错误处理
- 良好的ts 支持

---

虚拟dom 是来描述真实dom的js对象
组件是一组dom的封装, 是个函数,函数返回dom的封装, 一般都是可以复用的
组件 vdom 组件实例本质是个对象. renderer 函数

## 响应系统

1. vue3 响应的核心 proxy 对象, get 收集effect , set 触发effect. 利用weakmap(对象为key, 值为map); 值的map 中 key为响应的字段, value 为 set 收集的响应函数.

Vue 3 使用一个 任务队列机制 来调度更新任务, 所有响应式更新在一个事件循环中只执行一次, 不会造成多次重复渲染

2. computed 和 watch 是对effect的2次封装, watch 的本质是利用 effect 和 options.scheduler 实现
   watch 本质是 给响应式 getter 创建一个 effect，并在依赖变化时异步调用回调函数。
   computed 就像带缓存的 “惰性执行的 getter”，内部依赖 reactive/ref，依赖变化会标记脏，但不会立即计算，直到你访问它 .value。

3. 对象代理根据ecmascript 规范实现对应的拦截操作(proxy reflect)

4. Vue3 响应式系统中数组监听的内部机制原理: Proxy 拦截数组的操作 → 依赖收集 (track) → 派发更新 (trigger) (Vue3 对数组方法（push、pop、splice 等）做了“响应化包装”, 内部最终也是通过 set 修改数组和 length 来触发更新)

5. nextTick: 用于在下次 DOM 更新循环结束之后执行回调. (Vue 在响应式数据变化时，不会立即更新 DOM，而是异步队列合并更新，提高性能). Vue 的 nextTick 本质是 微任务队列的调度, 维护一个回调队列,用户调用 nextTick(cb) → 将回调放入队列,异步执行队列,执行完队列后，清空队列) Vue 内部是 数据变化 → 异步 DOM 更新 → nextTick 回调执行

在 Pinia 中，每个 store 的 state 被 Vue 3 的响应式系统（Proxy + reactive/ref）包装，从而自动追踪读取与写入并触发更新。**getters 则以计算属性（computed）的形式存在，具有依赖缓存功能；actions 是普通方法（可以同步也可以异步），负责封装更新 state 的逻辑。**

Pinia 是一种模块化的、响应式 /观察者模式为核心的状态管理库，结合命令模式（actions 作为命令），派生状态通过计算属性模式（computed），并加上工厂模式来定义 store，以及插件机制进行扩展。

默认情况下 Pinia / Redux / Redux Toolkit / MobX 本身都不会将状态“存到浏览器”（如 localStorage）

## 渲染器

1. vue2 双端快速diff算法
2. vue3 diff 算法 = 静态标记优化 + 双端比较 + 哈希查找 + 最长递增子序列 (LIS) 移动优化。 (偏运行时优化，核心是 双端比较 + LIS 移动最优。)
3. react 18 diff 算法,key + index 来做 diff, 采用贪心策略, 结合 Fiber 支持了 并发渲染(偏架构优化，核心是 基于 key 的复用规则 + 贪心移动，重点是 可中断、可恢复，为并发模式服务。)



## 组件化

1. vue3 异步组件本质是高阶组件, 支持错误处理, loading 状态(防止闪烁延迟loading), 加载超时, 加载失败超时重试.

2. keep alive 组件, 并不是真正的卸载, 组件放在隐藏容器内, 挂载时从隐藏容器搬出. 缓存策略为最近一次使用, LRU 算法

3. Teleport 组件, 指定 dom 渲染, 抽离了渲染逻辑, 方便Tree shaking

4. Transition 再渲染器在执行挂载和卸载操作时, 执行过渡相关钩子函数

5. vue3 双向绑定 读取时 → 依赖收集 → 修改时 → 触发副作用

## 编译器

1. 编译器: 完整的编译过程通常包含词法分析、语法分析、语义分析、中间代码生成、优化、目标代码生成等步骤
  Vue.js 模板编译器: 模板 => 词法分析 => 语法分析 => 模板AST => Transform => JavaScript AST => 代码生成 => 渲染函数
      1. 将模板字符串解析为模板 AST 的解析器（parser）
      2. 将模板 AST 转换为 JavaScript AST 的转换器（transformer）
      3. 根据 JavaScript AST 生成渲染函数代码的生成器 （generator）
    
  使用到了经典的: 递归下降算法

2. **编译优化指的是编译器将模板编译为渲染函数的过程中，尽可能多地提取关键信息，并以此指导生成最优代码的过程。**

3. Vue 3 的编译优化主要指编译器将模板编译为渲染函数的过程中，尽可能多地提取关键信息，用于指导生成最优代码的过程。优化的核心方向是区分动态内容与静态内容，并针对它们采取不同的策略，以减少运行时开销，提升更新性能.

  - Vue3 静态提升就是在编译阶段把不会变化的节点或属性抽离出来只创建一次，后续渲染直接复用，从而减少重复创建和 diff 提升性能, 减少内存占用。

4. Patch Flag 的意义：让 diff 只关注变化点，而不是无脑遍历所有属性。
    传统虚拟 DOM diff 会递归对比整棵 VNode 树，即使节点是静态的也要逐层检查，浪费性能。Vue3 在 编译阶段 就能知道哪些地方是“动态的”。所以会在生成渲染函数时，为动态节点打上 Patch Flag，用来告诉运行时“这个节点只需要检查哪些方面”。

5. Vue3 在编译阶段会把模板分成 Block，每个 Block 只追踪内部的 动态节点集合。更新时，Vue只需要遍历这些动态节点，而静态节点完全跳过。
  Block 是一个特殊的 VNode，它充当一个“容器”，负责收集并追踪其所有动态的后代节点。 由 Block 组成的树形结构就是 Block Tree。
  Block Tree 的意义：让 diff 只在动态节点集合内进行。

6. 两者关系: Patch Flag：标记动态节点 哪里可能变化。Block Tree：组织动态节点 只 diff 必要部分。
  Vue3 通过 Block Tree 把 diff 范围限制在动态节点，再用 Patch Flag精确标记具体的变化点，两者配合把运行时开销降到最低。
  运行时: 它直接对比新旧 Block 的 dynamicChildren 数组（一个扁平的、只含动态节点的数组）。对于数组中的每个新 VNode，根据其 Patch Flag 指示的类型，进行靶向更新。

7. 静态提升: 每次组件更新都会重新创建所有的 VNode, 编译器会在 编译阶段 分析模板，把完全静态的节点/属性抽离出来，生成一次后放在渲染函数外部，后续渲染时直接复用
    Vue3 静态提升就是把编译期可确定的静态节点/属性抽离出来，生成一次后在渲染中直接复用，从而减少 vnode 创建和 diff，提升性能。

8. 预字符串化: 完全静态的内容块, 编译器会直接把它们 预生成成 HTML 字符串，在运行时一次性插入DOM，而不是逐个创建VNode。减少运行时开销,更少的内存占用,更快的首屏渲染.

  Vue 3 的预字符串化，就是把编译期能确定的纯静态 DOM 直接转成 HTML 字符串，运行时直接插入，不走 VNode 创建和 diff，从而大幅减少开销。

  - 静态提升：把静态节点变成 VNode 常量，依旧走虚拟 DOM。
  - 预字符串化：对于整块完全静态的 DOM，直接生成 HTML 字符串，运行时一次性插入，更快。

9. 缓存内联事件处理函数: 内联箭头函数每次组件重新渲染时，Vue 都会创建一个新的函数对象。会导致不必要的内存开销或性能问题.
   两个优化: 1.缓存静态事件处理函数,2.内联事件处理函数缓存（cacheHandlers）在模板编译阶段可以通过缓存策略，将函数缓存到一个数组里，避免重复创建。(类似react useCallbeak)

10. v-once: 只渲染一次, 在静态静态文本, 不变的部分中使用. v-once 禁用了该节点及子节点的响应式绑定，彻底静态化,不会触发 diff 和重渲染;
  1.避免组件更新时重新创建虚拟 DOM 带来的性能开销。因为虚拟DOM 被缓存了，所以更新时无须重新创建。

11. Vue3 的编译时优化核心就是：👉 “能静态的就静态，能标记的就标记，运行时只关心动态部分”。

性能指标: 加载性能指标/交互性能指标/视觉稳定性指标/资源加载指标/用户体验综合指标(RAIL模型)


## 总结: 

这本书很好, 值得读几遍的, 感谢霍春阳老师.
