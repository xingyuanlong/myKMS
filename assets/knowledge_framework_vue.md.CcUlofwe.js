import{_ as s,I as i,c as o,o as r,j as l,J as t,a as n,w as a}from"./chunks/framework.fGi7qB65.js";const v=JSON.parse('{"title":"vue","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/framework/vue.md","filePath":"knowledge/framework/vue.md"}'),d={name:"knowledge/framework/vue.md"};function p(c,e,f,h,k,m){const u=i("Collapse");return r(),o("div",null,[e[12]||(e[12]=l("h1",{id:"vue",tabindex:"-1"},[n("vue "),l("a",{class:"header-anchor",href:"#vue","aria-label":"Permalink to “vue”"},"​")],-1)),e[13]||(e[13]=l("h3",{id:"_1-vue-动态渲染组件的原理是什么",tabindex:"-1"},[n("1.vue 动态渲染组件的原理是什么 "),l("a",{class:"header-anchor",href:"#_1-vue-动态渲染组件的原理是什么","aria-label":"Permalink to “1.vue 动态渲染组件的原理是什么”"},"​")],-1)),t(u,null,{default:a(()=>[...e[0]||(e[0]=[l("p",null,[l("strong",null,"本质是根据虚拟 DOM（VNode）的 type 动态切换组件"),n(" 动态组件就是根据 VNode 的 type 动态 patch，不同类型就卸载旧组件、挂载新组件。")],-1),l("p",null,[n("-"),l("code",null,'Vue 模板编译 <component :is="currentComponent"> → createVNode(currentComponent)')],-1),l("ul",null,[l("li",null,[n("当 currentComponent 变化： "),l("ul",null,[l("li",null,"生成新的 VNode"),l("li",null,"调用 patch(oldVNode, newVNode)"),l("li",null,[n("对比 VNode 类型： "),l("ul",null,[l("li",null,"类型相同 → 复用组件实例"),l("li",null,"类型不同 → 卸载旧组件，挂载新组件")])])])])],-1),l("p",null,"如果是字符串 → 查找全局组件注册表 如果是组件对象 → 返回组件本身",-1),l("p",null,[l("strong",null,"Vue 动态组件就是 根据 reactive/ref 的值动态生成 VNode type，然后通过 patch 更新组件实例，keep-alive 则通过缓存实例优化挂载卸载。")],-1)])]),_:1}),e[14]||(e[14]=l("h3",{id:"_2-vue-项目可做哪些性能优化",tabindex:"-1"},[n("2.Vue 项目可做哪些性能优化 "),l("a",{class:"header-anchor",href:"#_2-vue-项目可做哪些性能优化","aria-label":"Permalink to “2.Vue 项目可做哪些性能优化”"},"​")],-1)),t(u,null,{default:a(()=>[...e[1]||(e[1]=[n(" - 减少不必要的响应式追踪 - 用 markRaw() 包装不需要响应的对象 - 使用 shallowReactive / shallowRef 避免深层递归依赖 - 使用 key 保证组件复用正确 - 合理的使用指令 - 合理的使用 v-if 和 v-show 指令，避免不必要的渲染。 - 使用 v-for 时，尽量提供唯一的 key ，避免重复渲染。 - 使用 v-once 指令，只渲染一次，避免不必要的计算。 - 使用 v-memo 指令，对使用v-for生成的列表进行渲染优化 - 组件优化 - 合理使用 keep-alive 组件，缓存组件实例，避免重复渲染。 - 合理划分组件，提升复用性和渲染性能。 - 响应式优化 - watch的优化: 避免滥用深度监听，降低性能开销。对于频繁触发的响应式数据变化，可以通过防抖和节流优化监听逻辑。 - 异步组件懒加载 - 合理使用 Teleport 与 Suspense - 减少模板内复杂计算 - 代码分割 & 按需加载 - Tree Shaking + 移除无用依赖 - 懒加载 - 渲染加 key - 虚拟滚动 - ... ",-1)])]),_:1}),e[15]||(e[15]=l("h3",{id:"_3-nexttick-原理是什么",tabindex:"-1"},[n("3. nextTick 原理是什么 "),l("a",{class:"header-anchor",href:"#_3-nexttick-原理是什么","aria-label":"Permalink to “3. nextTick 原理是什么”"},"​")],-1)),t(u,null,{default:a(()=>[...e[2]||(e[2]=[l("p",null,[l("strong",null,"nextTick在下次 DOM 更新循环结束后执行回调，确保我们能操作到最新的 DOM 状态。")],-1),l("p",null,"Vue 采用 异步批量更新策略：",-1),l("ul",null,[l("li",null,"收集本轮所有的更新任务；"),l("li",null,"等当前“事件循环”结束后，一次性刷新 DOM；"),l("li",null,"保证更新最少、性能最好。")],-1),l("p",null,[n("Vue 3 的 nextTick 实际上是封装了一个"),l("strong",null,"微任务调度器（microtask scheduler）"),n("。")],-1),l("div",{class:"language-"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"}),l("pre",{class:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabindex:"0",dir:"ltr"},[l("code",null,[l("span",{class:"line"},[l("span",null,"// Vue3 内部核心实现伪代码")]),n(`
`),l("span",{class:"line"},[l("span",null,"let pending = false")]),n(`
`),l("span",{class:"line"},[l("span",null,"const queue = []")]),n(`
`),l("span",{class:"line"},[l("span")]),n(`
`),l("span",{class:"line"},[l("span",null,"function queueFlush() {")]),n(`
`),l("span",{class:"line"},[l("span",null,"  if (!pending) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"    pending = true")]),n(`
`),l("span",{class:"line"},[l("span",null,"    Promise.resolve().then(flushJobs) // 微任务")]),n(`
`),l("span",{class:"line"},[l("span",null,"  }")]),n(`
`),l("span",{class:"line"},[l("span",null,"}")]),n(`
`),l("span",{class:"line"},[l("span")]),n(`
`),l("span",{class:"line"},[l("span",null,"function flushJobs() {")]),n(`
`),l("span",{class:"line"},[l("span",null,"  pending = false")]),n(`
`),l("span",{class:"line"},[l("span",null,"  // 执行 watcher、渲染任务")]),n(`
`),l("span",{class:"line"},[l("span",null,"  ...")]),n(`
`),l("span",{class:"line"},[l("span",null,"  // 执行 nextTick 回调")]),n(`
`),l("span",{class:"line"},[l("span",null,"  flushPostFlushCbs()")]),n(`
`),l("span",{class:"line"},[l("span",null,"}")]),n(`
`),l("span",{class:"line"},[l("span")]),n(`
`),l("span",{class:"line"},[l("span",null,"export function nextTick(cb) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"  return cb ? Promise.resolve().then(cb) : Promise.resolve()")]),n(`
`),l("span",{class:"line"},[l("span",null,"}")])])])],-1),l("p",null,"Vue 内部维护了多个“任务队列”，它们依次执行：",-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"队列名"),l("th",null,"作用"),l("th",null,"举例")])]),l("tbody",null,[l("tr",null,[l("td",null,[l("strong",null,"job queue")]),l("td",null,"收集响应式副作用更新（组件 render、watch 回调）"),l("td",null,"数据变化后重新渲染组件")]),l("tr",null,[l("td",null,[l("strong",null,"postFlushCbs")]),l("td",null,"DOM 更新后执行"),l("td",null,"nextTick 回调、watch post 回调")]),l("tr",null,[l("td",null,[l("strong",null,"microtask queue")]),l("td",null,"最底层调度机制"),l("td",null,"Promise.resolve().then(...)")])])],-1),l("p",null,"所以 nextTick() 实际是在 DOM 更新完（flushJobs 执行后）被触发的。",-1),l("p",null,"因此 nextTick() 实际上是一个微任务级别的等待；所以它总是保证在本轮 DOM 更新完成后执行。",-1),l("p",null,[l("strong",null,"nextTick 一定比 setTimeout 先执行。"),n(" 因为：")],-1),l("ul",null,[l("li",null,"nextTick 底层用的是 微任务（microtask）；"),l("li",null,"setTimeout 属于 宏任务（macrotask）；"),l("li",null,"在一次事件循环中，微任务总是早于宏任务执行。")],-1),l("p",null,"nextTick 回调 再dom 渲染之后, 宏任务执行之前.",-1)])]),_:1}),e[16]||(e[16]=l("h3",{id:"_4-如何统一监听-vue-组件报错",tabindex:"-1"},[n("4.如何统一监听 Vue 组件报错 "),l("a",{class:"header-anchor",href:"#_4-如何统一监听-vue-组件报错","aria-label":"Permalink to “4.如何统一监听 Vue 组件报错”"},"​")],-1)),t(u,null,{default:a(()=>[...e[3]||(e[3]=[n(" 在 Vue 3 中，可以通过 全局错误处理器 （errorHandler） 和 生命周期钩子（例如 onErrorCaptured ）来统一监听和处理组件中的错误. ",-1),l("ul",null,[l("li",null,"通过全局错误处理器 app.config.errorHandler"),l("li",null,"局部错误捕获（onErrorCaptured）"),l("li",null,"Vue 只能捕获「Vue 运行时错误」，但是有些错误是全局 JavaScript 运行时错误（例如异步请求、脚本加载失败）。需要配合浏览器原生错误监听")],-1)])]),_:1}),e[17]||(e[17]=l("h3",{id:"_5-什么是-mvvm",tabindex:"-1"},[n("5. 什么是 MVVM "),l("a",{class:"header-anchor",href:"#_5-什么是-mvvm","aria-label":"Permalink to “5. 什么是 MVVM”"},"​")],-1)),t(u,null,{default:a(()=>[...e[4]||(e[4]=[l("p",null,"MVVM（Model-View-ViewModel） 是一种用于构建用户界面的架构模式，用于现代的前端开发框架（Vue、Angular）。它通过 数据绑定 和 视图模型 提供了高效的 UI 更新和数据同步机制。",-1),l("p",null,"MVVM 模式主要由 Model （模型）、 View （视图）、 ViewModel （视图模型）三个部分组成。",-1),l("p",null,"Model表示程序的核心数据和业务逻辑，它不关心用户界面，只负责数据的获取、存储和处理，并提供与外界交互的接口。 View负责展示数据和用户交互，简单来说他就是我们看到的UI 组件或 HTML 页面。 ViewModel是连接 View 和 Model 的桥梁，它不直接操作视图或模型，而是通过数据绑定将两者连接起来。",-1),l("p",null,[l("strong",null,"MVVM：让数据和视图自动同步（双向绑定）")],-1),l("p",null,"React 是一种 UI 声明式渲染的 View 层库，核心是 函数式 + 单向数据流。 Vue 是 MVVM 模型",-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"对比项"),l("th",null,"Vue (MVVM)"),l("th",null,"React (View + State)")])]),l("tbody",null,[l("tr",null,[l("td",null,"数据流"),l("td",null,"双向绑定"),l("td",null,"单向数据流")]),l("tr",null,[l("td",null,"绑定方式"),l("td",null,[l("code",null,"v-model"),n(" 自动同步")]),l("td",null,[n("手动 "),l("code",null,"onChange"),n(" + "),l("code",null,"setState")])]),l("tr",null,[l("td",null,"响应系统"),l("td",null,"Proxy 响应式追踪"),l("td",null,[n("调用 "),l("code",null,"setState"),n(" 触发重新渲染")])]),l("tr",null,[l("td",null,"哲学思想"),l("td",null,"声明式 + 响应式"),l("td",null,"函数式 + 纯 UI 渲染")]),l("tr",null,[l("td",null,"框架定位"),l("td",null,"完整 MVVM 框架"),l("td",null,"UI 库（View 层）")])])],-1)])]),_:1}),e[18]||(e[18]=l("h3",{id:"_6-vue-组件初始化的各个阶段都做了什么",tabindex:"-1"},[n("6. Vue 组件初始化的各个阶段都做了什么？ "),l("a",{class:"header-anchor",href:"#_6-vue-组件初始化的各个阶段都做了什么","aria-label":"Permalink to “6. Vue 组件初始化的各个阶段都做了什么？”"},"​")],-1)),t(u,null,{default:a(()=>[...e[5]||(e[5]=[l("p",null,"从组件的创建到挂载到页面，再到组件的更新和销毁，每个阶段都有特定的任务和职责。",-1),l("p",null,"🎯 组件实例创建：当我们第一次访问页面时，Vue创建组件实例，解析props、data、methods等属性方法，在组合式API中，执行 setup()。",-1),l("p",null,"🎯 响应式系统建立：基于 Proxy 实现 reactive、ref，建立依赖收集和触发更新机制，props 传递时自动响应式处理。",-1),l("p",null,"🎯 模板编译与渲染：将 template 编译为渲染函数，Vue 3 通过 静态提升等方式优化性能，Vite 预编译 SFC（单文件组件）。",-1),l("p",null,"🎯 DOM 挂载：执行渲染函数生成 VNode，通过 Patch 算法 转换为真实 DOM 并插入页面，同时初始化子组件。mounted（Options API）或 onMounted（Composition API）触发，可进行 DOM 操作。",-1),l("p",null,"🎯 响应式更新：状态变更触发 Diff 算法 计算最小 DOM 更新，beforeUpdate、updated（Options API）或 onBeforeUpdate、onUpdated（Composition API）执行相应逻辑。",-1),l("p",null,"🎯 组件销毁：移除 DOM，清理副作用（解绑事件、销毁 watcher、清理 effect），递归卸载子组件，触发 beforeUnmount、unmounted（Options API）或 onBeforeUnmount、onUnmounted（Composition API）。",-1)])]),_:1}),e[19]||(e[19]=l("h3",{id:"_7-vue3-如何实现双向数据绑定",tabindex:"-1"},[n("7.Vue3 如何实现双向数据绑定 "),l("a",{class:"header-anchor",href:"#_7-vue3-如何实现双向数据绑定","aria-label":"Permalink to “7.Vue3 如何实现双向数据绑定”"},"​")],-1)),t(u,null,{default:a(()=>[...e[6]||(e[6]=[l("p",null,[l("strong",null,"Vue 实现双向数据绑定的核心是通过响应式系统的 数据劫持和 观察者模式来实现的。")],-1),l("p",null,"Vue3 实现双向绑定的本质是这三层： 数据层（Model） ←→ 响应式系统（Reactivity） ←→ 视图层（View）",-1),l("p",null,"它主要依赖三个核心模块：",-1),l("ul",null,[l("li",null,"Proxy + Reflect —— 数据劫持（响应式追踪）"),l("li",null,"依赖收集与触发更新（effect + scheduler）"),l("li",null,"模板编译生成 getter/setter 更新逻辑")],-1),l("p",null,"数据劫持：reactive() / ref() Proxy/Reflect get 时依赖收集, set 时触发更新",-1),l("ul",null,[l("li",null,"track()：记录当前副作用（watchEffect、render 等）依赖了哪个数据；"),l("li",null,"trigger()：数据变更时，重新运行依赖的副作用函数（更新视图）。")],-1),l("p",null,"Vue3 的双向绑定本质是：",-1),l("ul",null,[l("li",null,"通过 Proxy 劫持数据 实现响应式追踪；"),l("li",null,"通过 effect 依赖收集与触发机制 实现自动更新；"),l("li",null,"通过 v-model 语法糖 + 事件机制 实现视图 ↔ 数据同步。")],-1),l("p",null,"Proxy 的缺点:",-1),l("ul",null,[l("li",null,[n("对数组的一些边界问题 "),l("ul",null,[l("li",null,"数组索引越界修改无效"),l("li",null,"部分原生方法不触发更新")])]),l("li",null,[n("性能问题 "),l("ul",null,[l("li",null,"嵌套非常深的对象,依赖收集和触发依然有开销")])]),l("li",null,[n("Proxy 不支持原始类型 "),l("ul",null,[l("li",null,"ref 是封装value的对象")])])],-1)])]),_:1}),e[20]||(e[20]=l("h3",{id:"_8-vue-模板编译的过程",tabindex:"-1"},[n("8.Vue 模板编译的过程 "),l("a",{class:"header-anchor",href:"#_8-vue-模板编译的过程","aria-label":"Permalink to “8.Vue 模板编译的过程”"},"​")],-1)),t(u,null,{default:a(()=>[...e[7]||(e[7]=[l("p",null,[l("strong",null,"模板解析、AST优化 和 代码生成")],-1),l("div",{class:"language-"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"}),l("pre",{class:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabindex:"0",dir:"ltr"},[l("code",null,[l("span",{class:"line"},[l("span",null,"模板字符串 (template)")]),n(`
`),l("span",{class:"line"},[l("span",null,"       ↓")]),n(`
`),l("span",{class:"line"},[l("span",null,"[1] 解析（Parse） → 生成 AST")]),n(`
`),l("span",{class:"line"},[l("span",null,"       ↓")]),n(`
`),l("span",{class:"line"},[l("span",null,"[2] 转换（Transform） → 优化、静态标记、指令处理")]),n(`
`),l("span",{class:"line"},[l("span",null,"       ↓")]),n(`
`),l("span",{class:"line"},[l("span",null,"[3] 生成（Generate） → 输出可执行的 render 函数")])])])],-1),l("ol",null,[l("li",null,"模板解析: Vue 使用其解析器将 HTML 模板转换为 抽象语法树（AST）。在这个阶段，Vue 会分析模板中的标签、属性和指令，生成一颗树形结构。每个节点表示模板中的一个元素或属性。"),l("li",null,"AST优化: Vue 在生成渲染函数前，会对 AST 进行优化。优化的核心目标是标记 静态节点，在渲染时，Vue 可以跳过这些静态节点，提升性能。 还有动态标记."),l("li",null,"代码生成: 生成渲染函数是编译的最终阶段，这个阶段会将优化后的 AST 转换成 JavaScript 渲染函数。")],-1)])]),_:1}),e[21]||(e[21]=l("h3",{id:"_9-vue-异步更新",tabindex:"-1"},[n("9. vue 异步更新 "),l("a",{class:"header-anchor",href:"#_9-vue-异步更新","aria-label":"Permalink to “9. vue 异步更新”"},"​")],-1)),t(u,null,{default:a(()=>[...e[8]||(e[8]=[l("p",null,"Vue 会延迟更新 DOM，等同一轮事件循环中所有状态改动都完成后，再统一执行更新。",-1),l("p",null,"目的： ✅ 避免频繁的 DOM 重绘（性能优化） ✅ 保证多次修改只渲染一次（批量更新） ✅ 数据一致性：确保在同一事件循环中的所有数据变更后，视图一次性更新到最终状态。",-1),l("div",{class:"language-"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"}),l("pre",{class:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabindex:"0",dir:"ltr"},[l("code",null,[l("span",{class:"line"},[l("span",null,"数据变化（Proxy.set）")]),n(`
`),l("span",{class:"line"},[l("span",null,"       ↓")]),n(`
`),l("span",{class:"line"},[l("span",null,"触发依赖（trigger）")]),n(`
`),l("span",{class:"line"},[l("span",null,"       ↓")]),n(`
`),l("span",{class:"line"},[l("span",null,"派发更新任务（scheduler → queueJob）")]),n(`
`),l("span",{class:"line"},[l("span",null,"       ↓")]),n(`
`),l("span",{class:"line"},[l("span",null,"进入异步任务队列（微任务）")]),n(`
`),l("span",{class:"line"},[l("span",null,"       ↓")]),n(`
`),l("span",{class:"line"},[l("span",null,"批量执行更新（flushJobs）")]),n(`
`),l("span",{class:"line"},[l("span",null,"       ↓")]),n(`
`),l("span",{class:"line"},[l("span",null,"重新渲染组件（patch → diff → DOM 更新）")])])])],-1),l("p",null,[l("strong",null,"响应式数据变化 → 触发依赖 effect → 将更新任务加入微任务队列 → 批量刷新渲染。")],-1)])]),_:1}),e[22]||(e[22]=l("h3",{id:"_10-vue-watch-computed-的区别",tabindex:"-1"},[n("10. vue watch computed 的区别 "),l("a",{class:"header-anchor",href:"#_10-vue-watch-computed-的区别","aria-label":"Permalink to “10. vue watch computed 的区别”"},"​")],-1)),t(u,null,{default:a(()=>[...e[9]||(e[9]=[l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"特性"),l("th",null,[l("code",null,"computed")]),l("th",null,[l("code",null,"watch")])])]),l("tbody",null,[l("tr",null,[l("td",null,"目的 / 语义"),l("td",null,"用于声明式地 “从状态推导 / 派生” 一个响应式的新值"),l("td",null,"用于监听状态变化，执行副作用逻辑（如 API 请求、日志、手动修改等）")]),l("tr",null,[l("td",null,"缓存 / 重算"),l("td",null,"有缓存机制，只有依赖变化时才重新计算"),l("td",null,"每次被监听的源变化时，回调都会执行（无缓存）")]),l("tr",null,[l("td",null,"延迟 / 惰性"),l("td",null,"惰性求值 —— 只有在被访问时才计算"),l("td",null,[n("立即触发（可配置 "),l("code",null,"immediate: true"),n("）")])]),l("tr",null,[l("td",null,"副作用能力"),l("td",null,"不推荐在 computed 中写副作用（应保持纯函数）"),l("td",null,"正是用来执行副作用的场景，如异步操作、状态同步、DOM 操作等")]),l("tr",null,[l("td",null,"输入 / 输出"),l("td",null,"通常是同步逻辑，返回值给模板或其他计算使用"),l("td",null,"回调可接收新值和旧值，执行任意复杂逻辑")]),l("tr",null,[l("td",null,"依赖跟踪"),l("td",null,"自动追踪内部访问的响应式变量作为依赖"),l("td",null,"明确指定被监听的响应式源（ref / reactive / getter 等）")]),l("tr",null,[l("td",null,"是否能监听深层对象 /数组"),l("td",null,[n("默认浅依赖；对于深层嵌套需要用 "),l("code",null,"computed(() => JSON.stringify(...))"),n(" 等技巧")]),l("td",null,[n("可设置 "),l("code",null,"deep: true"),n(" 监听嵌套属性变化")])]),l("tr",null,[l("td",null,"适合场景"),l("td",null,"计算属性、派生状态、模板绑定等"),l("td",null,"异步逻辑、数据拉取、条件触发、清理副作用、观察状态变化等")])])],-1),l("p",null,"原理:",-1),l("ul",null,[l("li",null,[l("p",null,"computed 底层是用 Vue 的响应式系统（effect + 依赖收集）包装的“缓存 getter”机制。只有其内部依赖发生变化时，才重新执行计算。")]),l("li",null,[l("p",null,"watch 则是一个高阶封装，让你监听某个响应式源的变化，并在变化时执行回调。它不会缓存回调的结果，也不会阻止重复调用。")])],-1)])]),_:1}),e[23]||(e[23]=l("h3",{id:"_11-vue3-lis",tabindex:"-1"},[n("11. vue3 lis "),l("a",{class:"header-anchor",href:"#_11-vue3-lis","aria-label":"Permalink to “11. vue3 lis”"},"​")],-1)),t(u,null,{default:a(()=>[...e[10]||(e[10]=[l("p",null,"LIS 在 Diff 中的作用：找出不需要移动的节点，最小化 DOM 操作",-1),l("ul",null,[l("li",null,[l("ol",null,[l("li",null,"将新节点映射到旧节点索引序列")])]),l("li",null,[l("ol",{start:"2"},[l("li",null,"求最长递增子序列（LIS）")])]),l("li",null,[l("ol",{start:"3"},[l("li",null,"非 LIS 节点移动或创建")])])],-1),l("p",null,"能够降低时间复杂度;大型表格、树结构、虚拟列表和移动频繁但大部分节点不变的场景, 效果好.",-1)])]),_:1}),e[24]||(e[24]=l("h3",{id:"_12-vue3-类似react-hooks的原理是什么",tabindex:"-1"},[n("12. vue3 类似react hooks的原理是什么? "),l("a",{class:"header-anchor",href:"#_12-vue3-类似react-hooks的原理是什么","aria-label":"Permalink to “12. vue3 类似react hooks的原理是什么?”"},"​")],-1)),t(u,null,{default:a(()=>[...e[11]||(e[11]=[l("p",null,"Composition API（组合式 API）。 虽然它们在目的（解决状态逻辑复用、组织代码）上非常相似，但它们的核心实现原理完全不同。",-1),l("ul",null,[l("li",null,"React Hooks 的原理：基于“调用顺序”和“链表”"),l("li",null,"Vue Composition API 的原理：基于“响应式系统”和“依赖追踪”")],-1),l("p",null,"React Hooks 的核心原理:",-1),l("ul",null,[l("li",null,"核心机制：基于“调用顺序”"),l("li",null,"运行方式： React 组件的函数体在每次渲染时都会重新执行。")],-1),l("p",null,[n("React 在内部为每个组件实例维护了一个"),l("strong",null,"特殊数据结构（可以想象成一个数组或链表）"),n("来存储 Hooks 的状态。 这就是为什么 React Hooks 有严格的“规则”：")],-1),l("ul",null,[l("li",null,"不能在条件（if）或循环（for）中调用 Hooks。"),l("li",null,"必须在函数顶层调用")],-1),l("p",null,"Vue Composition API 的核心原理: Vue 的原理则完全不同，它不依赖于“调用顺序”，因此没有 React Hooks 的那些限制。",-1),l("ul",null,[l("li",null,"核心机制：基于“响应式系统”（Reactivity System）"),l("li",null,"运行方式： setup() 函数在组件实例创建时只执行一次。")],-1),l("p",null,"Vue 3 的响应式系统是独立于组件的。当你调用 ref 或 reactive 时，你创建的是一个独立的、可被追踪的响应式对象。",-1),l("p",null,"setup() 只执行一次 这是与 React 的最大区别。",-1),l("ul",null,[l("li",null,"React 的函数组件每次渲染都会重新执行，所以它需要“调用顺序”来找回状态。"),l("li",null,"Vue 的 setup() 只在组件初始化时执行一次。")],-1),l("p",null,[l("strong",null,"ref 和 reactive 创建的状态只被创建一次，然后被闭包引用，它们在组件的整个生命周期中都是持久的。")],-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"特性"),l("th",null,"React Hooks"),l("th",null,"Vue Composition API")])]),l("tbody",null,[l("tr",null,[l("td",null,"核心原理"),l("td",null,"调用顺序 (Call Order)"),l("td",null,"依赖追踪 (Dependency Tracking)")]),l("tr",null,[l("td",null,"状态机制"),l("td",null,"React 内部的链表/数组"),l("td",null,"独立的响应式对象 (Proxy / Ref)")]),l("tr",null,[l("td",null,"函数执行"),l("td",null,"组件函数每次渲染都执行"),l("td",null,"setup() 只执行一次")]),l("tr",null,[l("td",null,"使用限制"),l("td",null,"有（Rules of Hooks，不能在 if/for 中）"),l("td",null,"无（可以在 if/for 中，因为状态是独立的）")]),l("tr",null,[l("td",null,"心智模型"),l("td",null,"“每次渲染都是全新的”"),l("td",null,"“状态是持久的，当它变化时自动触发更新”")])])],-1)])]),_:1})])}const b=s(d,[["render",p]]);export{v as __pageData,b as default};
