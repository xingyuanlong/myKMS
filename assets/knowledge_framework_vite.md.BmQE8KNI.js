import{_ as a,I as r,c as d,o as s,j as l,J as u,ai as o,a as n,w as i}from"./chunks/framework.Dp-6g2cw.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/framework/vite.md","filePath":"knowledge/framework/vite.md"}'),p={name:"knowledge/framework/vite.md"};function g(b,t,S,f,k,m){const e=r("Collapse");return s(),d("div",null,[t[14]||(t[14]=l("h2",{id:"webpack",tabindex:"-1"},[n("webpack "),l("a",{class:"header-anchor",href:"#webpack","aria-label":"Permalink to “webpack”"},"​")],-1)),t[15]||(t[15]=l("h3",{id:"_1-webpack-的工作流程",tabindex:"-1"},[n("1.Webpack 的工作流程 "),l("a",{class:"header-anchor",href:"#_1-webpack-的工作流程","aria-label":"Permalink to “1.Webpack 的工作流程”"},"​")],-1)),u(e,null,{default:i(()=>[...t[0]||(t[0]=[l("p",null,"Webpack 的工作流程",-1),l("ul",null,[l("li",null,[l("ol",null,[l("li",null,"入口（Entry）：从指定文件（如 index.js）开始分析依赖。")])]),l("li",null,[l("ol",{start:"2"},[l("li",null,"依赖图（Dependency Graph）：递归构建模块间的依赖关系。")])]),l("li",null,[l("ol",{start:"3"},[l("li",null,"加载器（Loaders）：转换非 JS 资源（如编译 Sass、处理图片）。")])]),l("li",null,[l("ol",{start:"4"},[l("li",null,"插件（Plugins）：在构建生命周期中执行优化任务。")])]),l("li",null,[l("ol",{start:"5"},[l("li",null,"输出（Output）：生成优化后的静态文件（如 bundle.js）。")])])],-1)])]),_:1}),t[16]||(t[16]=l("h3",{id:"_2-webpack-中的-loaders-和-plugins-有什么区别",tabindex:"-1"},[n("2.Webpack 中的 Loaders 和 Plugins 有什么区别 "),l("a",{class:"header-anchor",href:"#_2-webpack-中的-loaders-和-plugins-有什么区别","aria-label":"Permalink to “2.Webpack 中的 Loaders 和 Plugins 有什么区别”"},"​")],-1)),u(e,null,{default:i(()=>[...t[1]||(t[1]=[l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",{style:{"text-align":"left"}},"对比项"),l("th",{style:{"text-align":"left"}},[l("strong",null,"Loader")]),l("th",{style:{"text-align":"left"}},[l("strong",null,"Plugin")])])]),l("tbody",null,[l("tr",null,[l("td",{style:{"text-align":"left"}},"作用阶段"),l("td",{style:{"text-align":"left"}},"文件加载、转换阶段（打包前）"),l("td",{style:{"text-align":"left"}},"编译、打包的整个生命周期")]),l("tr",null,[l("td",{style:{"text-align":"left"}},"操作对象"),l("td",{style:{"text-align":"left"}},"单个模块文件（JS、CSS、图片等）"),l("td",{style:{"text-align":"left"}},"整个编译过程（模块、资源、chunk、输出）")]),l("tr",null,[l("td",{style:{"text-align":"left"}},"类型"),l("td",{style:{"text-align":"left"}},"转换器（Transformer）"),l("td",{style:{"text-align":"left"}},"扩展器（Enhancer）")]),l("tr",null,[l("td",{style:{"text-align":"left"}},"常见用途"),l("td",{style:{"text-align":"left"}},"把非 JS 资源转成 JS 模块"),l("td",{style:{"text-align":"left"}},"优化、注入、压缩、环境变量等")]),l("tr",null,[l("td",{style:{"text-align":"left"}},"调用方式"),l("td",{style:{"text-align":"left"}},[l("code",null,"module.rules"),n(" 中配置 "),l("code",null,"use")]),l("td",{style:{"text-align":"left"}},[l("code",null,"plugins"),n(" 数组中配置")])]),l("tr",null,[l("td",{style:{"text-align":"left"}},"工作机制"),l("td",{style:{"text-align":"left"}},"线性执行（从右到左）"),l("td",{style:{"text-align":"left"}},"基于 Tapable 的事件钩子机制")]),l("tr",null,[l("td",{style:{"text-align":"left"}},"示例"),l("td",{style:{"text-align":"left"}},[l("code",null,"babel-loader"),n(", "),l("code",null,"css-loader"),n(", "),l("code",null,"url-loader")]),l("td",{style:{"text-align":"left"}},[l("code",null,"HtmlWebpackPlugin"),n(", "),l("code",null,"DefinePlugin"),n(", "),l("code",null,"MiniCssExtractPlugin")])])])],-1),l("p",null,"Loader 执行机制",-1),l("ul",null,[l("li",null,"串行执行（从右到左）；"),l("li",null,"每个 loader 接收上一个 loader 的结果；"),l("li",null,"只能处理文件内容字符串；"),l("li",null,"是一个纯函数（无副作用）。")],-1),l("p",null,"Plugin 执行机制",-1),l("ul",null,[l("li",null,"通过 Webpack 的 Tapable 钩子系统；"),l("li",null,"插入到 Webpack 的编译生命周期中；"),l("li",null,"可以访问 compiler、compilation 对象；"),l("li",null,"可读可写资源、依赖、输出、日志等。")],-1)])]),_:1}),t[17]||(t[17]=l("h3",{id:"_3-tree-shaking",tabindex:"-1"},[n("3.Tree Shaking "),l("a",{class:"header-anchor",href:"#_3-tree-shaking","aria-label":"Permalink to “3.Tree Shaking”"},"​")],-1)),u(e,null,{default:i(()=>[...t[2]||(t[2]=[l("p",null,"Tree Shaking = 静态分析 + dead code elimination",-1),l("ul",null,[l("li",null,"去除未使用代码的技术, ESM 的 import/export 是静态分析的. 本质目标：减少打包体积，把代码中 未引用的函数、变量、类 剔除掉。"),l("li",null,[n("支持条件: "),l("ul",null,[l("li",null,"必须使用 ES Module;"),l("li",null,"导出必须是静态; 副作用(如果模块执行会有副作用（如修改全局变量），Tree Shaking 默认不会移除整个模块)."),l("li",null,"动态 import 可以按需加载，但静态分析更高效;"),l("li",null,"类库打包方式影响 Tree Shaking(lodash/es → 支持 Tree Shaking,lodash → CommonJS，不支持)")])])],-1),l("ol",null,[l("li",null,[l("p",null,"静态分析：树摇依赖于ES2015模块语法（即 import 和 export ），因为这些语法声明是静态的，使得构建工具在编译时就能确定哪些代码是没有被使用的。")]),l("li",null,[l("p",null,"标记未使用的导出：构建工具会遍历所有的导出项，标记那些在工程中未被其他模块引用的导出。")]),l("li",null,[l("p",null,"移除未引用代码：在最终的打包文件中移除那些未被引用的代码，这样做不仅减少了文件大小，还能提高应用的加载速度和性能。")])],-1)])]),_:1}),t[18]||(t[18]=l("h3",{id:"_4-tree-shaking-对-css-有效吗",tabindex:"-1"},[n("4. Tree Shaking 对 css 有效吗 "),l("a",{class:"header-anchor",href:"#_4-tree-shaking-对-css-有效吗","aria-label":"Permalink to “4. Tree Shaking 对 css 有效吗”"},"​")],-1)),u(e,null,{default:i(()=>[...t[3]||(t[3]=[l("ul",null,[l("li",null,[l("p",null,"纯 CSS 文件"),l("ul",null,[l("li",null,"Tree Shaking 无法分析哪些 CSS 类使用或未使用"),l("li",null,"所以 未使用的 CSS 默认不会被移除")])]),l("li",null,[l("p",null,"CSS-in-JS / CSS Module"),l("ul",null,[l("li",null,"CSS-in-JS（如 styled-components, emotion）生成的 JS 代码"),l("li",null,"对未使用的 styled 组件，Webpack/Rollup 的 Tree Shaking 可以删除对应 JS，从而间接删除样式"),l("li",null,"但这需要 样式写在 JS 里，纯 CSS 文件不适用")])]),l("li",null,[l("p",null,"tailwind / PostCSS / PurgeCSS"),l("ul",null,[l("li",null,"对于类名型 CSS（如 Tailwind、Bootstrap）"),l("li",null,"可以使用工具 扫描项目源码，删除未使用类"),l("li",null,"原理类似 Tree Shaking，但实际上是 静态 CSS 去重，不依赖 JS Tree Shaking")])])],-1)])]),_:1}),t[19]||(t[19]=l("h3",{id:"_5-webpack-runtime-是啥",tabindex:"-1"},[n("5. webpack runtime 是啥 "),l("a",{class:"header-anchor",href:"#_5-webpack-runtime-是啥","aria-label":"Permalink to “5. webpack runtime 是啥”"},"​")],-1)),u(e,null,{default:i(()=>[...t[4]||(t[4]=[l("p",null,[l("strong",null,"webpack runtime = 浏览器端的模块管理器 + 动态加载器 + 缓存器")],-1),l("p",null,"webpack 为了在浏览器执行模块打包后的代码而生成的一套加载、执行、管理模块的核心逻辑。",-1),l("p",null,"负责:",-1),l("ul",null,[l("li",null,[n("加载模块 ("),l("strong",null,"webpack_require"),n(") "),l("ul",null,[l("li",null,"核心加载器，用来执行模块函数并返回 exports"),l("li",null,[n("每个模块在打包后都变成一个函数 "),l("code",null,"(module, exports, **webpack_require**) => { … }")])])]),l("li",null,[n("缓存模块 "),l("ul",null,[l("li",null,"webpack 会把每个模块的执行结果缓存，避免重复执行：")])]),l("li",null,[n("支持动态 import / chunk 加载 "),l("ul",null,[l("li",null,"JSONP 或 Module Federation 加载"),l("li",null,"chunk 加载状态表")])]),l("li",null,[n("处理热更新（HMR） "),l("ul",null,[l("li",null,"监听更新的 chunk；"),l("li",null,"动态替换模块内容，不刷新页面")])])],-1)])]),_:1}),t[20]||(t[20]=l("h3",{id:"_6-webpack-有哪些优化项目的手段",tabindex:"-1"},[n("6. webpack 有哪些优化项目的手段？ "),l("a",{class:"header-anchor",href:"#_6-webpack-有哪些优化项目的手段","aria-label":"Permalink to “6. webpack  有哪些优化项目的手段？”"},"​")],-1)),u(e,null,{default:i(()=>[...t[5]||(t[5]=[l("p",null,"围绕 webpack 做性能优化，分为两个方面： 构建时间优化 、 构建体积优化",-1),l("ul",null,[l("li",null,[l("p",null,"构建时间优化"),l("ul",null,[l("li",null,"缩小范围"),l("li",null,"文件后缀"),l("li",null,"别名"),l("li",null,"缓存"),l("li",null,"并行构建(多核心)"),l("li",null,"定向查找第三方模块")])]),l("li",null,[l("p",null,"构建结果优化"),l("ul",null,[l("li",null,"压缩 js"),l("li",null,"压缩 css"),l("li",null,"压缩 html"),l("li",null,"压缩图片"),l("li",null,"按需加载"),l("li",null,"prload、prefetch"),l("li",null,"代码分割"),l("li",null,"tree shaking"),l("li",null,"gzip"),l("li",null,"作用域提升")])])],-1)])]),_:1}),t[21]||(t[21]=l("h2",{id:"vite",tabindex:"-1"},[n("vite "),l("a",{class:"header-anchor",href:"#vite","aria-label":"Permalink to “vite”"},"​")],-1)),t[22]||(t[22]=l("h3",{id:"_1-简述vite的依赖预加载机制",tabindex:"-1"},[n("1. 简述Vite的依赖预加载机制 "),l("a",{class:"header-anchor",href:"#_1-简述vite的依赖预加载机制","aria-label":"Permalink to “1. 简述Vite的依赖预加载机制”"},"​")],-1)),u(e,null,{default:i(()=>[...t[6]||(t[6]=[l("p",null,[l("strong",null,"Vite 的依赖预构建机制通过在开发模式下提前处理常用依赖（如 Vue、React 等），将这些依赖转换为浏览器可以直接执行的格式。这避免了每次启动时重新编译这些依赖，显著提升了启动速度。"),n(" 预构建的依赖被缓存，并在后续启动时复用缓存，进一步加速了开发过程中的构建和启动时间。")],-1),l("p",null,"具体来说，它的工作原理如下：",-1),l("ol",null,[l("li",null,"依赖识别和路径补全： Vite 会首先识别项目中需要的依赖，并对非绝对路径或相对路径的引用进行路径补全。比如，Vue 的加载路径会变为 node_modules/.vite/deps/Vue.js?v=1484ebe8，这一路径显示了 Vite 在 node_modules/.vite/deps 文件夹下存放了经过预处理的依赖文件。"),l("li",null,"转换成 ES 模块： 一些第三方包（特别是遵循 CommonJS 规范的包）在浏览器中无法直接使用。为了应对这种情况，Vite 会使用 esbuild 工具将这些依赖转换为符合 ES 模块规范的代码。转换后的代码会被存放在 node_modules/.vite/deps 文件夹下，这样浏览器就能直接识别并加载这些依赖。"),l("li",null,"统一集成 ES 模块： Vite 会对每个包的不同模块进行统一集成，将各个分散的模块（如不同的 ES 函数或组件）合并成一个或几个文件。这不仅减少了浏览器发起多个请求的次数，还能够加快页面加载速度")],-1)])]),_:1}),t[23]||(t[23]=l("h3",{id:"_2-vite-hmr-模块热更新-与webpack对比",tabindex:"-1"},[n("2. vite HMR 模块热更新 (与webpack对比) "),l("a",{class:"header-anchor",href:"#_2-vite-hmr-模块热更新-与webpack对比","aria-label":"Permalink to “2. vite HMR 模块热更新 (与webpack对比)”"},"​")],-1)),u(e,null,{default:i(()=>[...t[7]||(t[7]=[l("p",null,"修改代码 → 浏览器自动更新 → 状态不丢失",-1),l("p",null,"基本工作原理",-1),l("ol",null,[l("li",null,"开发服务器启动时：Vite 会用 ES Module 的方式向浏览器提供源码。"),l("li",null,"文件变动：Vite 通过 chokidar 监听文件改动。"),l("li",null,"HMR 通知：Vite Dev Server 用 WebSocket 通知浏览器“某个模块变了”。type:'update', updates 更新的文件内容"),l("li",null,"模块替换：浏览器端的 Vite HMR 客户端会：尝试只替换改动的模块（比如 .vue 组件、.css 文件）。如i18n.json 文件修改, 会刷新页面"),l("li",null,"import.meta.hot 可以手动控制 HMR 行为"),l("li",null,"Vite 内部维护一份 模块依赖图,向上传播，找接受更新的模块, 如果无法安全替换（比如入口文件改了），就会触发 整页刷新。")],-1),l("p",null,"Webpack HMR:基本原理一致, 开发时需要 打包，生成 bundle.js, 因为有打包过程，HMR 会比 Vite 慢",-1),l("p",null,"为什么 Vite 的 HMR 比 Webpack 快？",-1),l("ol",null,[l("li",null,[l("strong",null,"Vite 基于 原生 ESM，不用重新打整个 bundle。")]),l("li",null,[l("strong",null,"改动时只编译改动文件（按需编译）。")]),l("li",null,[l("strong",null,"Webpack 需要走完整的打包流程，依赖图越大更新越慢。")]),l("li",null,"所以在大项目里，Webpack 热更新可能要几秒，而 Vite 通常 <100ms。")],-1),l("p",null,"Vite 如何实现 React/Vue 的状态保留热更新？",-1),l("ol",null,[l("li",null,"React：通过 @vitejs/plugin-react 集成 react-refresh，在替换组件时保留 Hook 状态。"),l("li",null,"Vue：通过 @vitejs/plugin-vue，在替换 .vue 组件时保留组件实例的响应式状态。"),l("li",null,"本质：框架层插件拦截 HMR 更新过程，执行“局部替换 + 状态迁移”。")],-1),l("p",null,"Vite HMR 可能带来的问题？",-1),l("ol",null,[l("li",null,"内存泄漏：模块替换时没清理事件监听 / 定时器。"),l("li",null,"调试复杂度：和实际生产行为不一致（生产中没有 HMR）。"),l("li",null,"兼容性问题：某些第三方库没有 HMR 支持，只能整页刷新")],-1)])]),_:1}),t[24]||(t[24]=l("h3",{id:"_3-webpack-与-vite",tabindex:"-1"},[n("3.Webpack 与 Vite "),l("a",{class:"header-anchor",href:"#_3-webpack-与-vite","aria-label":"Permalink to “3.Webpack 与 Vite”"},"​")],-1)),u(e,null,{default:i(()=>[...t[8]||(t[8]=[l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",{style:{"text-align":"left"}},"对比项"),l("th",{style:{"text-align":"left"}},[l("strong",null,"Webpack")]),l("th",{style:{"text-align":"left"}},[l("strong",null,"Vite")])])]),l("tbody",null,[l("tr",null,[l("td",{style:{"text-align":"left"}},[l("strong",null,"核心思想")]),l("td",{style:{"text-align":"left"}},[n("一次性"),l("strong",null,"打包所有文件"),n("再启动开发服务器")]),l("td",{style:{"text-align":"left"}},[l("strong",null,"按需编译（ESM 原生支持）"),n("，依赖与源码分离处理")])]),l("tr",null,[l("td",{style:{"text-align":"left"}},[l("strong",null,"启动阶段")]),l("td",{style:{"text-align":"left"}},"需先打包整个项目（构建依赖图 → 打包输出）"),l("td",{style:{"text-align":"left"}},"启动极快，仅分析依赖，不预打包源码")]),l("tr",null,[l("td",{style:{"text-align":"left"}},[l("strong",null,"开发模式 (dev)")]),l("td",{style:{"text-align":"left"}},[n("使用 webpack-dev-server："),l("br"),n("所有模块打包成 bundle 后再提供服务")]),l("td",{style:{"text-align":"left"}},[n("使用原生 ESM："),l("br"),n("直接通过浏览器请求模块，Vite 拦截并按需编译返回")])]),l("tr",null,[l("td",{style:{"text-align":"left"}},[l("strong",null,"热更新 (HMR)")]),l("td",{style:{"text-align":"left"}},"修改文件后需重新打包相关 chunk，代价较高"),l("td",{style:{"text-align":"left"}},"仅重新编译变动的模块源码（原生 ESM 热替换），非常快")]),l("tr",null,[l("td",{style:{"text-align":"left"}},[l("strong",null,"构建阶段 (build)")]),l("td",{style:{"text-align":"left"}},"打包时用 loader + plugin 处理所有文件，输出 bundle"),l("td",{style:{"text-align":"left"}},[n("构建阶段由 "),l("strong",null,"Rollup"),n(" 完成打包（利用 ESM 静态分析）")])]),l("tr",null,[l("td",{style:{"text-align":"left"}},[l("strong",null,"打包粒度")]),l("td",{style:{"text-align":"left"}},"依赖与源码一起打包成 bundle"),l("td",{style:{"text-align":"left"}},"依赖单独预构建（esbuild），源码按需处理")]),l("tr",null,[l("td",{style:{"text-align":"left"}},[l("strong",null,"依赖处理")]),l("td",{style:{"text-align":"left"}},"JS、CSS、图片等都需 loader 解析"),l("td",{style:{"text-align":"left"}},[n("依赖模块（node_modules）由 "),l("strong",null,"esbuild"),n(" 预构建，源码按请求动态编译")])]),l("tr",null,[l("td",{style:{"text-align":"left"}},[l("strong",null,"性能瓶颈")]),l("td",{style:{"text-align":"left"}},"打包体积大、编译速度慢（依赖 AST 分析）"),l("td",{style:{"text-align":"left"}},[n("使用 "),l("strong",null,"esbuild（Go 编写）"),n("，依赖构建快 10-100 倍")])]),l("tr",null,[l("td",{style:{"text-align":"left"}},[l("strong",null,"构建结果")]),l("td",{style:{"text-align":"left"}},"输出多个 bundle 文件"),l("td",{style:{"text-align":"left"}},"输出原生 ESM 模块（经 Rollup 优化）")]),l("tr",null,[l("td",{style:{"text-align":"left"}},[l("strong",null,"适用场景")]),l("td",{style:{"text-align":"left"}},"大型复杂项目，生态成熟（如 React + Webpack5）"),l("td",{style:{"text-align":"left"}},"快速开发、现代浏览器环境（Vue3、React18）")]),l("tr",null,[l("td",{style:{"text-align":"left"}},[l("strong",null,"插件机制")]),l("td",{style:{"text-align":"left"}},"Tapable 构建的复杂插件系统"),l("td",{style:{"text-align":"left"}},"Rollup + Vite Hook，轻量、直观")]),l("tr",null,[l("td",{style:{"text-align":"left"}},[l("strong",null,"配置复杂度")]),l("td",{style:{"text-align":"left"}},"配置项繁多（entry、loader、plugin 等）"),l("td",{style:{"text-align":"left"}},"默认开箱即用，配置极简（vite.config.js）")]),l("tr",null,[l("td",{style:{"text-align":"left"}},[l("strong",null,"首次启动速度")]),l("td",{style:{"text-align":"left"}},"慢：需先打完整包"),l("td",{style:{"text-align":"left"}},"快：直接启动服务器即可运行")]),l("tr",null,[l("td",{style:{"text-align":"left"}},[l("strong",null,"生产打包速度")]),l("td",{style:{"text-align":"left"}},"中等（依赖 JS 解析打包）"),l("td",{style:{"text-align":"left"}},"快：esbuild + Rollup 组合优化")]),l("tr",null,[l("td",{style:{"text-align":"left"}},[l("strong",null,"调试体验")]),l("td",{style:{"text-align":"left"}},"源码被打包，调试路径复杂"),l("td",{style:{"text-align":"left"}},"源码即模块，调试路径清晰")]),l("tr",null,[l("td",{style:{"text-align":"left"}},[l("strong",null,"静态资源处理")]),l("td",{style:{"text-align":"left"}},"需配置 loader（file-loader/url-loader）"),l("td",{style:{"text-align":"left"}},"内置资源处理机制，直接 import 即可")]),l("tr",null,[l("td",{style:{"text-align":"left"}},[l("strong",null,"依赖缓存")]),l("td",{style:{"text-align":"left"}},"可配置 cache-loader"),l("td",{style:{"text-align":"left"}},"自动缓存依赖（esbuild 缓存 + HTTP 缓存）")])])],-1),l("ul",null,[l("li",null,[l("p",null,"webpack 的打包流程: 读取配置 → 创建 Compiler → 从入口构建依赖图 → Loader 转换模块 → Plugin 优化 → 生成 Chunk → 输出文件。")]),l("li",null,[l("p",null,"vite 开发时走原生 ESM + 按需编译，而生产环境走 Rollup 打包。vite 打包流程: 配置解析 -> 调用 Rollup 构建 -> 优化处理 -> 产物生成")])],-1)])]),_:1}),t[25]||(t[25]=l("h3",{id:"_4-ssr-是啥-对比csr的优势和适用场景",tabindex:"-1"},[n("4.ssr 是啥, 对比csr的优势和适用场景 "),l("a",{class:"header-anchor",href:"#_4-ssr-是啥-对比csr的优势和适用场景","aria-label":"Permalink to “4.ssr 是啥, 对比csr的优势和适用场景”"},"​")],-1)),u(e,null,{default:i(()=>[...t[9]||(t[9]=[l("p",null,"SSR（Server-Side Rendering） 是指在服务器端生成 HTML 内容，再发送到浏览器渲染，而不是浏览器端通过 JS 生成 DOM。",-1),l("p",null,"SSR 的核心实现原理: SSR 的核心在于“同构（Isomorphic）”或“通用（Universal）”应用——即一套代码（通常是 React, Vue, Svelte 等）既能在服务器上运行，也能在客户端上运行。",-1),l("p",null,"核心实现流程如下：",-1),l("ol",null,[l("li",null,[l("p",null,"请求到达服务器")]),l("li",null,[l("p",null,"服务器端路由与数据获取")])],-1),l("ul",null,[l("li",null,"路由匹配: 服务器根据请求的 URL 匹配到对应的页面组件"),l("li",null,"数据预取: 服务器在渲染组件之前，会执行该页面组件定义的“服务器端数据获取函数”（例如 Next.js 中的 getServerSideProps）。它会去调用数据库或 API，获取 ID 为 123 的产品数据。")],-1),l("ol",{start:"3"},[l("li",null,"服务器端渲染（Render to String）")],-1),l("ul",null,[l("li",null,"服务器使用框架提供的服务器端渲染 API（例如 React 的 ReactDOMServer.renderToString()）来“执行”组件。"),l("li",null,"由于在第 2 步已经获取了数据，组件会被填充完整的数据（产品名称、价格、描述等）。"),l("li",null,"这个执行过程的产物不是一个虚拟 DOM，而是一个完整的 HTML 字符串。")],-1),l("ol",{start:"4"},[l("li",null,"响应与首次渲染")],-1),l("ul",null,[l("li",null,"服务器将这个完整的 HTML 字符串打包成一个 HTTP 响应，发送给浏览器。"),l("li",null,"浏览器接收到 HTML 后，立即解析并渲染。用户此时立刻就能看到页面的完整内容（这就是首屏加载极快的原因）。"),l("li",null,"注意：此时的页面只是“静态的”，没有任何交互（点击按钮没反应），因为它对应的 JavaScript 还没执行。")],-1),l("ol",{start:"5"},[l("li",null,[n("Hydration（注水/激活） "),l("ul",null,[l("li",null,"在浏览器渲染 HTML 的同时，它会开始下载 CSR 模式下也需要的 JavaScript 包（例如 app.js）。"),l("li",null,"JS 下载并执行后，框架（如 React/Vue）会在客户端再次运行。"),l("li",null,[n("但它不会粗暴地重新渲染并替换所有 DOM，而是执行一个称为 "),l("strong",null,'"Hydration"（注水）'),n("的过程。")]),l("li",null,[n("Hydration 会"),l("strong",null,"“接管”"),n("服务器渲染的静态 DOM，遍历虚拟 DOM 和真实 DOM，将事件监听器（如 onClick）附加到现有的 HTML 元素上。")]),l("li",null,"这个过程完成后，页面就从“静态 HTML”变成了“可交互的单页应用（SPA）”。")])])],-1),l("p",null,[n("核心流程图： "),l("strong",null,"用户请求 → 服务器路由 → 服务器获取数据 → 服务器渲染 (生成HTML字符串) → 浏览器接收HTML并立即显示 → (并行)浏览器下载JS → JS执行 (Hydration) → 页面完全可交互")],-1),l("p",null,"SSR 相比 CSR 的不可替代优势:",-1),l("p",null,"CSR 最大的问题是“白屏时间长”和“SEO 灾难”。SSR 正是为解决这两个核心痛点而生，在以下场景具有不可替代的优势：",-1),l("ul",null,[l("li",null,"搜索引擎优化 (SEO)"),l("li",null,"极致的“首屏加载速度”（FCP）")],-1)])]),_:1}),t[26]||(t[26]=l("h3",{id:"_5-微前端-import-html-entry-场景下-子应用中存在路由懒加载-dynamic-import-的情况-import-html-entry-会如何处理或者需要注意什么",tabindex:"-1"},[n("5.微前端 / import-html-entry 场景下，子应用中存在路由懒加载（dynamic import）的情况，import-html-entry 会如何处理或者需要注意什么 "),l("a",{class:"header-anchor",href:"#_5-微前端-import-html-entry-场景下-子应用中存在路由懒加载-dynamic-import-的情况-import-html-entry-会如何处理或者需要注意什么","aria-label":"Permalink to “5.微前端 / import-html-entry 场景下，子应用中存在路由懒加载（dynamic import）的情况，import-html-entry 会如何处理或者需要注意什么”"},"​")],-1)),u(e,null,{default:i(()=>[...t[10]||(t[10]=[l("p",null,"import-html-entry 默认只处理 index.html 中的静态 script 和 link，所以懒加载模块不会被提前 fetch 或 exec。懒加载模块会在子应用自己的 webpack runtime 中正常 fetch（通过 publicPath 拼接 URL），然后动态加载。",-1),l("ul",null,[l("li",null,[l("p",null,"懒加载的模块执行时会使用子应用的 runtime（webpackJsonp / webpackChunk），所以如果你在 import-html-entry 里用 sandbox proxy window，需要把 webpackJsonp / webpack_require 等 runtime 挂到 proxy 上，确保 chunk 加载执行正常。")]),l("li",null,[l("p",null,"qiankun 会在 execScripts 中注入 sandbox proxy，保证动态 import 能访问 webpack runtime。")])],-1)])]),_:1}),t[27]||(t[27]=l("h3",{id:"_6-css-in-js-的优缺点",tabindex:"-1"},[n("6. CSS-in-JS 的优缺点 "),l("a",{class:"header-anchor",href:"#_6-css-in-js-的优缺点","aria-label":"Permalink to “6. CSS-in-JS  的优缺点”"},"​")],-1)),u(e,null,{default:i(()=>[...t[11]||(t[11]=[l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"优点"),l("th",null,"说明"),l("th",null,"实际收益")])]),l("tbody",null,[l("tr",null,[l("td",null,[l("strong",null,"1️⃣ 样式作用域自动隔离")]),l("td",null,"每个组件的样式自动作用于自身，不会影响全局或其他组件"),l("td",null,"避免 CSS 命名冲突、全局污染")]),l("tr",null,[l("td",null,[l("strong",null,"2️⃣ 动态样式支持（基于状态）")]),l("td",null,"可以直接使用 JS 变量、props、state 动态控制样式"),l("td",null,"让样式与逻辑无缝联动（例如根据主题、交互状态变化）")]),l("tr",null,[l("td",null,[l("strong",null,"3️⃣ 真正的组件化开发体验")]),l("td",null,"样式与组件逻辑紧密绑定在一起（co-located）"),l("td",null,"提高可维护性与可读性，代码结构更清晰")]),l("tr",null,[l("td",null,[l("strong",null,"4️⃣ 消除了全局命名问题")]),l("td",null,"自动生成唯一 className（hash）"),l("td",null,"无需再手动设计命名规范（如 BEM / SMACSS）")]),l("tr",null,[l("td",null,[l("strong",null,"5️⃣ 支持服务端渲染（SSR）与关键路径 CSS 提取")]),l("td",null,"框架（如 styled-components）可在 SSR 阶段注入 CSS"),l("td",null,"提高首屏性能、避免闪烁（FOUC）")]),l("tr",null,[l("td",null,[l("strong",null,"6️⃣ 更好的主题系统支持")]),l("td",null,"内置 ThemeProvider 概念，可动态切换主题"),l("td",null,"适合暗黑模式、品牌主题等需求")]),l("tr",null,[l("td",null,[l("strong",null,"7️⃣ 死代码消除（Tree Shaking 友好）")]),l("td",null,"未使用组件的样式不会被打包"),l("td",null,"打包体积更小、更干净")]),l("tr",null,[l("td",null,[l("strong",null,"8️⃣ 类型安全（TypeScript 集成）")]),l("td",null,"样式属性有类型提示与检查"),l("td",null,"减少拼写错误与无效样式")]),l("tr",null,[l("td",null,[l("strong",null,"9️⃣ 样式动态计算能力")]),l("td",null,"可以编写逻辑，如条件判断、循环、计算值"),l("td",null,"复杂 UI 响应更灵活（如动态 grid、尺寸）")]),l("tr",null,[l("td",null,[l("strong",null,"🔟 无需独立 CSS 构建管线")]),l("td",null,"不依赖 CSS Loader / PostCSS"),l("td",null,"前端构建配置更轻量（尤其在 Vite 等环境）")])])],-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"缺点"),l("th",null,"说明")])]),l("tbody",null,[l("tr",null,[l("td",null,[l("strong",null,"运行时开销")]),l("td",null,"一些库（如 styled-components）会在运行时动态生成样式，性能略低")]),l("tr",null,[l("td",null,[l("strong",null,"构建体积稍大")]),l("td",null,"比纯 CSS 稍重，需要额外 runtime")]),l("tr",null,[l("td",null,[l("strong",null,"调试难度")]),l("td",null,"虽然 devtools 支持不错，但不如传统 CSS 文件直观")]),l("tr",null,[l("td",null,[l("strong",null,"学习成本")]),l("td",null,"对初学者来说，需要理解 styled-components 或 Emotion API")])])],-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"场景"),l("th",null,"是否推荐使用 CSS-in-JS")])]),l("tbody",null,[l("tr",null,[l("td",null,"设计系统 / UI 库（需要主题支持）"),l("td",null,"✅ 强烈推荐")]),l("tr",null,[l("td",null,"React / Vue 组件化项目"),l("td",null,"✅ 推荐")]),l("tr",null,[l("td",null,"静态网站（CSS 变化少）"),l("td",null,"⚙️ 可选")]),l("tr",null,[l("td",null,"大型老项目（已用 SASS/BEM）"),l("td",null,"⚠️ 慎重迁移，成本较高")])])],-1)])]),_:1}),t[28]||(t[28]=l("h3",{id:"_7-monorepo-仓库如何控制权限",tabindex:"-1"},[n("7. monorepo 仓库如何控制权限 "),l("a",{class:"header-anchor",href:"#_7-monorepo-仓库如何控制权限","aria-label":"Permalink to “7. monorepo 仓库如何控制权限”"},"​")],-1)),u(e,null,{default:i(()=>[...t[12]||(t[12]=[l("p",null,"因为所有代码都在一个 Git 仓库里，如果不设计好，任何人都能改任何模块，会带来安全、合规和代码质量风险。",-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"层级"),l("th",null,"工具 / 方式"),l("th",null,"控制能力"),l("th",null,"适合规模")])]),l("tbody",null,[l("tr",null,[l("td",null,"1️⃣ Git 层"),l("td",null,"CODEOWNERS + 分支保护"),l("td",null,"控制谁能合并哪部分代码"),l("td",null,"小到中型团队")]),l("tr",null,[l("td",null,"2️⃣ CI 层"),l("td",null,"Path filter（路径过滤）"),l("td",null,"CI 只跑/部署有权限的项目"),l("td",null,"中大型")]),l("tr",null,[l("td",null,"3️⃣ 代码评审层"),l("td",null,"Review rule + PR 模板"),l("td",null,"自动要求特定 reviewer 审核"),l("td",null,"中大型")]),l("tr",null,[l("td",null,"4️⃣ Monorepo 管理层"),l("td",null,"Nx/Turborepo + Access Rules"),l("td",null,"可视化依赖图+权限边界"),l("td",null,"大型团队")]),l("tr",null,[l("td",null,"5️⃣ 组织层（GitHub/GitLab）"),l("td",null,"Team / Group 权限配置"),l("td",null,"精确到团队目录"),l("td",null,"超大型（多部门）")])])],-1),l("ol",null,[l("li",null,"GitHub / GitLab CODEOWNERS 文件")],-1),l("div",{class:"language-"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"}),l("pre",{class:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabindex:"0",dir:"ltr"},[l("code",null,[l("span",{class:"line"},[l("span",null,"# CODEOWNERS")]),n(`
`),l("span",{class:"line"},[l("span",null,"/apps/web/*          @frontend-team")]),n(`
`),l("span",{class:"line"},[l("span",null,"/apps/admin/*        @admin-team")]),n(`
`),l("span",{class:"line"},[l("span",null,"/packages/utils/*    @core-lib-team")]),n(`
`),l("span",{class:"line"},[l("span",null,"/packages/api/*      @backend-team")])])])],-1),l("p",null,"作用：",-1),l("p",null,"触发 PR 时自动要求指定团队审核；",-1),l("p",null,"没有通过指定 Reviewer 的批准不能 merge；",-1),l("p",null,"搭配 分支保护（Branch Protection Rules） 可强制执行。",-1),l("p",null,"✅ 适用：中小团队；简单易行；GitHub/GitLab 都支持。",-1),l("p",null,"2.Git 平台组织级权限",-1),l("p",null,"在 GitHub / GitLab 里：",-1),l("p",null,"每个项目路径对应一个 Team（如 frontend, backend, ops）；",-1),l("p",null,"给不同路径分配 读/写/审查 权限；",-1),l("p",null,"对外协作者仅开放特定子目录（GitLab 支持 Subgroup ACL 更细）。",-1)])]),_:1}),t[29]||(t[29]=l("h3",{id:"_8-esbuild",tabindex:"-1"},[n("8. esbuild "),l("a",{class:"header-anchor",href:"#_8-esbuild","aria-label":"Permalink to “8. esbuild”"},"​")],-1)),u(e,null,{default:i(()=>[...t[13]||(t[13]=[l("p",null,[n("esbuild 是一个用 Go 写的超快前端构建工具，定位是"),l("strong",null,"JavaScript/CSS 的打包器（bundler）+ 转译器（transformer）+ 压缩器（minifier）"),n("，很多工具（Vite、Angular、Rails、Netlify Functions 等）都会把它当作底层加速引擎来用。")],-1),l("p",null,"运行流程（build 模式）",-1),l("p",null,"从入口文件到输出 bundle，大体是这条流水线：",-1),l("ol",null,[l("li",null,[l("p",null,"读取入口 entryPoints")]),l("li",null,[l("p",null,"解析与扫描（parse/scan）")])],-1),l("ul",null,[l("li",null,"词法/语法解析生成 AST"),l("li",null,"扫描 import/require，收集依赖图（dependency graph）")],-1),l("ol",{start:"3"},[l("li",null,"模块解析（resolve）")],-1),l("ul",null,[l("li",null,"根据路径、条件导出、平台（browser/node）等规则定位真实文件"),l("li",null,"插件的 onResolve 会在这里介入。")],-1),l("ol",{start:"4"},[l("li",null,"加载与转译（load/transform）")],-1),l("ul",null,[l("li",null,"读取源文件"),l("li",null,"按 loader 处理 TS/JSX/CSS/JSON/文本等"),l("li",null,"插件 onLoad 可以替换/生成内容。")],-1),l("ol",{start:"5"},[l("li",null,"链接/打包（link/bundle）")],-1),l("ul",null,[l("li",null,"把依赖图按目标格式拼成一个或多个 chunk"),l("li",null,"进行 tree-shaking、作用域提升、代码分割（如开启 splitting）")],-1),l("ol",{start:"6"},[l("li",null,"优化与输出（minify/print）")],-1),l("ul",null,[l("li",null,"压缩、变量改写、去空白"),l("li",null,"生成 sourcemap"),l("li",null,"写入 outdir/outfile 或直接返回内存结果。")],-1),l("p",null,"transform 模式只走第 2/4/6 的“单文件管线”。",-1),l("p",null,"为什么 esbuild 特别快？",-1),l("ul",null,[l("li",null,"Go 原生实现 + 单体编译器"),l("li",null,"高度并行（多核）"),l("li",null,"极少的中间抽象/对象分配"),l("li",null,"增量构建复用解析结果"),l("li",null,"功能聚焦（不做 Type Checking）")],-1)])]),_:1}),t[30]||(t[30]=o('<h3 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to “其他”">​</a></h3><ul><li>webpack 打包速度分析, speed-measure-webpack-plugin, 打包大小分析: webpack-bundle-analyze</li><li>安装相同的但不同版本的组件库, 取别名 npm i alias@npm:name@^verison</li><li>灰度发布 <ul><li>灰度发布:新版本不是一次性发布给所有用户，而是只让部分用户先体验，逐步扩大范围，最后全量替换旧版本。</li></ul></li></ul><table tabindex="0"><thead><tr><th>对比项</th><th>灰度发布</th><th>蓝绿部署</th></tr></thead><tbody><tr><td>核心思想</td><td>逐步放量验证</td><td>一次性切换</td></tr><tr><td>流量分配</td><td>部分用户</td><td>全量流量</td></tr><tr><td>风险控制</td><td>可逐步调整比例</td><td>立即切换，风险更大</td></tr><tr><td>适用场景</td><td>新版本验证、A/B 测试</td><td>无缝升级部署</td></tr></tbody></table><table tabindex="0"><thead><tr><th>场景</th><th>技术方案</th><th>说明</th></tr></thead><tbody><tr><td>静态站点</td><td>多版本构建 + CDN 分流</td><td>通过 cookie/header 控制加载版本</td></tr><tr><td>微前端</td><td>子应用级灰度</td><td>不同用户加载不同子应用版本</td></tr><tr><td>React/Vue 单页</td><td>Feature Flag（功能开关）</td><td>动态控制哪些功能显示</td></tr><tr><td>配合后端</td><td>接口层灰度</td><td>后端返回版本信息或新接口数据</td></tr></tbody></table>',4))])}const x=a(p,[["render",g]]);export{h as __pageData,x as default};
