import{_ as p,I as r,c as h,o as k,ah as n,J as e,j as s,w as l,a}from"./chunks/framework.fGi7qB65.js";const f=JSON.parse('{"title":"react","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/framework/react.md","filePath":"knowledge/framework/react.md"}'),d={name:"knowledge/framework/react.md"};function o(c,i,u,E,g,y){const t=r("Collapse");return k(),h("div",null,[i[6]||(i[6]=n("",202)),e(t,null,{default:l(()=>[...i[0]||(i[0]=[s("p",null,"i18n 实现国际化",-1),s("ol",null,[s("li",null,"动态语言切换 + 按需加载")],-1),s("ul",null,[s("li",null,"动态import+映射表,页面级组件在useEffect或路由加载时调用i18n.addResources(),减少初始打包体积，提高首屏加载速度, 使用缓存(localStorage / IndexedDB)")],-1),s("ol",{start:"2"},[s("li",null,[s("p",null,"日期/时间/数字/货币格式化")]),s("li",null,[s("p",null,"自动提取翻译 Key & 多语言管理")])],-1),s("ul",null,[s("li",null,"i18next-scanner 扫描")],-1),s("ol",{start:"4"},[s("li",null,"i18n + 路由（多语言 URL）")],-1),s("ul",null,[s("li",null,":lang 作为路由参数, 配合effect, navigate loadLanguage实现")],-1),s("ol",{start:"5"},[s("li",null,[a("i18n 国际化对 React 组件性能的影响？如何优化？ "),s("ul",null,[s("li",null,"react-i18next 会在语言切换时触发重新渲染依赖翻译的组件: 精准使用 useTranslation('namespace')(语言文件可以按 namespace 划分)，避免全局组件不必要渲染;"),s("li",null,"Trans 组件只包裹需要翻译的部分;"),s("li",null,"使用 memoization (React.memo) 避免深层组件重复渲染, 避免重复 useTranslation, 子组件可通过 props 传递翻译后的文本, react-i18next 使用 Context + Hook，组件通过 useTranslation() 获取翻译函数 t()")])])],-1)])]),_:1}),i[7]||(i[7]=s("h3",{id:"_27-自己写的hooks",tabindex:"-1"},[a("27. 自己写的hooks "),s("a",{class:"header-anchor",href:"#_27-自己写的hooks","aria-label":"Permalink to “27. 自己写的hooks”"},"​")],-1)),e(t,null,{default:l(()=>[...i[1]||(i[1]=[s("ul",null,[s("li",null,"简单的 useLocalStorage;"),s("li",null,"基于useRequest封装项目使用useDict 提供 dict 功能,支持单个, 批量获取dict 初始化, 缓存, 刷新, getLabel; - useFlatOrgTree 获取机构树, 后端是List 的结构, 转化成Tree 结构, 还有把Tree 结构转化成list机构;"),s("li",null,"useModal 把弹窗状态和打开关闭方法封装成一个hook(open 是的把对象传入);"),s("li",null,"usePermission 判断权限, useRequset:"),s("li",null,"基于 vueuse的useAsyncState 封装的 useRequset, 返回state,isLoading,isReady,run, 支持配置showMessage,formatResult,initialState, immediate等;"),s("li",null,"useSearchTable 将 table 操作封装再里面;"),s("li",null,"useConfirm")],-1)])]),_:1}),i[8]||(i[8]=s("h3",{id:"_28-redux-toolkit",tabindex:"-1"},[a("28.Redux Toolkit "),s("a",{class:"header-anchor",href:"#_28-redux-toolkit","aria-label":"Permalink to “28.Redux Toolkit”"},"​")],-1)),e(t,null,{default:l(()=>[...i[2]||(i[2]=[s("ol",null,[s("li",null,"createSlice 内部用 Immer，允许你写“可变写法”，但底层会生成不可变的新 state。"),s("li",null,[a("createAsyncThunk 内部是如何工作的？ "),s("ul",null,[s("li",null,[a("生成一个 thunk action（函数），会在调用时触发一个 生命周期三段式： "),s("ul",null,[s("li",null,"pending → 异步任务开始"),s("li",null,"fulfilled → 异步任务成功"),s("li",null,"rejected → 异步任务失败")])]),s("li",null,"内部用 dispatch 多次派发 action，而不是只派发一次。")])])],-1),s("p",null,"3.Redux Toolkit 如何优化性能 - 1.内置 Immer + useSelector 的 浅比较，减少无效渲染。 - 2.createEntityAdapter 提供规范化数据结构（normalized state），避免深层次 diff。 - 3. 配合 memo / useMemo / useCallback，只渲染必要组件。",-1),s("ol",{start:"4"},[s("li",null,[a("如果要在 Redux Toolkit 里实现一个 Undo/Redo 功能，怎么做？ "),s("ul",null,[s("li",null,"在 reducer 里维护一个 past[]、present、future[] 三段式结构。"),s("li",null,"每次 dispatch：把当前 present 推入 pastpresent 替换为新 state"),s("li",null,"Undo → 从 past 弹出最后一个到 present，并把原先的 present 推入 future")])])],-1)])]),_:1}),i[9]||(i[9]=s("h3",{id:"_29-react-usestate-usereducer-useref-useeffece-原理",tabindex:"-1"},[a("29. react usestate usereducer useref useeffece 原理 "),s("a",{class:"header-anchor",href:"#_29-react-usestate-usereducer-useref-useeffece-原理","aria-label":"Permalink to “29. react usestate usereducer useref useeffece 原理”"},"​")],-1)),e(t,null,{default:l(()=>[...i[3]||(i[3]=[s("p",null,"环形队列就是：链表的最后一个节点的 next 指针 指向头节点，形成一个环。",-1),s("ul",null,[s("li",null,[s("p",null,"useState 的原理"),s("ul",null,[s("li",null,"原理可以拆解成三个部分：状态保存、状态更新 和 触发渲染。 useState 把状态保存在 Fiber 的 Hook 链表中，setState 通过更新队列记录变化，并触发 Fiber 的调度和重新渲染，最终在下一次执行组件时计算出新状态。"),s("li",null,"React 为什么需要 useState: 在函数组件里，普通的局部变量在函数执行完后会被销毁。React 通过 useState 把状态存放在 Fiber 节点 上，这样每次函数组件重新执行时，状态不会丢失。"),s("li",null,"状态保存原理: 每个组件对应一个 Fiber 节点。Fiber 上有一个 memoizedState 属性，存储链表结构，保存多个 Hook 的状态。"),s("li",null,"状态更新原理: 调用 setState 时, 会创建一个 更新对象, 放到对应 Hook 的更新队列里, 然后 React 会调度一次 组件重新渲染"),s("li",null,"触发渲染机制: setState 本质上调用了 React 的 调度器，会标记当前 Fiber 为需要更新，然后触发一次 Fiber 调度 → Diff → commit → 重新渲染 流程。")])]),s("li",null,[s("p",null,"usereducer原理"),s("ul",null,[s("li",null,"useState 的原理一样, 是把状态更新逻辑抽出来交给 reducer 函数. 其实 React 内部 useState 就是 useReducer 的语法糖。"),s("li",null,"useReducer 本质上和 useState 一样，状态保存在 Fiber Hook 链表里，更新通过环形队列记录；不同的是，它通过 reducer(state, action) 把更新逻辑交给用户，让状态更新更可控。")])])],-1),s("div",{class:"language-"},[s("button",{title:"Copy Code",class:"copy"}),s("span",{class:"lang"}),s("pre",{class:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabindex:"0",dir:"ltr"},[s("code",null,[s("span",{class:"line"},[s("span",null,"function useState(initialState) {")]),a(`
`),s("span",{class:"line"},[s("span",null,"    return useReducer((state, action) => {")]),a(`
`),s("span",{class:"line"},[s("span",null,"        return typeof action === 'function' ? action(state) : action;")]),a(`
`),s("span",{class:"line"},[s("span",null,"    }, initialState);")]),a(`
`),s("span",{class:"line"},[s("span",null,"}")])])])],-1),s("ul",null,[s("li",null,[s("p",null,"useRef 原理"),s("ul",null,[s("li",null,"useRef 的作用就是：给你一个不会变的“盒子”来存放东西。"),s("li",null,"和其他 Hooks 一样，useRef 也存放在 Fiber 的 Hook 链表里。 不同点在于：初次渲染时，React 会创建一个对象 { current: initialValue }，并保存到 memoizedState。之后的渲染，直接返回同一个对象。"),s("li",null,"每次调用 useRef，拿到的都是同一个对象引用；修改 .current 不会触发渲染，因为 React 不会监听这个值的变化。")])]),s("li",null,[s("p",null,"useeffece 原理"),s("ul",null,[s("li",null,"React 提供 useEffect，把这些副作用挂到 Fiber 的副作用链表，在 DOM 更新提交之后 执行。(commit 阶段执行)"),s("li",null,[a("可以分成三个阶段: 初次渲染, 提交阶段, 更新渲染 "),s("ul",null,[s("li",null,"updateQueue（effect 链表）"),s("li",null,"layoutEffect（同步执行）：在 DOM 更新后，浏览器绘制之前执行（会阻塞渲染）。"),s("li",null,"effect（即 useEffect）（异步执行）：在浏览器完成绘制后执行，不会阻塞渲染")])]),s("li",null,"useEffect 的原理就是：在渲染时收集副作用，存到 Fiber 的effect链表；在commit阶段统一执行，并根据依赖数组判断是否需要重新运行，同时处理清理函数。")])])],-1)])]),_:1}),i[10]||(i[10]=s("h3",{id:"_30-react-useeffect-依赖项为数据或者对象-如何处理",tabindex:"-1"},[a("30. react useEffect 依赖项为数据或者对象, 如何处理 "),s("a",{class:"header-anchor",href:"#_30-react-useeffect-依赖项为数据或者对象-如何处理","aria-label":"Permalink to “30. react useEffect 依赖项为数据或者对象, 如何处理”"},"​")],-1)),e(t,null,{default:l(()=>[...i[4]||(i[4]=[s("p",null,"当 useEffect 的依赖项是数组或对象时，你可能会遇到一个陷阱：useEffect 会在每次组件重新渲染时都执行，即使数组或对象的内容“看起来”没有变化.",-1),s("p",null,"React 组件每次重新渲染时，在函数体内部定义的对象或数组都会被重新创建一个新的实例。比较时Object.is 始终为false,因此 effect 会重新执行",-1),s("p",null,"方案一：解构原始值 (Destructuring Primitives)",-1),s("ul",null,[s("li",null,"取只关心其中的某些原始值")],-1),s("p",null,"方案二：使用 useMemo 稳定引用 (Memoization)",-1),s("ul",null,[s("li",null,"useMemo 会缓存这个对象/数组，只有当 useMemo 自己的依赖项改变时，它才会重新创建一个新的对象/数组。")],-1),s("p",null,"方案三：序列化为字符串 (Stringification)",-1),s("ul",null,[s("li",null,"把它们转换成一个 JSON 字符串，因为字符串是原始值。")],-1),s("p",null,"方案四：使用自定义 Hook (Deep Compare)",-1),s("ul",null,[s("li",null,"创建一个自定义 Hook（例如 useRef）来存储前一个值，并在 useEffect 内部手动进行“深度比较”。")],-1)])]),_:1}),i[11]||(i[11]=s("h3",{id:"_31-jsx-为什么只允许有一个父节点",tabindex:"-1"},[a("31. jsx 为什么只允许有一个父节点 "),s("a",{class:"header-anchor",href:"#_31-jsx-为什么只允许有一个父节点","aria-label":"Permalink to “31. jsx 为什么只允许有一个父节点”"},"​")],-1)),e(t,null,{default:l(()=>[...i[5]||(i[5]=[s("p",null,[s("strong",null,"因为 JSX 最终会被编译成 JavaScript 函数调用，而 JavaScript 的函数一次只能返回一个值。")],-1),s("p",null,"核心原理：JSX 是 React.createElement() 的语法糖.",-1),s("p",null,"你写的 JSX 代码并不会直接在浏览器中运行。它需要一个转译器（最常见的是 Babel）将其转换为浏览器能理解的纯 JavaScript。 在 React 中，你写的每一段 JSX 标签都会被转译成一个 React.createElement(component, props, ...children) 函数调用 这个函数调用的返回值是一个 JavaScript 对象（用来描述你想要创建的 UI，也就是 React 元素或“虚拟 DOM”节点）",-1)])]),_:1}),i[12]||(i[12]=n("",3))])}const F=p(d,[["render",o]]);export{f as __pageData,F as default};
