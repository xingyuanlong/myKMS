### 1. AI Agent  是啥?

<Collapse>

AI Agent（智能代理） 是一个能够 **感知环境、做决策、执行动作** 的系统。是能够感知环境、做决策并执行动作的智能系统，其复杂度从简单规则反应型到学习型智能体不等。
    
AI Agent 的代码生成、辅助编程工具和提示工程 (Prompt Engineering) 工具

AI Agent 是能够感知环境、基于目标和策略做决策并执行动作的智能系统，现代应用多结合 LLM，实现自动化任务、多步推理和上下文增强。

</Collapse>

### 2. MCP 是啥

<Collapse>

ai mcp 是啥: 
  传统的大语言模型通常只能访问其训练时的数据，无法获取实时信息或与外部系统交互。MCP 的引入，解决了这一限制，使 AI 助手能够：
  - 访问实时数据：如数据库查询、网页抓取、API 调用等。
  - 执行操作：如文件管理、任务调度、系统控制等。
  - 增强上下文理解：通过标准化的协议，提供更丰富的上下文信息，提高回答的准确性和相关性。

</Collapse>

### 3. ai mcp 与 agent 区别和相同是啥

<Collapse>



| 对比维度         | **AI MCP（Model Context Protocol）**       | **Agent（智能体）**                                    |
| ------------ | ---------------------------------------- | ------------------------------------------------- |
| **核心定义**     | 一种开放协议，用于让 AI 模型与外部工具、数据源、安全系统进行交互的标准化接口 | 一个具备感知、决策、行动能力的 AI 实体，能自主执行任务                     |
| **目标**       | 让 AI 模型具备“安全、受控地访问外部能力”的标准化方式            | 模拟人类行为与决策，实现自动化任务执行                               |
| **本质定位**     | 通信协议 / 桥梁层（模型与外部世界之间的 API 桥）             | 智能执行体 / 上层应用（基于协议或框架实现行为）                         |
| **是否具备决策逻辑** | ❌ 无（仅负责传递与规范化上下文与调用）                     | ✅ 有（根据上下文、记忆、目标做出决策）                              |
| **是否依赖模型**   | ✅ 是，为模型服务的协议层                            | ✅ 是，通常内嵌或依赖大模型                                    |
| **数据交互方式**   | 定义好的接口和上下文传递机制（如：tools、files、memory等）    | 主动感知 + 调用外部 API 或协议（可使用 MCP）                      |
| **典型实现者**    | OpenAI MCP、Anthropic MCP 等               | AutoGPT、LangChain Agent、OpenDevin、ChatGPT Agent 等 |
| **可扩展性**     | 高，通过定义新的 MCP 服务器或工具接口扩展模型能力              | 高，可通过插件、工具链、MCP 等方式增强行为                           |
| **安全控制**     | 强，强调“模型可见范围”与“安全沙箱”                      | 弱到中等，取决于实现（可能越权或误操作）                              |
| **运行层级**     | 模型与外部系统之间的“中间层”                          | 应用层（运行在用户逻辑上层）                                    |
| **示例场景**     | 模型通过 MCP 协议安全访问数据库、文件系统、内部 API           | Agent 使用 MCP 工具自动检索文档、编写代码、执行命令                   |
| **关系总结**     | 提供 Agent 可用的“统一外部接口标准”                   | 利用 MCP 作为工具访问协议来实现自主任务执行                          |


简单总结：

MCP 是“协议层” → 定义模型如何安全访问世界。
Agent 是“智能层” → 定义模型如何使用这些能力执行任务。

换句话说：
  MCP ≈ 插座标准，
  Agent ≈ 插在插座上运行的设备。

</Collapse>



### 4. Prompt 工程

<Collapse>

- Prompt 工程就是精心设计、优化和管理输入给大语言模型的提示，以最大化输出质量和准确性的技术。
- Prompt 工程 = 设计和优化输入给 LLM 的提示（Prompt）以获得最准确、最有效输出的技术和方法
- Prompt 工程的目标是 **用最小代价让模型输出最期望的结果。**

</Collapse>


### 5.AI Coding 的个人最佳实践


<Collapse>

- 选助手: chatgpt codex 和 github copilot
- 高质量提示词（Prompt）模板
  - 把“上下文先行 + 验收先行”写死在提示里，减少反复。
  -  定身份 + 限制
- 质量护栏（个人级“红线”） 
  - 一次只改一件事：让 AI 聚焦在 1–3 个文件，减少回滚成本。
  - 看 diff 不看 demo：合并前逐行审阅关键点：状态共享、边界条件、异常路径、内存/性能热路径。
  - 强制四件套：代码 + 测试 + 示例 + 说明，缺一不收。
- 调试与修复闭环
- 仓库最小“AI 上下文包”
  - Chat/对话里加一句：规范见 /ai_context/STYLE.md, TECH_STACK.md, DO_NOTS.md，必须遵守
  - 在仓库根放 /ai_context/
    - STYLE.md（命名/目录/commit 规范）
    - TECH_STACK.md（框架版本、状态管理、UI/HTTP/路由选型）
    - API_SPEC.md（关键接口契约与错误码）
    - DO_NOTS.md（黑名单：禁用 API/反模式/易踩坑）
    - 之后提示词直接引用这些文档，减少来回解释。

-  把 AI 当“代码生成器 + 搜索引擎 + 重构器”
- 界定 → 生成 → 验证 → 固化


</Collapse>


### 6.对于 AI IDE 中 Agent 的理解

<Collapse>

**AI IDE 中 Agent 它不只是聊天补全，而是能读—想—改—验的一套自动化执行体。**

- 定义:**一个具备工具调用能力、可多轮执行的自动化体（planner + executor），在 IDE 里对代码仓库做计划→生成→编辑→验证→提交的闭环。**
- 本质差异（vs. 普通 Chat/补全）
  - Chat：只给建议，改不动仓库；上下文短。
  - 补全：跟光标走，单文件/局部。
  - Agent：可跨文件/多步骤，调用代码搜索、测试、构建、git、包管理、格式化/静态检查等工具，并返回可审阅的 patch。



AI IDE 中的 Agent = 具备工具调用与多轮自校验的“自动化协作者”。它的价值不在“能写多少代码”，而在把规则化的、可验证的仓库级改动交给机器完成；你的工作是设置清晰边界与硬性的质量闸门，让它安全高效地跑完“计划→编辑→验证→提交”的闭环。


</Collapse>


### 7.对于 AI IDE 中 MCP 的理解

<Collapse>

它是把 IDE/Agent 和外部工具、数据源“标准化接驳”的一套开放协议——更像给 AI 装了一个 “USB-C 接口”：一处实现，处处连用。

mcp:

定义：由 Anthropic 发起的开源协议，用来把 AI 应用/代理（Agent）与“工具 + 数据 + 工作流”做双向、安全、可发现的连接。一次实现协议，便可复用整套生态的集成。

生态位置：面向 IDE/桌面助手/云端代理等“客户端”（Client），以及暴露工具/数据能力的“服务器”（Server）。客户端发现可用工具，调用并拿回结构化结果。


MCP = 给 AI IDE/Agent 的通用“工具与数据总线”。它把“发现—调用—返回”的语义标准化，让 Agent 能在 IDE 里安全、可复用地连接到文件系统、构建/测试、企业 API 等能力，进而把“计划→编辑→验证→提交”的工程闭环跑起来。

</Collapse>


### 8.  AI IDE 中 Tab 补全模型及其原理

<Collapse>

**是一条从上下文收集 → 语言模型推断 → 候选生成与重排 → 约束与安全 → 呈现与学习的工程流水线**

```swift
键入 → 触发条件命中
   → 上下文构建（prefix+suffix+符号/RAG+工程规则）
     → 模型解码（FIM/自回归，KV cache，限长/停用符）
       → 生成多候选（不同温度/窗口）
         → 重排（可编性/风格/相似度/历史采纳）
           → 约束&安全过滤（语法/lint/secret）
             → 呈现（渐进式，短→长）
               → 反馈学习（接受/编辑/拒绝→排序器/提示适配）

```

</Collapse>


