import{_ as i,I as a,c as r,o as d,j as l,J as e,ah as o,a as n,w as s}from"./chunks/framework.CfFWKSe1.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/2025.md","filePath":"interview/2025.md"}'),p={name:"interview/2025.md"};function h(c,u,k,g,b,m){const t=a("Collapse");return d(),r("div",null,[u[19]||(u[19]=l("p",null,"pr",-1)),u[20]||(u[20]=l("h3",{id:"_1-react-vue-有什么区别和相似",tabindex:"-1"},[n("1. react vue 有什么区别和相似 "),l("a",{class:"header-anchor",href:"#_1-react-vue-有什么区别和相似","aria-label":"Permalink to “1. react vue 有什么区别和相似”"},"​")],-1)),e(t,null,{default:s(()=>[...u[0]||(u[0]=[l("p",null,"对比:",-1),l("ul",null,[l("li",null,[l("p",null,"vue 编译+运行时框架, react 运行时, 所以vue 再编译时能够做很多优化(如静态标记和动态提升), react 更注重运行时, react 19 也有 React Compiler 编译优化. (svelte 纯编译 )")]),l("li",null,[l("p",null,"React：UI 库（Library），专注于 视图层，其它路由/状态管理等靠社区生态（React Router、Redux）。 Vue：渐进式框架（Framework），提供了从视图到路由、状态管理（Vue Router、Pinia/Vuex）的完整解决方案。")]),l("li",null,[l("p",null,"语法与编程范式:"),l("ul",null,[l("li",null,"React：以 JavaScript/TypeScript 为核心，用 JSX 描述 UI。 更偏向函数式编程，鼓励用 Hooks 管理状态、副作用。"),l("li",null,[n("Vue：提供 单文件组件 (SFC)，分为 "),l("code",null,"<template> + <script> + <style>"),n("。 更接近声明式和模板式编程，容易上手")])])]),l("li",null,[l("p",null,"数据绑定"),l("ul",null,[l("li",null,"React：单向数据流，props → 子组件，更新需要 setState 或 useState。"),l("li",null,"Vue：双向数据绑定 (v-model)，适合表单场景，逻辑简洁。")])]),l("li",null,[l("p",null,"性能优化"),l("ul",null,[l("li",null,"React：依靠 shouldComponentUpdate / React.memo / useMemo / useCallback。"),l("li",null,"Vue：通过 响应式系统（Proxy + Effect 追踪依赖），自动追踪更新；还可以用 v-once、computed 优化")])]),l("li",null,[l("p",null,"状态管理"),l("ul",null,[l("li",null,"React：依赖外部库（Redux、MobX、Zustand、Recoil 等），灵活但碎片化。"),l("li",null,"Vue：官方提供 Vuex（Vue2）/ Pinia（Vue3），统一、集成度高")])]),l("li",null,[l("p",null,"底层区别:")])],-1),l("p",null,"1.核心思想",-1),l("ul",null,[l("li",null,[n("React "),l("ol",null,[l("li",null,"核心是函数式 + 状态驱动 UI：UI = f(state)。"),l("li",null,"关注数据不可变和纯函数更新。"),l("li",null,"React 本身是渲染库，路由/状态管理等能力由社区提供。")])]),l("li",null,[n("Vue "),l("ol",null,[l("li",null,"核心是响应式系统 + 模板编译：通过响应式追踪 + 渲染函数驱动更新。"),l("li",null,"偏向声明式与命令式相结合，易上手。"),l("li",null,"Vue 是一个完整的框架，提供更多开箱即用的能力。")])])],-1),l("ol",{start:"2"},[l("li",null,[l("p",null,"响应式机制"),l("ul",null,[l("li",null,"React: 没有内置响应式，靠 useState/useReducer 触发组件更新。每次 setState 会触发组件重新渲染，然后通过虚拟 DOM diff 决定哪些节点需要更新。数据变化 → 全量渲染 → Diff → 最小化 DOM 更新。"),l("li",null,"Vue: Vue 2 使用 Object.defineProperty，Vue 3 使用 Proxy；通过精确的依赖追踪，只有用到字段的组件或计算属性会订阅该字段。数据变化 → 精确找到依赖它的组件/模板 → 只更新必要部分。")])]),l("li",null,[l("p",null,"虚拟 DOM & 渲染"),l("ul",null,[l("li",null,"React: 使用 Fiber 架构（从 v16 开始）。每个组件对应一个 Fiber 节点，支持异步可中断渲染（time slicing、并发模式），强调调度与优先级，确保 UI 流畅。"),l("li",null,"Vue: Vue 3 借助编译期优化和 Block Tree（静态提升 + 动态节点追踪）。模板在编译时划分为“静态节点 + 动态节点”，更新时只 diff 动态部分。Vue 3.6 引入的 Vapor Mode 甚至尝试跳过虚拟 DOM，生成更精确的更新代码。")])]),l("li",null,[l("p",null,"调度机制"),l("ul",null,[l("li",null,"React：有完整的 Scheduler，支持优先级队列（用户交互优先、网络渲染延后）和并发渲染（Concurrent Mode）。"),l("li",null,"Vue：内置异步队列 + nextTick，保证数据更新合并（批量刷新），调度相对简单，不区分复杂优先级。")])]),l("li",null,[l("p",null,"渲染层抽象"),l("ul",null,[l("li",null,"React: ReactDOM 是一个渲染器，底层渲染器可替换（React Native、Ink、three-fiber），通过 Reconciler + Renderer 解耦。"),l("li",null,"Vue: Vue 3 同样有 Renderer 抽象（runtime-core + runtime-dom），官方维护 DOM 渲染器及其它平台的渲染器，但 React 在多端渲染生态上更成熟。")])]),l("li",null,[l("p",null,"生态设计"),l("ul",null,[l("li",null,"React：小核 + 强社区，灵活且可扩展（例如 React Native、Next.js、Remix 等）。"),l("li",null,"Vue：整体框架理念，内置响应式和编译器，适合小团队和中台项目，使用体验更统一。")])])],-1),l("p",null,"相似性",-1),l("ul",null,[l("li",null,"都是 UI 层框架，专注视图"),l("li",null,"都基于 数据驱动视图"),l("li",null,"都通过 虚拟 DOM 进行高效 DOM 更新"),l("li",null,"都是 组件化开发，支持递归组合"),l("li",null,"父 → 子（props）单向数据流 保证数据可预测性"),l("li",null,"都有 生命周期钩子"),l("li",null,"都支持 SSR / SSG / CSR 混合渲染"),l("li",null,"都在追求 更细粒度更新和并发渲染"),l("li",null,"都支持跨平台渲染")],-1)])]),_:1}),u[21]||(u[21]=l("h3",{id:"_2-qiankun",tabindex:"-1"},[n("2.qiankun "),l("a",{class:"header-anchor",href:"#_2-qiankun","aria-label":"Permalink to “2.qiankun”"},"​")],-1)),e(t,null,{default:s(()=>[...u[1]||(u[1]=[l("ul",null,[l("li",null,[l("p",null,"js 隔离: 1.SnapshotSandbox（快照沙箱）: 在应用切换前，把 window 的状态做一份快照。子应用运行时，修改的全局变量只保存在自己的快照里。卸载子应用时，还原 window。缺点：只能同时激活一个子应用（适合单实例场景）。"),l("p",null,"2.ProxySandbox（代理沙箱） 基于 ES6 Proxy 拦截子应用对全局对象的读写。每个子应用有一个独立的代理对象作为 window，实际访问 window.xxx 时，会优先读写子应用自己的代理上下文。多个子应用可并行运行，互不影响。"),l("p",null,"qiankun 默认在支持 Proxy 的浏览器下使用这个方案")])],-1),l("div",{class:"language-"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"}),l("pre",{class:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabindex:"0",dir:"ltr"},[l("code",null,[l("span",{class:"line"},[l("span",null,"const fakeWindow = {};")]),n(`
`),l("span",{class:"line"},[l("span",null,"const proxy = new Proxy(window, {")]),n(`
`),l("span",{class:"line"},[l("span",null,"        get(target, key) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"        return key in fakeWindow ? fakeWindow[key] : target[key];")]),n(`
`),l("span",{class:"line"},[l("span",null,"},")]),n(`
`),l("span",{class:"line"},[l("span",null,"set(target, key, value) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"        fakeWindow[key] = value;")]),n(`
`),l("span",{class:"line"},[l("span",null,"        return true;")]),n(`
`),l("span",{class:"line"},[l("span",null,"      }")]),n(`
`),l("span",{class:"line"},[l("span",null,"});")])])])],-1),l("ul",null,[l("li",null,[l("p",null,"样式隔离:"),l("ol",null,[l("li",null,"严格样式隔离: Shadow DOM 兼容性不好"),l("li",null,'实验性样式隔离（样式前缀）:通过 ScopedCSS 插件，在运行时动态给子应用 CSS 加上前缀（比如 [data-qiankun="xxx"]）。确保样式只影响当前子应用的 DOM。原理类似 Vue 的 scoped 样式，但是在运行时做。'),l("li",null,"css BEM, PostCSS 插件")])])],-1)])]),_:1}),u[22]||(u[22]=l("h3",{id:"_3-amis-表单联动",tabindex:"-1"},[n("3. amis 表单联动 "),l("a",{class:"header-anchor",href:"#_3-amis-表单联动","aria-label":"Permalink to “3. amis 表单联动”"},"​")],-1)),u[23]||(u[23]=l("ol",null,[l("li",null,"给某个表单项绑定 onChange，当值变化时更新另一个表单项。"),l("li",null,"如果是展示或可用性联动 visibleOn / disabledOn")],-1)),u[24]||(u[24]=l("h3",{id:"_4-vite-插件",tabindex:"-1"},[n("4.vite 插件 "),l("a",{class:"header-anchor",href:"#_4-vite-插件","aria-label":"Permalink to “4.vite 插件”"},"​")],-1)),e(t,null,{default:s(()=>[...u[2]||(u[2]=[l("div",{class:"language-"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"}),l("pre",{class:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabindex:"0",dir:"ltr"},[l("code",null,[l("span",{class:"line"},[l("span",null,"import type { Plugin } from 'vite';")]),n(`
`),l("span",{class:"line"},[l("span")]),n(`
`),l("span",{class:"line"},[l("span",null,"function myPlugin(options?): Plugin {")]),n(`
`),l("span",{class:"line"},[l("span",null,"  return {")]),n(`
`),l("span",{class:"line"},[l("span",null,"    name: 'my-plugin',  // **必须**有 name，方便调试")]),n(`
`),l("span",{class:"line"},[l("span",null,"    // enforce: 'pre' 或 'post'（可选），指定此插件执行顺序")]),n(`
`),l("span",{class:"line"},[l("span",null,"    config(config, { command }) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"      // 修改 Vite / Rollup 配置（可选）")]),n(`
`),l("span",{class:"line"},[l("span",null,"    },")]),n(`
`),l("span",{class:"line"},[l("span",null,"    configResolved(resolvedConfig) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"      // 当最终 config 确定后执行")]),n(`
`),l("span",{class:"line"},[l("span",null,"    },")]),n(`
`),l("span",{class:"line"},[l("span",null,"    resolveId(source, importer) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"      // 自定义模块解析逻辑")]),n(`
`),l("span",{class:"line"},[l("span",null,"    },")]),n(`
`),l("span",{class:"line"},[l("span",null,"    load(id) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"      // 如果你要“自己加载一个模块”，返回内容")]),n(`
`),l("span",{class:"line"},[l("span",null,"      // 否则返回 null 让后续钩子 /默认流程处理")]),n(`
`),l("span",{class:"line"},[l("span",null,"    },")]),n(`
`),l("span",{class:"line"},[l("span",null,"    transform(code, id) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"      // 转换模块源代码，返回 { code, map } 或 string")]),n(`
`),l("span",{class:"line"},[l("span",null,"    },")]),n(`
`),l("span",{class:"line"},[l("span",null,"    handleHotUpdate(ctx) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"      // 在开发服务下，处理 HMR 热更新逻辑")]),n(`
`),l("span",{class:"line"},[l("span",null,"    },")]),n(`
`),l("span",{class:"line"},[l("span",null,"    // 构建阶段钩子")]),n(`
`),l("span",{class:"line"},[l("span",null,"    buildStart() { },")]),n(`
`),l("span",{class:"line"},[l("span",null,"    generateBundle(options, bundle, isWrite) { },")]),n(`
`),l("span",{class:"line"},[l("span",null,"    writeBundle() { },")]),n(`
`),l("span",{class:"line"},[l("span",null,"    closeBundle() { },")]),n(`
`),l("span",{class:"line"},[l("span",null,"  };")]),n(`
`),l("span",{class:"line"},[l("span",null,"}")])])])],-1),l("p",null,"// 替换模板的一个字",-1),l("div",{class:"language-"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"}),l("pre",{class:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabindex:"0",dir:"ltr"},[l("code",null,[l("span",{class:"line"},[l("span",null,"export default function replaceTextPlugin(options = { search: 'FOO', replace: 'BAR' }) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"  return {")]),n(`
`),l("span",{class:"line"},[l("span",null,"    name: 'vite-plugin-replace-text',")]),n(`
`),l("span",{class:"line"},[l("span",null,"    enforce: 'pre',")]),n(`
`),l("span",{class:"line"},[l("span",null,"    transform(code, id) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"      if (/\\.(js|ts|jsx|tsx)$/.test(id)) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"        return code.replace(new RegExp(options.search, 'g'), options.replace);")]),n(`
`),l("span",{class:"line"},[l("span",null,"      }")]),n(`
`),l("span",{class:"line"},[l("span",null,"      return null;")]),n(`
`),l("span",{class:"line"},[l("span",null,"    }")]),n(`
`),l("span",{class:"line"},[l("span",null,"  };")]),n(`
`),l("span",{class:"line"},[l("span",null,"}")])])])],-1),l("p",null,"// 统计TODO",-1),l("div",{class:"language-"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"}),l("pre",{class:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabindex:"0",dir:"ltr"},[l("code",null,[l("span",{class:"line"},[l("span",null,"import fs from 'fs';")]),n(`
`),l("span",{class:"line"},[l("span",null,"import path from 'path';")]),n(`
`),l("span",{class:"line"},[l("span")]),n(`
`),l("span",{class:"line"},[l("span",null,"export function vitePluginTodo() {")]),n(`
`),l("span",{class:"line"},[l("span",null,"  const todos = [];")]),n(`
`),l("span",{class:"line"},[l("span")]),n(`
`),l("span",{class:"line"},[l("span",null,"  function scanFile(filePath) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"    const code = fs.readFileSync(filePath, 'utf-8');")]),n(`
`),l("span",{class:"line"},[l("span",null,"    const lines = code.split('\\n');")]),n(`
`),l("span",{class:"line"},[l("span")]),n(`
`),l("span",{class:"line"},[l("span",null,"    lines.forEach((line, index) => {")]),n(`
`),l("span",{class:"line"},[l("span",null,"      const todoMatch = line.match(/\\/\\/\\s*TODO\\s*:(.*)/i) ")]),n(`
`),l("span",{class:"line"},[l("span",null,"                     || line.match(/\\/\\*\\s*TODO\\s*:(.*)\\*\\//i);")]),n(`
`),l("span",{class:"line"},[l("span")]),n(`
`),l("span",{class:"line"},[l("span",null,"      if (todoMatch) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"        todos.push({")]),n(`
`),l("span",{class:"line"},[l("span",null,"          file: path.relative(process.cwd(), filePath),")]),n(`
`),l("span",{class:"line"},[l("span",null,"          line: index + 1,")]),n(`
`),l("span",{class:"line"},[l("span",null,"          content: todoMatch[1].trim(),")]),n(`
`),l("span",{class:"line"},[l("span",null,"        });")]),n(`
`),l("span",{class:"line"},[l("span",null,"      }")]),n(`
`),l("span",{class:"line"},[l("span",null,"    });")]),n(`
`),l("span",{class:"line"},[l("span",null,"  }")]),n(`
`),l("span",{class:"line"},[l("span")]),n(`
`),l("span",{class:"line"},[l("span",null,"  function scanDir(dir) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"    const entries = fs.readdirSync(dir, { withFileTypes: true });")]),n(`
`),l("span",{class:"line"},[l("span",null,"    for (const entry of entries) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"      const fullPath = path.join(dir, entry.name);")]),n(`
`),l("span",{class:"line"},[l("span")]),n(`
`),l("span",{class:"line"},[l("span",null,"      if (entry.isDirectory()) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"        if (entry.name === 'node_modules' || entry.name.startsWith('.')) continue;")]),n(`
`),l("span",{class:"line"},[l("span",null,"        scanDir(fullPath);")]),n(`
`),l("span",{class:"line"},[l("span",null,"      } else if (/\\.(ts|js|tsx|jsx|vue)$/.test(entry.name)) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"        scanFile(fullPath);")]),n(`
`),l("span",{class:"line"},[l("span",null,"      }")]),n(`
`),l("span",{class:"line"},[l("span",null,"    }")]),n(`
`),l("span",{class:"line"},[l("span",null,"  }")]),n(`
`),l("span",{class:"line"},[l("span")]),n(`
`),l("span",{class:"line"},[l("span",null,"  console.log('vite-plugin-todo');")]),n(`
`),l("span",{class:"line"},[l("span",null,"  return {")]),n(`
`),l("span",{class:"line"},[l("span",null,"    name: 'vite-plugin-todo',")]),n(`
`),l("span",{class:"line"},[l("span",null,"    apply: 'build',")]),n(`
`),l("span",{class:"line"},[l("span",null,"    buildStart() {")]),n(`
`),l("span",{class:"line"},[l("span",null,"      console.log('vite-plugin-todo buildStart');")]),n(`
`),l("span",{class:"line"},[l("span",null,"      todos.length = 0;")]),n(`
`),l("span",{class:"line"},[l("span",null,"      scanDir(process.cwd());")]),n(`
`),l("span",{class:"line"},[l("span",null,"    },")]),n(`
`),l("span",{class:"line"},[l("span",null,"    closeBundle() {")]),n(`
`),l("span",{class:"line"},[l("span",null,"      if (todos.length > 0) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"        console.log('\\n💡 TODO List:');")]),n(`
`),l("span",{class:"line"},[l("span",null,"        todos.forEach(todo => {")]),n(`
`),l("span",{class:"line"},[l("span",null,"          console.log(`${todo.file}:${todo.line} - ${todo.content}`);")]),n(`
`),l("span",{class:"line"},[l("span",null,"        });")]),n(`
`),l("span",{class:"line"},[l("span",null,"      } else {")]),n(`
`),l("span",{class:"line"},[l("span",null,"        console.log('\\n✅ No TODO found.');")]),n(`
`),l("span",{class:"line"},[l("span",null,"      }")]),n(`
`),l("span",{class:"line"},[l("span",null,"    }")]),n(`
`),l("span",{class:"line"},[l("span",null,"  };")]),n(`
`),l("span",{class:"line"},[l("span",null,"}")])])])],-1)])]),_:1}),u[25]||(u[25]=l("h3",{id:"_5-webpack-和-vite-的区别",tabindex:"-1"},[n("5. webpack 和 vite 的区别 "),l("a",{class:"header-anchor",href:"#_5-webpack-和-vite-的区别","aria-label":"Permalink to “5. webpack 和 vite 的区别”"},"​")],-1)),e(t,null,{default:s(()=>[...u[3]||(u[3]=[l("ol",null,[l("li",null,"Webpack：老牌的 打包器，把所有依赖打包成一个或多个 bundle。"),l("li",null,"Vite：新一代 前端构建工具，开发环境利用浏览器的 原生 ES 模块 (ESM)，生产环境用 Rollup 打包。")],-1),l("p",null,"1.开发模式 Webpack： 启动时必须 先打包整个项目，再启动 dev server。 启动速度和项目体积成正比。 Vite： 启动时 不打包业务代码，依赖用 esbuild 预构建，源码按需编译。 启动速度几乎和项目体积无关，大型项目也能秒开。",-1),l("pre",null,[l("code",null,`    👉 一句话：Webpack = 打包后再跑，Vite = 边跑边编译。
`)],-1),l("ol",{start:"2"},[l("li",null,[l("p",null,"热更新（HMR） webpack：基于打包产物 diff，大型项目热更新会卡顿。 Vite：直接基于 ESM 精确替换模块，更新速度更快。")]),l("li",null,[l("p",null,"生产构建 Webpack：开发和生产都用自家打包逻辑。 Vite：开发用 esbuild + ESM，生产用 Rollup 打包（Tree-shaking 更强，但生态不如 Webpack 丰富）。")]),l("li",null,[l("p",null,"配置与生态 Webpack：配置复杂但灵活。loader + plugin 生态极其成熟。 Vite：开箱即用，配置简单。插件体系基于 Rollup，生态在快速增长。")])],-1),l("p",null,"Webpack 是基于打包的老牌全能工具，功能强大但启动和热更新慢；Vite 利用 ESM 和 esbuild，开发体验好、速度快，生产打包用 Rollup。",-1)])]),_:1}),u[26]||(u[26]=l("h3",{id:"_6-react-fiber-架构",tabindex:"-1"},[n("6. React Fiber 架构 "),l("a",{class:"header-anchor",href:"#_6-react-fiber-架构","aria-label":"Permalink to “6. React Fiber 架构”"},"​")],-1)),e(t,null,{default:s(()=>[...u[4]||(u[4]=[l("p",null,[n("Fiber 是 React 对 虚拟 DOM 渲染机制的重写，它的核心目标是："),l("strong",null,"支持可中断的渲染和任务优先级调度"),n("，从而改善大型应用的渲染性能和用户体验。简单理解就是：把更新任务拆成可中断的小单元，按优先级调度执行。")],-1),l("p",null,"Fiber 的数据结构: Fiber 是一个链表/树形结构，每个 Fiber 节点对应一个 React 元素或组件。",-1),l("p",null,"双阶段渲染（两阶段 Reconciliation）:Fiber 实现了 可中断渲染，把渲染分为两个阶段：",-1),l("ul",null,[l("li",null,"Render 阶段（Reconciliation, 构建 Fiber 树，比较新旧 Fiber 树，生成 effect list（要更新的副作用列表）。可以中断、按优先级切分任务。不直接修改 DOM。"),l("li",null,"Commit 阶段:遍历 effect list，将副作用应用到真实 DOM。是同步执行的，一旦开始就不能中断。包括挂载、更新、删除 DOM.")],-1),l("p",null,"调度与优先级:Fiber 内置 任务调度器，任务分为不同优先级：同步任务（高优先级，如点击事件);动画任务异步任务（低优先级，如网络请求完成后的渲染）通过分片（time slicing）和 requestIdleCallback / messChannel / setTimeout，保证 UI 不被阻塞",-1),l("ul",null,[l("li",null,[l("p",null,"Fiber 为什么要出现？"),l("ul",null,[l("li",null,"为了解决 React 15 的同步渲染阻塞问题，支持可中断渲染和任务优先级。")])]),l("li",null,[l("p",null,"Fiber 树 vs 虚拟 DOM 树区别？"),l("ul",null,[l("li",null,"虚拟 DOM 树只表示 UI 元素结构。"),l("li",null,"Fiber 树表示元素 + 组件 + 更新状态 + 优先级 + 副作用列表，更复杂。")])]),l("li",null,[l("p",null,"Render 阶段和 Commit 阶段有什么区别？"),l("ul",null,[l("li",null,"Render 阶段：可中断、生成 effect list，不触碰 DOM。"),l("li",null,"Commit 阶段：同步执行、应用 effect，修改真实 DOM")])])],-1)])]),_:1}),u[27]||(u[27]=l("hr",null,null,-1)),u[28]||(u[28]=l("p",null,"jc",-1)),u[29]||(u[29]=l("h3",{id:"_7-单点登录",tabindex:"-1"},[n("7. 单点登录 "),l("a",{class:"header-anchor",href:"#_7-单点登录","aria-label":"Permalink to “7. 单点登录”"},"​")],-1)),e(t,null,{default:s(()=>[...u[5]||(u[5]=[l("p",null,"用户在一个系统上登录后，就能无感知地访问其他关联系统，无需再次登录。",-1),l("ul",null,[l("li",null,[l("p",null,"统一身份认证中心（Identity Provider, IdP）"),l("ul",null,[l("li",null,"用户只在认证中心登录一次。"),l("li",null,"认证中心负责验证用户名/密码、签发令牌（如 JWT、SAML、OAuth2 Token）。")])]),l("li",null,[l("p",null,"业务系统（Service Provider, SP）"),l("ul",null,[l("li",null,"用户访问业务系统时，业务系统会跳转到认证中心校验。"),l("li",null,"认证成功后，认证中心返回一个「登录凭证」（Token / Ticket）。"),l("li",null,"业务系统验证凭证后，允许用户访问。")])]),l("li",null,[l("p",null,"Cookie + Session（早期）"),l("ul",null,[l("li",null,"依赖共享 Cookie（要求同域或二级域名一致）。"),l("li",null,"局限性大，不适合跨域。")])]),l("li",null,[l("p",null,"Token（JWT / OAuth2 / OpenID Connect）（主流）"),l("ul",null,[l("li",null,"用户认证成功后，认证中心签发 Token。"),l("li",null,"各系统通过 Token 识别用户，支持跨域、跨平台。")])])],-1)])]),_:1}),u[30]||(u[30]=l("h3",{id:"_8-状态管理redux-mobx-pinna-设计模式是啥-区别是啥",tabindex:"-1"},[n("8.状态管理redux mobx pinna 设计模式是啥？区别是啥 "),l("a",{class:"header-anchor",href:"#_8-状态管理redux-mobx-pinna-设计模式是啥-区别是啥","aria-label":"Permalink to “8.状态管理redux mobx pinna 设计模式是啥？区别是啥”"},"​")],-1)),e(t,null,{default:s(()=>[...u[6]||(u[6]=[l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"维度"),l("th",null,"Redux"),l("th",null,"MobX"),l("th",null,"Pinia")])]),l("tbody",null,[l("tr",null,[l("td",null,"状态更新方式"),l("td",null,"不可变 + reducer"),l("td",null,"可变 + observable"),l("td",null,"可变 + reactive")]),l("tr",null,[l("td",null,"阅读 /可预测性"),l("td",null,"高（统一入口）"),l("td",null,"较低（更新处散落）"),l("td",null,"较中等 /接近 Vue 响应式方式")]),l("tr",null,[l("td",null,"异步 /副作用管理"),l("td",null,"通过中间件（thunk / saga）"),l("td",null,"action / reaction / autorun"),l("td",null,"普通 action + 插件 /订阅")]),l("tr",null,[l("td",null,"模块化"),l("td",null,"使用 reducer 组合拆分"),l("td",null,"多 store / classes"),l("td",null,"天生模块 store")]),l("tr",null,[l("td",null,"学习成本"),l("td",null,"较高"),l("td",null,"较低"),l("td",null,"中等（依赖 Vue 响应式理解）")]),l("tr",null,[l("td",null,"调试工具 / 时间旅行"),l("td",null,"强支持（Redux DevTools）"),l("td",null,"有 MobX DevTools、reaction 日志等"),l("td",null,"Pinia Devtools /插件支持")]),l("tr",null,[l("td",null,"适合场景"),l("td",null,"大型复杂状态，团队协作"),l("td",null,"快速开发、响应性重 UI"),l("td",null,"Vue 应用 / Composition API 生态")])])],-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"库"),l("th",null,"核心模式"),l("th",null,"特点")])]),l("tbody",null,[l("tr",null,[l("td",null,"Redux"),l("td",null,"发布-订阅 + 单例模式 + 函数式编程"),l("td",null,"可预测、严格、样板代码多")]),l("tr",null,[l("td",null,"MobX"),l("td",null,"观察者模式 + 响应式 + 面向对象(OOP)"),l("td",null,"简洁直观、自动追踪依赖、灵活")]),l("tr",null,[l("td",null,"Pinia"),l("td",null,"观察者模式 + 依赖注入 + 组合模式"),l("td",null,"结合 Vue3 响应式系统，轻量优雅")])])],-1),l("p",null,"观察者模式 与 发布-订阅模式（格式化）",-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"模式"),l("th",null,"是否有中介"),l("th",null,"耦合度"),l("th",null,"典型场景")])]),l("tbody",null,[l("tr",null,[l("td",null,"观察者模式 (Observer)"),l("td",null,"❌ 没有中介"),l("td",null,"相对紧耦合"),l("td",null,"UI 响应数据变化（如 Vue2）")]),l("tr",null,[l("td",null,"发布-订阅模式 (Pub/Sub)"),l("td",null,"✅ 有中介"),l("td",null,"松耦合"),l("td",null,"事件总线、跨模块通信、消息队列")])])],-1),l("p",null,"概念要点：",-1),l("ul",null,[l("li",null,[l("p",null,"观察者模式（Observer）"),l("ul",null,[l("li",null,"结构：有一个目标对象（Subject），维护观察者列表；状态变化时主动通知所有观察者。"),l("li",null,"特点：点对点通知，被观察者需要知道其观察者；适合一对多、紧密协作场景。")])]),l("li",null,[l("p",null,"发布-订阅模式（Publish‑Subscribe）"),l("ul",null,[l("li",null,"结构：引入消息中间件/事件中心，发布者发布事件到中间件，订阅者从中间件订阅事件。"),l("li",null,"特点：发布者与订阅者解耦，扩展性强，适合多对多和跨模块通信。")])])],-1),l("p",null,"对比总结：",-1),l("ul",null,[l("li",null,"耦合：Observer 更紧耦合（Subject 知道 observers）；Pub/Sub 更松耦合（通过中介解耦）。"),l("li",null,"可扩展性：Pub/Sub 更易扩展和复用；Observer 更简单、直接，适合 UI 内部数据驱动场景。")],-1),l("p",null,"观察者模式（简要结构示例）",-1),l("ul",null,[l("li",null,"Subject: 维护 observers 列表，提供 register / unregister / notify 方法。"),l("li",null,"Observer: 实现 update 接口，接收通知并更新自身。")],-1),l("p",null,"发布-订阅模式（简要结构示例）",-1),l("ul",null,[l("li",null,"EventBus（中介）: on / off / emit。"),l("li",null,"发布者: emit(event, payload)。"),l("li",null,"订阅者: on(event, handler)。")],-1)])]),_:1}),u[31]||(u[31]=l("h3",{id:"_9-如果一个项目-使用了antd-组件库-又使用了antd-2次开发组件库-会不会有问题",tabindex:"-1"},[n("9. 如果一个项目 使用了antd 组件库, 又使用了antd 2次开发组件库 会不会有问题 "),l("a",{class:"header-anchor",href:"#_9-如果一个项目-使用了antd-组件库-又使用了antd-2次开发组件库-会不会有问题","aria-label":"Permalink to “9. 如果一个项目 使用了antd 组件库, 又使用了antd 2次开发组件库 会不会有问题”"},"​")],-1)),e(t,null,{default:s(()=>[...u[7]||(u[7]=[l("ol",null,[l("li",null,"样式冲突, 可以通过修改命名前缀区分"),l("li",null,"ConfigProvider 全局化配置也可能会冲突")],-1)])]),_:1}),u[32]||(u[32]=l("h3",{id:"_10-页面卡顿-内存泄露排查",tabindex:"-1"},[n("10. 页面卡顿，内存泄露排查 "),l("a",{class:"header-anchor",href:"#_10-页面卡顿-内存泄露排查","aria-label":"Permalink to “10. 页面卡顿，内存泄露排查”"},"​")],-1)),e(t,null,{default:s(()=>[...u[8]||(u[8]=[l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"现象"),l("th",null,"原因可能性")])]),l("tbody",null,[l("tr",null,[l("td",null,"页面卡顿 / 帧率低 /响应迟钝"),l("td",null,"JS 执行时间过长、频繁重绘/重排、布局触发、事件处理阻塞、定时器或循环、垃圾回收暂停")]),l("tr",null,[l("td",null,"内存持续上涨不降 /长时间运行后越来越慢"),l("td",null,"内存泄漏：一些对象、DOM、回调、事件监听器、定时器等未被释放仍被引用")])])],-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"阶段"),l("th",null,"目标"),l("th",null,"使用工具"),l("th",null,"主要操作"),l("th",null,"关键观察点"),l("th",null,"可能问题 /风险")])]),l("tbody",null,[l("tr",null,[l("td",null,[l("strong",null,"1️⃣ 确认问题")]),l("td",null,"复现卡顿或内存异常的场景"),l("td",null,"浏览器、用户日志、监控平台"),l("td",null,"收集用户反馈、复现路径、操作步骤"),l("td",null,"卡顿是否规律出现 / 内存是否持续上涨"),l("td",null,"确认是性能问题而非业务阻塞")]),l("tr",null,[l("td",null,[l("strong",null,"2️⃣ 初步检测")]),l("td",null,"判断是卡顿还是内存泄漏"),l("td",null,[n("Chrome DevTools → "),l("strong",null,"Performance Monitor")]),l("td",null,"观察 FPS、CPU、JS Heap、DOM Node 数量变化"),l("td",null,"Heap、Node 数持续上升"),l("td",null,"存在潜在泄漏或渲染过频")]),l("tr",null,[l("td",null,[l("strong",null,"3️⃣ 拍快照分析")]),l("td",null,"捕获堆内对象状态"),l("td",null,[n("DevTools → "),l("strong",null,"Memory → Heap Snapshot")]),l("td",null,"操作前 / 操作后各拍一份快照"),l("td",null,"Retained Size / Detached DOM Trees"),l("td",null,"未被释放的 DOM / 对象被引用")]),l("tr",null,[l("td",null,[l("strong",null,"4️⃣ 对比快照")]),l("td",null,"找出泄漏源头"),l("td",null,[n("Memory → "),l("strong",null,"Comparison 视图")]),l("td",null,"比较两份快照差异"),l("td",null,"哪些对象 / 节点数量持续增加"),l("td",null,"确认泄漏对象及增长趋势")]),l("tr",null,[l("td",null,[l("strong",null,"5️⃣ 引用链分析")]),l("td",null,"找出被谁持有"),l("td",null,[n("Memory → "),l("strong",null,"Retainers / Object References")]),l("td",null,"追踪泄漏对象的引用路径"),l("td",null,"闭包、全局变量、事件监听、定时器"),l("td",null,"典型 JS 引用未释放")]),l("tr",null,[l("td",null,[l("strong",null,"6️⃣ 修复验证")]),l("td",null,"移除引用 / 优化逻辑"),l("td",null,"代码修改 + 重测"),l("td",null,"清理事件、取消定时器、销毁监听、优化响应式"),l("td",null,"重新运行监控，确认 Heap 稳定"),l("td",null,"内存回收正常、卡顿消失")]),l("tr",null,[l("td",null,[l("strong",null,"7️⃣ 性能优化")]),l("td",null,"防止再次发生"),l("td",null,"Performance 面板 + Lighthouse"),l("td",null,"分析长任务（>50ms）和渲染瓶颈"),l("td",null,"Recalculate Style / Layout / Paint 频率"),l("td",null,"渲染层优化、减少阻塞 JS")]),l("tr",null,[l("td",null,[l("strong",null,"8️⃣ 持续监控")]),l("td",null,"监控上线表现"),l("td",null,"性能监控 SDK（如 Sentry、WebVitals）"),l("td",null,"采集 FPS / Heap / 页面耗时数据"),l("td",null,"长时间运行后趋势"),l("td",null,"提前发现潜在泄漏")])])],-1)])]),_:1}),u[33]||(u[33]=l("h3",{id:"_11-定位白屏的常见原因",tabindex:"-1"},[n("11.定位白屏的常见原因 "),l("a",{class:"header-anchor",href:"#_11-定位白屏的常见原因","aria-label":"Permalink to “11.定位白屏的常见原因”"},"​")],-1)),e(t,null,{default:s(()=>[...u[9]||(u[9]=[l("ul",null,[l("li",null,[l("p",null,"1.JavaScript 错误导致渲染中断"),l("ul",null,[l("li",null,"症状：控制台报错，页面无法正常渲染。"),l("li",null,"也可能接口返回异常数据或前端未兼容数据")])]),l("li",null,[l("p",null,"2.关键资源加载失败"),l("ul",null,[l("li",null,"症状：页面依赖的 CSS、JS、图片等资源未加载，导致页面样式或功能缺失。")])]),l("li",null,[l("p",null,"3.页面渲染逻辑异常"),l("ul",null,[l("li",null,"症状：页面结构正常，但内容未渲染。"),l("li",null,[n("排查方法： "),l("ul",null,[l("li",null,"检查 JavaScript 渲染逻辑，确认数据是否正确传递和处理。"),l("li",null,"使用断点调试，逐步执行代码，查看变量值和执行流程。")])])])]),l("li",null,[l("p",null,"4.浏览器兼容性问题"),l("ul",null,[l("li",null,"症状：特定浏览器或版本下页面白屏。"),l("li",null,"排查方法："),l("li",null,"使用 Can I Use 等工具，检查所用特性在目标浏览器中的支持情况。"),l("li",null,"添加适当的 Polyfill，确保功能在旧版浏览器中可用")])]),l("li",null,[l("ol",{start:"5"},[l("li",null,"网络环境或权限问题")]),l("ul",null,[l("li",null,"症状：在特定网络环境下（如公司内网）页面白屏。"),l("li",null,[n("排查方法： "),l("ul",null,[l("li",null,"检查 Content Security Policy（CSP）设置，确保没有阻止资源加载。"),l("li",null,"确认没有被防火墙或安全软件拦截")])])])]),l("li",null,[l("p",null,"6.白屏检测方案"),l("ul",null,[l("li",null,[l("p",null,"方案一：检测根节点是否渲染：通过检查根节点是否有内容，判断页面是否白屏。")]),l("li",null,[l("p",null,"方案二：Mutation Observer 监听 DOM 变化：监听页面 DOM 变化，判断页面是否渲染。")]),l("li",null,[l("p",null,"方案三：页面截图检测：对比页面截图与纯白图片，判断页面是否白屏。")]),l("li",null,[l("p",null,"方案四：采样对比：在页面中采样多个点，判断是否有元素渲染。")]),l("li",null,[l("p",null,"步骤："),l("ul",null,[l("li",null,"1.生成随机坐标点：在页面的宽度和高度范围内生成多个随机坐标点。"),l("li",null,"2.检查坐标点处的元素：使用 document.elementFromPoint(x, y) 方法获取指定坐标点处的最上层元素。"),l("li",null,"3.判断元素是否可见：检查获取到的元素是否存在且可见。")])])])])],-1),l("div",{class:"language-"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"}),l("pre",{class:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabindex:"0",dir:"ltr"},[l("code",null,[l("span",{class:"line"},[l("span",null,"function isElementRendered(sampleCount = 10) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"    let visibleCount = 0;")]),n(`
`),l("span",{class:"line"},[l("span",null,"    for (let i = 0; i < sampleCount; i++) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"        const x = Math.random() * window.innerWidth;")]),n(`
`),l("span",{class:"line"},[l("span",null,"        const y = Math.random() * window.innerHeight;")]),n(`
`),l("span",{class:"line"},[l("span",null,"        const element = document.elementFromPoint(x, y);")]),n(`
`),l("span",{class:"line"},[l("span")]),n(`
`),l("span",{class:"line"},[l("span",null,"        if (element && element.offsetParent !== null) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"            visibleCount++;")]),n(`
`),l("span",{class:"line"},[l("span",null,"        }")]),n(`
`),l("span",{class:"line"},[l("span",null,"    }")]),n(`
`),l("span",{class:"line"},[l("span")]),n(`
`),l("span",{class:"line"},[l("span",null,"    return visibleCount / sampleCount > 0.5; // 如果超过一半的采样点有可见元素，认为页面已渲染")]),n(`
`),l("span",{class:"line"},[l("span",null,"}")])])])],-1)])]),_:1}),u[34]||(u[34]=l("h3",{id:"_12-浏览器事件循环-网络请求是宏任务吗",tabindex:"-1"},[n("12.浏览器事件循环，网络请求是宏任务吗？ "),l("a",{class:"header-anchor",href:"#_12-浏览器事件循环-网络请求是宏任务吗","aria-label":"Permalink to “12.浏览器事件循环，网络请求是宏任务吗？”"},"​")],-1)),e(t,null,{default:s(()=>[...u[10]||(u[10]=[l("p",null,"是的，浏览器中的网络请求（如使用 fetch 或 XMLHttpRequest）属于宏任务（macrotask）。",-1),l("p",null,"调用栈（Call Stack）：执行同步代码。 - 宏任务队列（Macrotask Queue）：存放宏任务的回调函数，例如 setTimeout、setInterval、DOM 事件、网络请求, UI 渲染等。 - 微任务队列（Microtask Queue）：存放微任务的回调函数，例如 Promise.then、MutationObserver 等。",-1),l("p",null,"事件循环的执行顺序如下：",-1),l("ul",null,[l("li",null,"执行调用栈中的同步代码。"),l("li",null,"执行微任务队列中的所有任务，直到队列为空。"),l("li",null,"更新渲染（如果需要）。"),l("li",null,"从宏任务队列中取出一个任务执行。"),l("li",null,"重复上述步骤")],-1),l("p",null,"宏任务 → 微任务 → ✅ 渲染 → 下一个宏任务",-1),l("div",{class:"language-"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"}),l("pre",{class:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabindex:"0",dir:"ltr"},[l("code",null,[l("span",{class:"line"},[l("span",null,"┌────────────────────────────┐")]),n(`
`),l("span",{class:"line"},[l("span",null,"│       1. 取一个宏任务       │ (如 script, I/O, setTimeout 回调)")]),n(`
`),l("span",{class:"line"},[l("span",null,"├────────────────────────────┤")]),n(`
`),l("span",{class:"line"},[l("span",null,"│       2. 执行所有微任务     │ (Promise.then, MutationObserver)")]),n(`
`),l("span",{class:"line"},[l("span",null,"├────────────────────────────┤")]),n(`
`),l("span",{class:"line"},[l("span",null,"│       3. 执行渲染前钩子     │ (requestAnimationFrame)")]),n(`
`),l("span",{class:"line"},[l("span",null,"├────────────────────────────┤")]),n(`
`),l("span",{class:"line"},[l("span",null,"│       4. 执行渲染 / 绘制    │ (样式计算, 布局, 合成, 绘制)")]),n(`
`),l("span",{class:"line"},[l("span",null,"├────────────────────────────┤")]),n(`
`),l("span",{class:"line"},[l("span",null,"│       5. requestIdleCallback │ (如果有空闲)")]),n(`
`),l("span",{class:"line"},[l("span",null,"├────────────────────────────┤")]),n(`
`),l("span",{class:"line"},[l("span",null,"│       6. 下一个宏任务循环    │")]),n(`
`),l("span",{class:"line"},[l("span",null,"└────────────────────────────┘")])])])],-1),l("p",null,[l("strong",null,"宏任务 → 微任务 → rAF → 渲染 → idle → 下一宏任务")],-1)])]),_:1}),u[35]||(u[35]=l("h3",{id:"_13-页面的线程",tabindex:"-1"},[n("13. 页面的线程 "),l("a",{class:"header-anchor",href:"#_13-页面的线程","aria-label":"Permalink to “13. 页面的线程”"},"​")],-1)),e(t,null,{default:s(()=>[...u[11]||(u[11]=[l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"线程名称"),l("th",null,"职责"),l("th",null,"是否并行"),l("th",null,"示例说明")])]),l("tbody",null,[l("tr",null,[l("td",null,[l("strong",null,"主线程（Main Thread）")]),l("td",null,"执行 JS、解析 HTML、计算样式、布局（layout）、绘制（paint）"),l("td",null,"❌ 单线程"),l("td",null,"JS 运行、DOM 操作、重排、重绘都在此执行")]),l("tr",null,[l("td",null,[l("strong",null,"渲染线程 / 合成线程（Compositor Thread）")]),l("td",null,"接收绘制指令，合成图层生成最终画面"),l("td",null,"✅ 可并行"),l("td",null,"负责 GPU 合成层的渲染，保证流畅动画")]),l("tr",null,[l("td",null,[l("strong",null,"光栅化线程（Raster Thread）")]),l("td",null,"把图层位图栅格化（交给 GPU 绘制）"),l("td",null,"✅ 多线程"),l("td",null,"将合成层绘制成像素输出")]),l("tr",null,[l("td",null,[l("strong",null,"网络线程（Network Thread）")]),l("td",null,"处理网络请求（HTTP、WebSocket、fetch）"),l("td",null,"✅ 独立"),l("td",null,"不受主线程阻塞，可同时并发多个请求")]),l("tr",null,[l("td",null,[l("strong",null,"IO 线程（Browser Process）")]),l("td",null,"管理文件、Cookie、缓存、输入输出等"),l("td",null,"✅ 独立"),l("td",null,"负责硬盘 / 系统层交互")]),l("tr",null,[l("td",null,[l("strong",null,"定时器线程（Timer Thread）")]),l("td",null,"管理定时器（setTimeout / setInterval）"),l("td",null,"✅ 独立"),l("td",null,"到期后把回调放回主线程事件队列执行")]),l("tr",null,[l("td",null,[l("strong",null,"Web Worker 线程")]),l("td",null,"执行耗时 JS 计算（不操作 DOM）"),l("td",null,"✅ 多线程"),l("td",null,"后台计算、大文件处理、AI、解析任务")]),l("tr",null,[l("td",null,[l("strong",null,"Service Worker 线程")]),l("td",null,"拦截请求、缓存资源、推送等"),l("td",null,"✅ 独立"),l("td",null,"PWA 核心线程，生命周期独立于页面")]),l("tr",null,[l("td",null,[l("strong",null,"GPU 线程（GPU Process）")]),l("td",null,"负责页面绘制、图像合成、3D 渲染"),l("td",null,"✅ 独立"),l("td",null,"合成层最终交由 GPU 渲染输出")])])],-1),l("p",null,[l("strong",null,"JS、DOM、CSSOM、Layout、Paint、事件响应、垃圾回收（GC）都在主线程中执行。")],-1),l("p",null,"因此：当 JS 执行时间过长时（例如死循环 / 大量同步逻辑），会阻塞渲染 → 页面卡顿。当频繁修改 DOM、触发布局重排（Reflow）、重绘（Repaint）时，主线程负载增加 → FPS 下降。",-1),l("p",null,"✅ 这就是为什么浏览器看似“多线程”，但 JS 执行仍是单线程的根本原因：JS 与渲染共用主线程，为了避免线程竞争 DOM。",-1)])]),_:1}),u[36]||(u[36]=l("h3",{id:"_14-ts-type-interface",tabindex:"-1"},[n("14.ts type interface "),l("a",{class:"header-anchor",href:"#_14-ts-type-interface","aria-label":"Permalink to “14.ts type interface”"},"​")],-1)),e(t,null,{default:s(()=>[...u[12]||(u[12]=[l("ul",null,[l("li",null,[l("p",null,"interface：适用于定义对象的结构，支持声明合并和扩展，便于面向对象编程。(推荐interface)")]),l("li",null,[l("p",null,"type：适用于定义联合类型、交叉类型、元组等复杂类型，提供更强的表达能力")])],-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"对比维度"),l("th",null,[l("code",null,"interface")]),l("th",null,[l("code",null,"type")])])]),l("tbody",null,[l("tr",null,[l("td",null,[l("strong",null,"语义")]),l("td",null,"描述“对象的结构”或“类的契约”"),l("td",null,"可定义任意类型（对象、联合、交叉、原始类型等）")]),l("tr",null,[l("td",null,[l("strong",null,"扩展方式")]),l("td",null,[n("通过 "),l("code",null,"extends"),n(" 继承")]),l("td",null,[n("通过 "),l("code",null,"&"),n("（交叉类型）组合")])]),l("tr",null,[l("td",null,[l("strong",null,"可合并性（声明合并）")]),l("td",null,"✅ 可以多次定义同名接口，自动合并"),l("td",null,"❌ 不可重复声明同名 type")]),l("tr",null,[l("td",null,[l("strong",null,"能定义的类型范围")]),l("td",null,"仅限对象、函数、类结构"),l("td",null,"✅ 可定义联合类型、交叉类型、条件类型、元组等")]),l("tr",null,[l("td",null,[l("strong",null,"实现关系")]),l("td",null,[n("类（class）可实现（"),l("code",null,"implements"),n("）接口")]),l("td",null,[n("类不能直接实现 "),l("code",null,"type")])]),l("tr",null,[l("td",null,[l("strong",null,"复杂类型表达")]),l("td",null,"不支持直接定义联合、映射等复杂类型"),l("td",null,"✅ 支持高级类型语法（联合、条件、映射等）")]),l("tr",null,[l("td",null,[l("strong",null,"兼容性")]),l("td",null,"更适合定义公共 API（库、类）"),l("td",null,"更灵活，适合组合与函数类型")]),l("tr",null,[l("td",null,[l("strong",null,"编译后表现")]),l("td",null,"不会生成 JS 代码，仅用于类型检查"),l("td",null,"同样仅存在于类型层")])])],-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"场景"),l("th",null,"推荐类型"),l("th",null,"理由")])]),l("tbody",null,[l("tr",null,[l("td",null,"定义对象结构 / 类契约"),l("td",null,[l("code",null,"interface")]),l("td",null,"语义更清晰、支持声明合并")]),l("tr",null,[l("td",null,"定义联合、交叉、映射类型"),l("td",null,[l("code",null,"type")]),l("td",null,"表达力更强")]),l("tr",null,[l("td",null,"在公共库、类型声明文件中"),l("td",null,[l("code",null,"interface")]),l("td",null,"更好扩展性")]),l("tr",null,[l("td",null,"内部工具类型、组合类型"),l("td",null,[l("code",null,"type")]),l("td",null,"更灵活简洁")])])],-1)])]),_:1}),u[37]||(u[37]=l("h3",{id:"_15-ts-泛型",tabindex:"-1"},[n("15. ts 泛型 "),l("a",{class:"header-anchor",href:"#_15-ts-泛型","aria-label":"Permalink to “15. ts 泛型”"},"​")],-1)),e(t,null,{default:s(()=>[...u[13]||(u[13]=[l("p",null,"泛型（Generics） 是一种强大的特性，允许在定义函数、接口或类时不预先指定具体的类型，而在使用时再指定类型，从而实现类型的复用和灵活性。 泛型使得代码在处理不同类型的数据时，仍能保持类型安全。",-1),l("p",null,"泛型的优势",-1),l("ul",null,[l("li",null,[l("p",null,"类型安全：在编译时进行类型检查，避免运行时错误。")]),l("li",null,[l("p",null,"代码复用：编写与特定类型无关的通用代码，提高代码的复用性。")]),l("li",null,[l("p",null,"灵活性：根据实际需要指定类型，适应不同的数据类型和数据结构。")]),l("li",null,[l("p",null,"高级: 泛型约束, 默认泛型类型, 泛型与联合类型,")]),l("li",null,[l("p",null,[l("strong",null,"函数重载: 所谓函数重载就是同一个函数，根据传递的参数不同，会有不同的表现形式")])]),l("li",null,[l("p",null,"never是其它类型(null undefined)的子类型，代表不会出现的值")])],-1)])]),_:1}),u[38]||(u[38]=l("h3",{id:"_16-从输入-url-到页面渲染的完整流程-说出自己的理解",tabindex:"-1"},[n("16. 从输入 URL 到页面渲染的完整流程, 说出自己的理解 "),l("a",{class:"header-anchor",href:"#_16-从输入-url-到页面渲染的完整流程-说出自己的理解","aria-label":"Permalink to “16. 从输入 URL 到页面渲染的完整流程, 说出自己的理解”"},"​")],-1)),e(t,null,{default:s(()=>[...u[14]||(u[14]=[l("p",null,"当用户输入一个 URL 并回车，整个过程可以拆成 五个阶段：",-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"阶段"),l("th",null,"描述"),l("th",null,"涉及层次")])]),l("tbody",null,[l("tr",null,[l("td",null,"1️⃣ 地址解析"),l("td",null,"URL 解析、缓存检查、DNS 查询、协议判断（HTTP/HTTPS）"),l("td",null,"网络层")]),l("tr",null,[l("td",null,"2️⃣ 建立连接"),l("td",null,"TCP 三次握手、TLS 握手（HTTPS）"),l("td",null,"传输层")]),l("tr",null,[l("td",null,"3️⃣ 发送请求"),l("td",null,"HTTP 请求报文构造与发送"),l("td",null,"应用层")]),l("tr",null,[l("td",null,"4️⃣ 服务器响应"),l("td",null,"服务端处理并返回 HTML/CSS/JS/图片等资源"),l("td",null,"服务端")]),l("tr",null,[l("td",null,"5️⃣ 浏览器渲染"),l("td",null,"构建 DOM / CSSOM / Render Tree / Layout / Paint / Composite"),l("td",null,"浏览器内核")])])],-1),l("ol",null,[l("li",null,"URL 解析与 DNS 查询")],-1),l("p",null,"流程：",-1),l("ul",null,[l("li",null,"浏览器解析输入内容（判断是搜索词还是 URL）；"),l("li",null,"检查本地缓存（DNS 缓存、hosts 文件）；"),l("li",null,"若无缓存，向本地 DNS 服务器递归/迭代查询；"),l("li",null,"得到目标 IP。")],-1),l("p",null,"可以优化的点",-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"优化项"),l("th",null,"说明")])]),l("tbody",null,[l("tr",null,[l("td",null,"✅ 使用 CDN"),l("td",null,"缩短 DNS 路径与物理距离")]),l("tr",null,[l("td",null,[n("✅ DNS 预解析 ("),l("code",null,'<link rel="dns-prefetch" href="//example.com">'),n(")")]),l("td",null,"提前解析域名")]),l("tr",null,[l("td",null,"✅ 减少跨域请求"),l("td",null,"减少不同域名下的资源请求数")]),l("tr",null,[l("td",null,"✅ 服务端启用 HTTP/2"),l("td",null,"复用连接，减少 DNS 解析次数")])])],-1),l("ol",{start:"2"},[l("li",null,"建立 TCP / TLS 连接")],-1),l("p",null,"流程：",-1),l("ul",null,[l("li",null,"TCP 三次握手；"),l("li",null,"若 HTTPS：还需 TLS 握手（证书验证、密钥协商）；"),l("li",null,"建立安全连接。")],-1),l("p",null,"可以优化的点:",-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"优化项"),l("th",null,"说明")])]),l("tbody",null,[l("tr",null,[l("td",null,"✅ 开启 HTTP/2 or HTTP/3"),l("td",null,"多路复用，减少握手消耗")]),l("tr",null,[l("td",null,"✅ 复用连接（Keep-Alive）"),l("td",null,"减少新连接建立的开销")]),l("tr",null,[l("td",null,"✅ TLS 1.3"),l("td",null,"减少握手 RTT 次数")]),l("tr",null,[l("td",null,"✅ 使用 CDN 边缘节点"),l("td",null,"减少物理延迟")])])],-1),l("ol",{start:"3"},[l("li",null,"发送 HTTP 请求")],-1),l("p",null,"流程：",-1),l("ul",null,[l("li",null,"浏览器构造请求头；"),l("li",null,"附带 cookie / token；"),l("li",null,"发送到服务器。")],-1),l("p",null,"可以优化的点:",-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"优化项"),l("th",null,"说明")])]),l("tbody",null,[l("tr",null,[l("td",null,"✅ 压缩请求头（HTTP/2）"),l("td",null,"减少 header 体积")]),l("tr",null,[l("td",null,"✅ 合理使用缓存头（ETag / Cache-Control）"),l("td",null,"减少重复请求")]),l("tr",null,[l("td",null,"✅ 精简 Cookie"),l("td",null,"减少请求体积")]),l("tr",null,[l("td",null,"✅ 使用 POST/GET 正确语义"),l("td",null,"避免误用")])])],-1),l("ol",{start:"4"},[l("li",null,"服务器响应阶段")],-1),l("p",null,"流程：",-1),l("ul",null,[l("li",null,"服务器解析请求；"),l("li",null,"调用后端逻辑 / 查询数据库；"),l("li",null,"渲染模板（SSR 或返回静态文件）；"),l("li",null,"返回响应体（HTML、CSS、JS、图片等）")],-1),l("p",null,"可以优化的点:",-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"优化项"),l("th",null,"说明")])]),l("tbody",null,[l("tr",null,[l("td",null,"✅ 静态化 / CDN 缓存"),l("td",null,"HTML/资源分发")]),l("tr",null,[l("td",null,"✅ SSR / SSG"),l("td",null,"加快首屏渲染")]),l("tr",null,[l("td",null,"✅ 接口聚合 / GraphQL"),l("td",null,"减少多次请求")]),l("tr",null,[l("td",null,"✅ 压缩响应（Gzip/Brotli）"),l("td",null,"减小传输体积")]),l("tr",null,[l("td",null,"✅ 分片传输 (Transfer-Encoding: chunked)"),l("td",null,"边传输边渲染")])])],-1),l("ol",{start:"5"},[l("li",null,"浏览器渲染阶段")],-1),l("p",null,"5.1 构建 DOM",-1),l("ul",null,[l("li",null,"解析 HTML → 生成 DOM 树；"),l("li",null,[l("code",null,"<script>"),n(" 会阻塞解析（除非 async 或 defer）。")])],-1),l("p",null,"优化：",-1),l("ul",null,[l("li",null,"defer / async 加载 JS；"),l("li",null,"HTML 压缩；"),l("li",null,"优化首屏 HTML 结构（避免过多嵌套）；"),l("li",null,"将不关键的脚本延迟加载。")],-1),l("p",null,"5.2 构建 CSSOM",-1),l("ul",null,[l("li",null,"下载并解析 CSS；"),l("li",null,"与 DOM 合并成 Render Tree。")],-1),l("p",null,"优化：",-1),l("ul",null,[l("li",null,"减少外链 CSS；"),l("li",null,"使用关键路径渲染优化（Critical CSS）；"),l("li",null,"避免复杂选择器；"),l("li",null,[n("使用 "),l("link",{rel:"preload"}),n(" 预加载关键 CSS。")])],-1),l("p",null,"5.3 Render Tree → Layout → Paint → Composite",-1),l("ul",null,[l("li",null,"Layout：计算每个节点的几何位置；"),l("li",null,"Paint：绘制像素；"),l("li",null,"Composite：合成层，GPU 加速渲染。")],-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"优化项"),l("th",null,"原理")])]),l("tbody",null,[l("tr",null,[l("td",null,"✅ 减少重排重绘"),l("td",null,[n("避免频繁修改 layout 属性（如 "),l("code",null,"width"),n("、"),l("code",null,"height"),n("）")])]),l("tr",null,[l("td",null,"✅ 使用 transform/opacity 动画"),l("td",null,"利用 GPU 合成层")]),l("tr",null,[l("td",null,"✅ 合理使用 will-change"),l("td",null,"告诉浏览器提前优化渲染层")]),l("tr",null,[l("td",null,"✅ 懒加载图片与组件"),l("td",null,"降低首屏压力")]),l("tr",null,[l("td",null,"✅ 使用虚拟列表"),l("td",null,"优化长列表性能")])])],-1),l("p",null,"整体性能优化策略总结:",-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"阶段"),l("th",null,"关键优化方向")])]),l("tbody",null,[l("tr",null,[l("td",null,"网络"),l("td",null,"DNS 缓存、HTTP/2、CDN、Keep-Alive")]),l("tr",null,[l("td",null,"请求"),l("td",null,"缓存策略、资源合并与压缩")]),l("tr",null,[l("td",null,"传输"),l("td",null,"Gzip/Brotli 压缩、分片传输")]),l("tr",null,[l("td",null,"渲染"),l("td",null,"异步加载、懒加载、Critical CSS、DOM 优化")]),l("tr",null,[l("td",null,"交互"),l("td",null,"Debounce/Throttle、GPU 动画、虚拟滚动")]),l("tr",null,[l("td",null,"构建"),l("td",null,"Tree-shaking、Code Splitting、懒加载模块")])])],-1),l("p",null,"可量化的指标（Web Vitals）",-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"指标"),l("th",null,"说明"),l("th",null,"理想值")])]),l("tbody",null,[l("tr",null,[l("td",null,[l("strong",null,"LCP"),n(" (Largest Contentful Paint)")]),l("td",null,"最大内容渲染时间"),l("td",null,"< 2.5s")]),l("tr",null,[l("td",null,[l("strong",null,"FID"),n(" (First Input Delay)")]),l("td",null,"首次交互延迟"),l("td",null,"< 100ms")]),l("tr",null,[l("td",null,[l("strong",null,"CLS"),n(" (Cumulative Layout Shift)")]),l("td",null,"页面布局稳定性"),l("td",null,"< 0.1")]),l("tr",null,[l("td",null,[l("strong",null,"TTFB"),n(" (Time to First Byte)")]),l("td",null,"首字节时间"),l("td",null,"< 0.8s")]),l("tr",null,[l("td",null,[l("strong",null,"FCP"),n(" (First Contentful Paint)")]),l("td",null,"首次内容绘制"),l("td",null,"< 1.8s")])])],-1)])]),_:1}),u[39]||(u[39]=o(`<h3 id="_17-web安全" tabindex="-1">17. web安全 <a class="header-anchor" href="#_17-web安全" aria-label="Permalink to “17. web安全”">​</a></h3><p><a href="/myKMS/knowledge/browser/webSecurity.html">web安全</a></p><ol><li>xss</li><li>csrf</li><li>点击劫持</li><li>token</li><li>sql注入</li><li>文件上传</li><li>认证与权限</li><li>加密算法</li><li>ddos</li><li>爬虫</li><li>服务器安全</li></ol><h3 id="_18-防爬虫" tabindex="-1">18. 防爬虫 <a class="header-anchor" href="#_18-防爬虫" aria-label="Permalink to “18. 防爬虫”">​</a></h3><pre><code>1. 使用验证码
2. 设置访问频率限制
3. 使用 User-Agent 检测
4. 动态内容加载
5. IP 黑名单
6. 使用 Token 验证
</code></pre><h3 id="_19-缓存" tabindex="-1">19. 缓存 <a class="header-anchor" href="#_19-缓存" aria-label="Permalink to “19. 缓存”">​</a></h3>`,6)),e(t,null,{default:s(()=>[...u[15]||(u[15]=[l("p",null,"浏览器 / 缓存层（代理、CDN）会将服务器响应保存起来，当下次请求相同资源时可直接从缓存中返回，而不必到服务器取。这样可以减少网络延迟和服务器负荷。",-1),l("ul",null,[l("li",null,[l("p",null,"新鲜度判断（Freshness） vs 验证（Validation）"),l("ul",null,[l("li",null,"新鲜（Fresh）：在有效期内，缓存可直接返回给客户端。"),l("li",null,"陈旧（Stale）：资源已过有效期，需要验证是否更新（例如通过 ETag / Last-Modified）或强制重新下载。")]),l("p",null,"验证机制：客户端发送条件请求（If-None-Match, If-Modified-Since），服务器如资源未变返回 304 Not Modified 让客户端继续用缓存。")]),l("li",null,[l("p",null,"缓存作用域"),l("ul",null,[l("li",null,[l("p",null,"私有缓存（Private Cache）：如浏览器本地缓存，仅对单个用户可见。")]),l("li",null,[l("p",null,"共享缓存（Shared Cache / Proxy / CDN）：CDN / 代理服务器等中间缓存，可被多个用户共享。对于涉及用户隐私或基于 cookie 的响应，要限制这类缓存")])])]),l("li",null,[l("p",null,"no-cache ≠ “不缓存” —— 它允许缓存储存，但使用前必须验证。")]),l("li",null,[l("p",null,"no-store 是“不储存”的真正指令，但不会清除已经缓存的旧数据。")]),l("li",null,[l("p",null,"Expires 比较老旧，现代多数场景用 cache-control 的 max-age。")]),l("li",null,[l("p",null,"实践中: 一般index.html 都是 no-store no-cache 的, 其他静态资源都是设置长缓存的.")])],-1)])]),_:1}),u[40]||(u[40]=l("hr",null,null,-1)),u[41]||(u[41]=l("p",null,"zx",-1)),u[42]||(u[42]=l("h3",{id:"_20-组件-key-改变和-props-改变有什么区别",tabindex:"-1"},[n("20. 组件 key 改变和 props 改变有什么区别 "),l("a",{class:"header-anchor",href:"#_20-组件-key-改变和-props-改变有什么区别","aria-label":"Permalink to “20. 组件 key 改变和 props 改变有什么区别”"},"​")],-1)),e(t,null,{default:s(()=>[...u[16]||(u[16]=[l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"变化类型"),l("th",null,"对组件实例的影响"),l("th",null,"生命周期"),l("th",null,"state 是否保留"),l("th",null,"主要使用场景")])]),l("tbody",null,[l("tr",null,[l("td",null,[l("strong",null,"key 改变")]),l("td",null,[l("strong",null,"卸载旧组件 → 挂载新组件"),n("（实例被销毁并重建）")]),l("td",null,[n("先触发旧组件的 "),l("code",null,"componentWillUnmount"),n(" / "),l("code",null,"useEffect"),n(" 的 cleanup，再触发新组件的 "),l("code",null,"constructor"),n(" → "),l("code",null,"render"),n(" → "),l("code",null,"useEffect")]),l("td",null,[l("strong",null,"不会保留"),n("（因为是全新实例）")]),l("td",null,"当需要强制重新初始化组件（比如重置表单、重新加载数据）")]),l("tr",null,[l("td",null,[l("strong",null,"props 改变（key 不变）")]),l("td",null,[l("strong",null,"复用原组件实例")]),l("td",null,[n("触发 "),l("code",null,"shouldComponentUpdate"),n("（如有）/ "),l("code",null,"render"),n(" / 更新后的 "),l("code",null,"useEffect")]),l("td",null,[l("strong",null,"会保留"),n("（除非代码主动重置）")]),l("td",null,"正常的属性更新：列表内容变化、UI 随数据更新")])])],-1),l("h4",{id:"核心思想",tabindex:"-1"},[n("核心思想 "),l("a",{class:"header-anchor",href:"#核心思想","aria-label":"Permalink to “核心思想”"},"​")],-1),l("ul",null,[l("li",null,"key 是身份标签：一变就换人（卸载 + 重建）。"),l("li",null,"props 是输入数据：只变数据，不换人（实例保留）。")],-1),l("h5",{id:"一句话总结",tabindex:"-1"},[n("一句话总结 "),l("a",{class:"header-anchor",href:"#一句话总结","aria-label":"Permalink to “一句话总结”"},"​")],-1),l("ul",null,[l("li",null,"需要强制重新初始化组件（如清空表单、重新加载动画）时，用 key；"),l("li",null,"仅需更新组件展示的数据时，修改 props 即可。")],-1),l("h4",{id:"深入-props-引用没变-vs-引用改变",tabindex:"-1"},[n("深入: props 引用没变 vs 引用改变 "),l("a",{class:"header-anchor",href:"#深入-props-引用没变-vs-引用改变","aria-label":"Permalink to “深入: props 引用没变 vs 引用改变”"},"​")],-1),l("ul",null,[l("li",null,[l("p",null,"props 引用没变"),l("ul",null,[l("li",null,"父组件重新渲染，但 data 对象引用没变。"),l("li",null,"React 认为 props 没有变化，子组件如果是 React.memo，不会重新渲染。"),l("li",null,"state 保留，useEffect 依赖不会触发（如果依赖该 prop）。")])]),l("li",null,[l("p",null,"props 引用改变"),l("ul",null,[l("li",null,"每次父组件渲染都会生成新对象。"),l("li",null,"即使内容相同，引用改变 → React 认为 props 改变。"),l("li",null,"React.memo 会触发重新渲染。"),l("li",null,"useEffect 依赖该 prop 也会重新执行。")])])],-1)])]),_:1}),u[43]||(u[43]=l("h3",{id:"_26-react-form-里面非受控组件-如何对应上值的改变",tabindex:"-1"},[n("26. react form 里面非受控组件 如何对应上值的改变 "),l("a",{class:"header-anchor",href:"#_26-react-form-里面非受控组件-如何对应上值的改变","aria-label":"Permalink to “26. react form 里面非受控组件 如何对应上值的改变”"},"​")],-1)),e(t,null,{default:s(()=>[...u[17]||(u[17]=[l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"方式"),l("th",null,"数据存放"),l("th",null,"值变化的响应"),l("th",null,"外部值改变时")])]),l("tbody",null,[l("tr",null,[l("td",null,"受控组件"),l("td",null,"React state"),l("td",null,[l("code",null,"onChange"),n(" → setState → 重新渲染")]),l("td",null,"直接受 state 驱动，值自动更新")]),l("tr",null,[l("td",null,"非受控组件"),l("td",null,"DOM 元素内部"),l("td",null,[n("通过 "),l("code",null,"ref"),n(" 读取")]),l("td",null,[n("需要用 "),l("code",null,"ref.current.value = ..."),n(" 手动更新")])])])],-1),l("p",null,"总结",-1),l("ul",null,[l("li",null,"非受控组件默认不会随着 props 变化而更新。"),l("li",null,[n("如果想同步外部变化： "),l("ul",null,[l("li",null,"用 ref + useEffect 直接赋值给 DOM。"),l("li",null,"或者通过改变 key 来强制重建。"),l("li",null,"如果频繁需要同步外部数据，最好改用 受控组件")])])],-1)])]),_:1}),u[44]||(u[44]=l("h3",{id:"_27-antd-form是如何控制内部组件的value的",tabindex:"-1"},[n("27. antd form是如何控制内部组件的value的 "),l("a",{class:"header-anchor",href:"#_27-antd-form是如何控制内部组件的value的","aria-label":"Permalink to “27. antd form是如何控制内部组件的value的”"},"​")],-1)),e(t,null,{default:s(()=>[...u[18]||(u[18]=[l("p",null,"基于 v4+ 分析",-1),l("h5",{id:"总体设计思路",tabindex:"-1"},[n("总体设计思路 "),l("a",{class:"header-anchor",href:"#总体设计思路","aria-label":"Permalink to “总体设计思路”"},"​")],-1),l("p",null,[n("Antd Form 并不是简单地把 "),l("code",null,"<Form.Item>"),n(" 里的 "),l("code",null,"<Input>"),n(" 当作受控组件包一层，而是自己实现了一套 “表单状态管理 + 受控注入” 机制。 核心：")],-1),l("ul",null,[l("li",null,"Form 内部维护一个 FormStore（字段名 → 值 的状态）。"),l("li",null,[n("每个 "),l("code",null,"<Form.Item>"),n(" 都会通过 Context 注册到 FormStore。")]),l("li",null,"FormStore 变化后，通过 Context + forceUpdate 通知对应 Form.Item 重新渲染。"),l("li",null,"Form.Item 渲染时，会把 value 和 onChange 注入到子组件，实现受控。")],-1),l("p",null,"典型用法:",-1),l("div",{class:"language-jsx"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"},"jsx"),l("pre",{class:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabindex:"0",dir:"ltr"},[l("code",null,[l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"<"),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Form"),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," form"),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"{form} "),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"initialValues"),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"{{ username: "),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},"'Tom'"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," }}>")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"  <"),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Form.Item"),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," name"),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"username"'),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},">")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    <"),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Input"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," />")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"  </"),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Form.Item"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},">")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"</"),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Form"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},">")])])])],-1),l("p",null,"对应关系：",-1),l("div",{class:"language-js"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"},"js"),l("pre",{class:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabindex:"0",dir:"ltr"},[l("code",null,[l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"<"),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Form"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},">           —— 维护 FormStore（字段状态）")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"   │")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"   └─<"),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"FormContext.Provider"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},">  —— 提供 Store 和订阅方法")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        │")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"        └─<"),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Form.Item"),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}}," name"),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"username"'),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"> —— 注册字段")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"              │")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"              └─ cloneElement(<"),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Input"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},">, {value, onChange})")])])])],-1),l("ol",null,[l("li",null,"流程详解")],-1),l("ul",null,[l("li",null,[l("ol",null,[l("li",null,"FormStore")]),l("ul",null,[l("li",null,"Form 创建时，内部有一个 store = {} 保存所有字段的值。"),l("li",null,[n("提供方法： "),l("ul",null,[l("li",null,"getFieldValue(name) / getFieldsValue()"),l("li",null,"setFieldValue(name, value)"),l("li",null,"subscribe(callback) 订阅字段变化"),l("li",null,"Form.useForm() 返回的就是对这个 Store 的引用")])])])]),l("li",null,[l("p",null,"2.Form.Item 注册字段"),l("ul",null,[l("li",null,[l("code",null,'<Form.Item name="username">'),n(" 渲染时，会通过 Context 把 name 注册到 Store。")]),l("li",null,"它会订阅对应字段，当该字段值变化时触发 forceUpdate() 来重新渲染该 Item。")])]),l("li",null,[l("ol",{start:"3"},[l("li",null,"克隆子节点注入受控属性")]),l("ul",null,[l("li",null,[n("渲染时，Form.Item 会用 React.cloneElement 给子组件（如 "),l("code",null,"<Input />"),n("）注入：")])]),l("div",{class:"language-js"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"},"js"),l("pre",{class:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabindex:"0",dir:"ltr"},[l("code",null,[l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"  {")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"  value"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},": store[name],")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"  onChange"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},": ("),l("span",{style:{"--shiki-light":"#E36209","--shiki-dark":"#FFAB70"}},"e"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") "),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"=>"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," {")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"    const"),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," newValue"),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}}," ="),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," e "),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"&&"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," e.target "),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"?"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," e.target.value "),l("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},":"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," e;")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    store."),l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"setFieldValue"),l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(name, newValue);")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"  }")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"}")])])])]),l("ul",null,[l("li",null,"这样，子组件（比如 antd Input）变成了 FormStore 受控的受控组件。"),l("li",null,[l("em",null,[l("strong",null,"自定义组件支持接收value,onChange属性即可")])]),l("li",null,"如果原本子组件自己也传了 value 和 onChange，Form.Item 会合并，但以 Form 为主。"),l("li",null,"因此，用 antd Form 时，不需要再手动写 value 和 onChange。")])]),l("li",null,[l("ol",{start:"4"},[l("li",null,"触发更新")]),l("ul",null,[l("li",null,[n("用户在 Input 中输入： "),l("ul",null,[l("li",null,[l("ol",null,[l("li",null,"Input 调用 onChange → store.setFieldValue(name, newValue)")])]),l("li",null,[l("ol",{start:"2"},[l("li",null,"Store 更新值后通知所有订阅者（相关 Form.Item）")])]),l("li",null,[l("ol",{start:"3"},[l("li",null,"对应 Form.Item forceUpdate()，重新渲染，给 Input 新的 value")])]),l("li",null,"从而保证 Input 的显示值始终与 FormStore 中的值同步。")])])])]),l("li",null,[l("p",null,"5.特殊场景"),l("ul",null,[l("li",null,"initialValues：初始渲染时写入 Store，Form.Item 会读取。"),l("li",null,"setFieldsValue / resetFields：调用这些 API 时直接改 Store → 通知订阅 → 触发 Form.Item 更新。"),l("li",null,"dependencies：依赖项变化时重新渲染 Form.Item。"),l("li",null,"shouldUpdate：控制 Form.Item 是否重新渲染。")])])],-1),l("p",null,"受控与非受控的对比",-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"特性"),l("th",null,"普通非受控表单"),l("th",null,"antd Form 内部机制")])]),l("tbody",null,[l("tr",null,[l("td",null,"值存放"),l("td",null,"DOM（通过 defaultValue）"),l("td",null,"FormStore（JS 对象）")]),l("tr",null,[l("td",null,"组件更新"),l("td",null,"用户输入不会触发 React 重新渲染"),l("td",null,"每次输入都更新 Store 并触发 Form.Item 重渲染")]),l("tr",null,[l("td",null,"外部控制"),l("td",null,"需要 ref 手动更新 DOM"),l("td",null,[n("用 "),l("code",null,"form.setFieldsValue()"),n(" 即可更新所有字段")])])])],-1),l("p",null,[n("👉 可以认为： "),l("strong",null,"Antd Form 把所有字段都变成了受控组件，并用集中式 Store 管理。")],-1),l("p",null,[l("strong",null,"总结")],-1),l("ul",null,[l("li",null,[n("核心机制："),l("strong",null,"集中式 FormStore 管理所有字段。")]),l("li",null,"关键手段：Form.Item 通过 Context 注册并订阅字段变化。"),l("li",null,[n("数据流： "),l("ul",null,[l("li",null,"外部调用 setFieldsValue 或用户输入 → 更新 Store → 通知 Form.Item → 渲染子组件 → 子组件显示最新值。")])]),l("li",null,"因此，antd Form 里的 Input、Select、Checkbox 等都是受控的，值完全由 FormStore 决定。")],-1)])]),_:1})])}const E=i(p,[["render",h]]);export{y as __pageData,E as default};
