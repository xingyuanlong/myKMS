import{_ as t,I as o,c as r,o as a,j as l,J as i,a as e,w as s}from"./chunks/framework.09HZKTj5.js";const T=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/base/nodejs.md","filePath":"knowledge/base/nodejs.md"}'),p={name:"knowledge/base/nodejs.md"};function d(k,n,h,m,c,x){const u=o("Collapse");return a(),r("div",null,[n[6]||(n[6]=l("h3",{id:"_1-node-中-require-时发生了什么",tabindex:"-1"},[e("1.Node 中 require 时发生了什么? "),l("a",{class:"header-anchor",href:"#_1-node-中-require-时发生了什么","aria-label":"Permalink to “1.Node 中 require 时发生了什么?”"},"​")],-1)),i(u,null,{default:s(()=>[...n[0]||(n[0]=[l("p",null,"路径解析 => 缓存检查 => 创建模块对象 => 读取与编译 => 执行模块代码 => 标记完成并返回",-1),l("p",null,"require() 缓存检查顺序：",-1),l("ul",null,[l("li",null,[l("ol",null,[l("li",null,"检查原生模块缓存;")])]),l("li",null,[l("ol",{start:"2"},[l("li",null,"检查 require.cache（路径解析后的绝对路径作为 key）。")])]),l("li",null,[l("ol",{start:"3"},[l("li",null,"如果缓存未命中 → 走模块解析;")])]),l("li",null,[l("ol",{start:"4"},[l("li",null,"执行模块，填充 require.cache，返回 module.exports。")])])],-1)])]),_:1}),n[7]||(n[7]=l("h3",{id:"_2-node-js-事件循环机制",tabindex:"-1"},[e("2.Node.js 事件循环机制 "),l("a",{class:"header-anchor",href:"#_2-node-js-事件循环机制","aria-label":"Permalink to “2.Node.js 事件循环机制”"},"​")],-1)),i(u,null,{default:s(()=>[...n[1]||(n[1]=[l("p",null,"六个阶段:",-1),l("ol",null,[l("li",null,"Timers（计时器阶段）执行 setTimeout() 和 setInterval() 的回调"),l("li",null,"Pending callbacks（待定回调阶段）执行系统操作的回调，如 TCP 错误"),l("li",null,"Idle, prepare（闲置准备阶段）内部使用阶段"),l("li",null,"Poll（轮询阶段） - 最重要的阶段 检索新的 I/O 事件，执行 I/O 相关回调"),l("li",null,"Check（检查阶段）执行 setImmediate() 的回调"),l("li",null,"Close callbacks（关闭回调阶段）执行关闭事件的回调，如 socket.on('close', ...)")],-1),l("div",{class:"language-"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"}),l("pre",{class:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabindex:"0",dir:"ltr"},[l("code",null,[l("span",{class:"line"},[l("span",null,"每个阶段的宏任务执行完 →")]),e(`
`),l("span",{class:"line"},[l("span",null,"    执行所有 nextTick 回调 →")]),e(`
`),l("span",{class:"line"},[l("span",null,"    执行所有微任务 (Promise)")]),e(`
`),l("span",{class:"line"},[l("span",null,"→ 进入下一个阶段")])])])],-1),l("p",null,"注意: 滥用 process.nextTick：会阻塞后续阶段（饿死循环）。",-1),l("p",null,[l("strong",null,"优先级关系"),l("strong",null,"process.nextTick() > Promise.then() > setTimeout() > setImmediate()")],-1),l("ul",null,[l("li",null,"Node 的事件循环由 libuv 实现，循环有 timers → pending → poll → check → close 等阶段。"),l("li",null,"微任务： process.nextTick（最高优先）→ Promise.then（微任务）。"),l("li",null,"setImmediate 与 setTimeout(0) 的先后取决于上下文（在 I/O 回调中 setImmediate 会优先）。"),l("li",null,"线程池 用于无法立即非阻塞完成的工作（默认线程数 ≈4，可通过 UV_THREADPOOL_SIZE 设置）。"),l("li",null,"不要阻塞 主线程，必要时用 worker_threads 或外部服务/进程。")],-1)])]),_:1}),n[8]||(n[8]=l("h3",{id:"_3-process-nexttick-与-settimeout-的区别",tabindex:"-1"},[e("3.process.nextTick 与 setTimeout 的区别 "),l("a",{class:"header-anchor",href:"#_3-process-nexttick-与-settimeout-的区别","aria-label":"Permalink to “3.process.nextTick 与 setTimeout 的区别”"},"​")],-1)),i(u,null,{default:s(()=>[...n[2]||(n[2]=[l("ul",null,[l("li",null,"process.nextTick 在当前事件循环结束时执行"),l("li",null,"setTimeout(fn, 0) 在下一个事件循环开始时执行"),l("li",null,"nextTick 优先级更高")],-1)])]),_:1}),n[9]||(n[9]=l("h3",{id:"_4-koa-与-express-的区别",tabindex:"-1"},[e("4.Koa 与 Express 的区别 "),l("a",{class:"header-anchor",href:"#_4-koa-与-express-的区别","aria-label":"Permalink to “4.Koa 与 Express 的区别”"},"​")],-1)),i(u,null,{default:s(()=>[...n[3]||(n[3]=[l("ol",null,[l("li",null,"中间件机制")],-1),l("ul",null,[l("li",null,"Express：单向流动，中间件通过 next() 线性执行，一旦响应结束就不能修改"),l("li",null,"Koa：洋葱模型，中间件既可以处理请求也可以处理响应，支持统一的错误处理")],-1),l("ol",{start:"2"},[l("li",null,"异步处理")],-1),l("ul",null,[l("li",null,"Express：基于回调函数，容易陷入回调地狱，异步错误处理相对复杂"),l("li",null,"Koa：基于 Promise 和 async/await，代码更简洁，异步流程控制更直观")],-1),l("ol",{start:"3"},[l("li",null,"上下文对象")],-1),l("ul",null,[l("li",null,"Express：req 和 res 是分离的对象，功能相对分散"),l("li",null,"Koa：ctx 统一上下文，封装了 request 和 response，API 设计更简洁优雅")],-1),l("ol",{start:"4"},[l("li",null,"功能内置")],-1),l("ul",null,[l("li",null,"Express：内置了很多中间件，功能齐全，开箱即用"),l("li",null,"Koa：核心功能精简，需要通过第三方中间件扩展，更加灵活")],-1),l("ol",{start:"5"},[l("li",null,"路由系统")],-1),l("ul",null,[l("li",null,"Express：内置了强大的路由系统，支持链式调用"),l("li",null,"Koa：路由需要通过第三方中间件实现（如 koa-router）")],-1),l("p",null,"6.社区生态",-1),l("ul",null,[l("li",null,"Express：历史更悠久，社区更成熟，资源更丰富"),l("li",null,"Koa：较新但发展迅速，设计更现代，适合新项目")],-1),l("ol",{start:"7"},[l("li",null,"错误处理")],-1),l("ul",null,[l("li",null,"Express：通过特殊的错误处理中间件，需要手动传递错误"),l("li",null,"Koa：通过 try/catch 优雅地处理错误，统一的错误处理更方便")],-1),l("ol",{start:"8"},[l("li",null,"适用场景")],-1),l("ul",null,[l("li",null,"Express：适合快速开发，现有项目迁移，团队熟悉度高"),l("li",null,"Koa：适合追求优雅代码，需要更好的异步流程控制的场景")],-1)])]),_:1}),n[10]||(n[10]=l("h3",{id:"_5-jwt-如何自动更新-token",tabindex:"-1"},[e("5.JWT 如何自动更新 token "),l("a",{class:"header-anchor",href:"#_5-jwt-如何自动更新-token","aria-label":"Permalink to “5.JWT 如何自动更新 token”"},"​")],-1)),i(u,null,{default:s(()=>[...n[4]||(n[4]=[l("p",null,"采用JWT 双 Token 模式：Access Token + Refresh Token",-1),l("table",{tabindex:"0"},[l("thead",null,[l("tr",null,[l("th",null,"类型"),l("th",null,"作用"),l("th",null,"有效期"),l("th",null,"存储位置")])]),l("tbody",null,[l("tr",null,[l("td",null,[l("strong",null,"Access Token")]),l("td",null,"每次请求携带，用于认证用户身份"),l("td",null,"短（几分钟 ~ 几小时）"),l("td",null,"浏览器内存 / localStorage / cookie")]),l("tr",null,[l("td",null,[l("strong",null,"Refresh Token")]),l("td",null,"用于申请新的 Access Token"),l("td",null,"长（几天 ~ 几周）"),l("td",null,"安全 Cookie / HttpOnly 存储")])])],-1),l("p",null,"当前端收到 401 且检测到是 “Access Token 过期”时, 用Refresh Token 获取新的Access Token",-1),l("p",null,"前端思路:",-1),l("ul",null,[l("li",null,"封装请求拦截器；"),l("li",null,"如果请求返回 401，且不是刷新请求；"),l("li",null,"尝试调用 /auth/refresh；"),l("li",null,"刷新成功 → 重试原请求；"),l("li",null,"刷新失败 → 跳转登录。")],-1),l("ol",null,[l("li",null,[l("p",null,"滑动过期（Sliding Expiration）"),l("ul",null,[l("li",null,"每次用户请求时，如果 Access Token 快过期，自动签发新 Token(playload 可以加过期时间)")])]),l("li",null,[l("p",null,"令牌版本号机制"),l("ul",null,[l("li",null,"每个用户在数据库中维护一个 tokenVersion；当刷新或登出时，更新版本号；旧的 Refresh Token 因版本号不匹配立即失效。")])]),l("li",null,[l("p",null,"JWT 自动续期时的“并发刷新冲突问题”"),l("ul",null,[l("li",null,[e("同一时间只允许一次刷新操作,其他请求等待刷新完成后再继续。 "),l("ul",null,[l("li",null,"请求队列 + 刷新锁"),l("li",null,[e("当第一个请求检测到 token 过期时： "),l("ul",null,[l("li",null,"标记一个全局变量 isRefreshing = true"),l("li",null,"发起 /auth/refresh 请求"),l("li",null,"其他同时失败的请求 不要立即刷新，而是放进一个队列 pendingRequests")])]),l("li",null,[e("刷新成功后： "),l("ul",null,[l("li",null,"更新新的 token；"),l("li",null,"依次重放（retry）队列中的请求；"),l("li",null,"清空队列；"),l("li",null,"重置 isRefreshing = false。")])])])]),l("li",null,[e("刷新令牌幂等化 "),l("ul",null,[l("li",null,"若在短时间内多次使用同一个 refresh token,后端可以检测并返回同一个新 token（或最新有效 token），而不是直接报错“refresh token 已被使用”。")])]),l("li",null,[e("刷新限流 "),l("ul",null,[l("li",null,"对同一个用户的刷新操作设置时间间隔限制（例如 5 秒内只允许一次刷新）")])])])])],-1)])]),_:1}),n[11]||(n[11]=l("h3",{id:"_6-扫描登录如何实现",tabindex:"-1"},[e("6.扫描登录如何实现? "),l("a",{class:"header-anchor",href:"#_6-扫描登录如何实现","aria-label":"Permalink to “6.扫描登录如何实现?”"},"​")],-1)),i(u,null,{default:s(()=>[...n[5]||(n[5]=[l("p",null,"PC浏览器 <———> 服务器 <———> 手机App",-1),l("ul",null,[l("li",null,[l("p",null,"浏览器打开登录页"),l("ul",null,[l("li",null,"前端请求后端生成一个 唯一的登录二维码"),l("li",null,"二维码内容通常是一个 临时 login_token（或UUID）"),l("li",null,"二维码展示给用户")])]),l("li",null,[l("p",null,"用户用手机App扫码"),l("ul",null,[l("li",null,"App 扫描二维码，得到 login_token"),l("li",null,"App 发请求到服务器，验证该二维码是否合法"),l("li",null,"如果合法，App 显示提示「是否允许登录该网页？」")])]),l("li",null,[l("p",null,"用户在手机上点击「确认登录」"),l("ul",null,[l("li",null,"App 带着登录状态的用户信息，调用后端接口"),l("li",null,"服务端保存：该 login_token 对应的登录状态")])]),l("li",null,[l("p",null,"网页端轮询或WebSocket等待登录结果"),l("ul",null,[l("li",null,"网页端每隔1-2秒查询登录结果"),l("li",null,"如果发现 login_token 已被确认绑定用户，则返回成功状态 + 用户信息")])]),l("li",null,[l("p",null,"浏览器登录成功"),l("ul",null,[l("li",null,"前端拿到 token（如JWT），存入 Cookie / LocalStorage"),l("li",null,"重定向到首页，登录完成")])])],-1)])]),_:1}),n[12]||(n[12]=l("h3",{id:"其他",tabindex:"-1"},[e("其他 "),l("a",{class:"header-anchor",href:"#其他","aria-label":"Permalink to “其他”"},"​")],-1)),n[13]||(n[13]=l("ul",null,[l("li",null,[l("strong",null,"eggjs 默认worker 和cpu核心数相同, 如果是物理机器,可能需要指定worker 数")]),l("li",null,"登录后页面多次自动重复刷新后,才正常进去, a 服务颁发的token, b 服务短时间后才正常认证,可能是2个机器时间不一致,差几秒或者几十秒")],-1))])}const g=t(p,[["render",d]]);export{T as __pageData,g as default};
