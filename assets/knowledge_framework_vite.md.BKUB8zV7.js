import{_ as i,I as d,c as n,o as r,ah as l,J as s,w as o,j as t}from"./chunks/framework.fGi7qB65.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/framework/vite.md","filePath":"knowledge/framework/vite.md"}'),g={name:"knowledge/framework/vite.md"};function u(p,e,f,c,x,b){const a=d("Collapse");return r(),n("div",null,[e[1]||(e[1]=l('<h2 id="webpack" tabindex="-1">webpack <a class="header-anchor" href="#webpack" aria-label="Permalink to “webpack”">​</a></h2><h3 id="_1-webpack-的工作流程" tabindex="-1">1.Webpack 的工作流程 <a class="header-anchor" href="#_1-webpack-的工作流程" aria-label="Permalink to “1.Webpack 的工作流程”">​</a></h3><p>Webpack 的工作流程</p><ul><li><ol><li>入口（Entry）：从指定文件（如 index.js）开始分析依赖。</li></ol></li><li><ol start="2"><li>依赖图（Dependency Graph）：递归构建模块间的依赖关系。</li></ol></li><li><ol start="3"><li>加载器（Loaders）：转换非 JS 资源（如编译 Sass、处理图片）。</li></ol></li><li><ol start="4"><li>插件（Plugins）：在构建生命周期中执行优化任务。</li></ol></li><li><ol start="5"><li>输出（Output）：生成优化后的静态文件（如 bundle.js）。</li></ol></li></ul><h3 id="_2-webpack-中的-loaders-和-plugins-有什么区别" tabindex="-1">2.Webpack 中的 Loaders 和 Plugins 有什么区别 <a class="header-anchor" href="#_2-webpack-中的-loaders-和-plugins-有什么区别" aria-label="Permalink to “2.Webpack 中的 Loaders 和 Plugins 有什么区别”">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">对比项</th><th style="text-align:left;"><strong>Loader</strong></th><th style="text-align:left;"><strong>Plugin</strong></th></tr></thead><tbody><tr><td style="text-align:left;">作用阶段</td><td style="text-align:left;">文件加载、转换阶段（打包前）</td><td style="text-align:left;">编译、打包的整个生命周期</td></tr><tr><td style="text-align:left;">操作对象</td><td style="text-align:left;">单个模块文件（JS、CSS、图片等）</td><td style="text-align:left;">整个编译过程（模块、资源、chunk、输出）</td></tr><tr><td style="text-align:left;">类型</td><td style="text-align:left;">转换器（Transformer）</td><td style="text-align:left;">扩展器（Enhancer）</td></tr><tr><td style="text-align:left;">常见用途</td><td style="text-align:left;">把非 JS 资源转成 JS 模块</td><td style="text-align:left;">优化、注入、压缩、环境变量等</td></tr><tr><td style="text-align:left;">调用方式</td><td style="text-align:left;"><code>module.rules</code> 中配置 <code>use</code></td><td style="text-align:left;"><code>plugins</code> 数组中配置</td></tr><tr><td style="text-align:left;">工作机制</td><td style="text-align:left;">线性执行（从右到左）</td><td style="text-align:left;">基于 Tapable 的事件钩子机制</td></tr><tr><td style="text-align:left;">示例</td><td style="text-align:left;"><code>babel-loader</code>, <code>css-loader</code>, <code>url-loader</code></td><td style="text-align:left;"><code>HtmlWebpackPlugin</code>, <code>DefinePlugin</code>, <code>MiniCssExtractPlugin</code></td></tr></tbody></table><p>Loader 执行机制</p><ul><li>串行执行（从右到左）；</li><li>每个 loader 接收上一个 loader 的结果；</li><li>只能处理文件内容字符串；</li><li>是一个纯函数（无副作用）。</li></ul><p>Plugin 执行机制</p><ul><li>通过 Webpack 的 Tapable 钩子系统；</li><li>插入到 Webpack 的编译生命周期中；</li><li>可以访问 compiler、compilation 对象；</li><li>可读可写资源、依赖、输出、日志等。</li></ul><h3 id="_3-tree-shaking" tabindex="-1">3.Tree Shaking <a class="header-anchor" href="#_3-tree-shaking" aria-label="Permalink to “3.Tree Shaking”">​</a></h3><p>Tree Shaking = 静态分析 + dead code elimination</p><ul><li>去除未使用代码的技术, ESM 的 import/export 是静态分析的. 本质目标：减少打包体积，把代码中 未引用的函数、变量、类 剔除掉。</li><li>支持条件: <ul><li>必须使用 ES Module;</li><li>导出必须是静态; 副作用(如果模块执行会有副作用（如修改全局变量），Tree Shaking 默认不会移除整个模块).</li><li>动态 import 可以按需加载，但静态分析更高效;</li><li>类库打包方式影响 Tree Shaking(lodash/es → 支持 Tree Shaking,lodash → CommonJS，不支持)</li></ul></li></ul><hr><h2 id="vite" tabindex="-1">vite <a class="header-anchor" href="#vite" aria-label="Permalink to “vite”">​</a></h2><h3 id="_1-简述vite的依赖预加载机制" tabindex="-1">1. 简述Vite的依赖预加载机制 <a class="header-anchor" href="#_1-简述vite的依赖预加载机制" aria-label="Permalink to “1. 简述Vite的依赖预加载机制”">​</a></h3><p><strong>Vite 的依赖预构建机制通过在开发模式下提前处理常用依赖（如 Vue、React 等），将这些依赖转换为浏览器可以直接执行的格式。这避免了每次启动时重新编译这些依赖，显著提升了启动速度。</strong>预构建的依赖被缓存，并在后续启动时复用缓存，进一步加速了开发过程中的构建和启动时间。</p><p>具体来说，它的工作原理如下：</p><ol><li>依赖识别和路径补全： Vite 会首先识别项目中需要的依赖，并对非绝对路径或相对路径的引用进行路径补全。比如，Vue 的加载路径会变为 node_modules/.vite/deps/Vue.js?v=1484ebe8，这一路径显示了 Vite 在 node_modules/.vite/deps 文件夹下存放了经过预处理的依赖文件。</li><li>转换成 ES 模块： 一些第三方包（特别是遵循 CommonJS 规范的包）在浏览器中无法直接使用。为了应对这种情况，Vite 会使用 esbuild 工具将这些依赖转换为符合 ES 模块规范的代码。转换后的代码会被存放在 node_modules/.vite/deps 文件夹下，这样浏览器就能直接识别并加载这些依赖。</li><li>统一集成 ES 模块： Vite 会对每个包的不同模块进行统一集成，将各个分散的模块（如不同的 ES 函数或组件）合并成一个或几个文件。这不仅减少了浏览器发起多个请求的次数，还能够加快页面加载速度</li></ol><h3 id="_2-vite-hmr-模块热更新-与webpack对比" tabindex="-1">2. vite HMR 模块热更新 (与webpack对比) <a class="header-anchor" href="#_2-vite-hmr-模块热更新-与webpack对比" aria-label="Permalink to “2. vite HMR 模块热更新 (与webpack对比)”">​</a></h3>',20)),s(a,null,{default:o(()=>[...e[0]||(e[0]=[t("p",null,"修改代码 → 浏览器自动更新 → 状态不丢失",-1),t("p",null,"基本工作原理",-1),t("ol",null,[t("li",null,"开发服务器启动时：Vite 会用 ES Module 的方式向浏览器提供源码。"),t("li",null,"文件变动：Vite 通过 chokidar 监听文件改动。"),t("li",null,"HMR 通知：Vite Dev Server 用 WebSocket 通知浏览器“某个模块变了”。type:'update', updates 更新的文件内容"),t("li",null,"模块替换：浏览器端的 Vite HMR 客户端会：尝试只替换改动的模块（比如 .vue 组件、.css 文件）。如i18n.json 文件修改, 会刷新页面"),t("li",null,"import.meta.hot 可以手动控制 HMR 行为"),t("li",null,"Vite 内部维护一份 模块依赖图,向上传播，找接受更新的模块, 如果无法安全替换（比如入口文件改了），就会触发 整页刷新。")],-1),t("p",null,"Webpack HMR:基本原理一致, 开发时需要 打包，生成 bundle.js, 因为有打包过程，HMR 会比 Vite 慢",-1),t("p",null,"为什么 Vite 的 HMR 比 Webpack 快？",-1),t("ol",null,[t("li",null,"Vite 基于 原生 ESM，不用重新打整个 bundle。"),t("li",null,"改动时只编译改动文件（按需编译）。"),t("li",null,"Webpack 需要走完整的打包流程，依赖图越大更新越慢。"),t("li",null,"所以在大项目里，Webpack 热更新可能要几秒，而 Vite 通常 <100ms。")],-1),t("p",null,"Vite 如何实现 React/Vue 的状态保留热更新？",-1),t("ol",null,[t("li",null,"React：通过 @vitejs/plugin-react 集成 react-refresh，在替换组件时保留 Hook 状态。"),t("li",null,"Vue：通过 @vitejs/plugin-vue，在替换 .vue 组件时保留组件实例的响应式状态。"),t("li",null,"本质：框架层插件拦截 HMR 更新过程，执行“局部替换 + 状态迁移”。")],-1),t("p",null,"Vite HMR 可能带来的问题？",-1),t("ol",null,[t("li",null,"内存泄漏：模块替换时没清理事件监听 / 定时器。"),t("li",null,"调试复杂度：和实际生产行为不一致（生产中没有 HMR）。"),t("li",null,"兼容性问题：某些第三方库没有 HMR 支持，只能整页刷新")],-1)])]),_:1}),e[2]||(e[2]=l('<h3 id="webpack-与-vite" tabindex="-1">.Webpack 与 Vite <a class="header-anchor" href="#webpack-与-vite" aria-label="Permalink to “.Webpack 与 Vite”">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">对比项</th><th style="text-align:left;"><strong>Webpack</strong></th><th style="text-align:left;"><strong>Vite</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>核心思想</strong></td><td style="text-align:left;">一次性<strong>打包所有文件</strong>再启动开发服务器</td><td style="text-align:left;"><strong>按需编译（ESM 原生支持）</strong>，依赖与源码分离处理</td></tr><tr><td style="text-align:left;"><strong>启动阶段</strong></td><td style="text-align:left;">需先打包整个项目（构建依赖图 → 打包输出）</td><td style="text-align:left;">启动极快，仅分析依赖，不预打包源码</td></tr><tr><td style="text-align:left;"><strong>开发模式 (dev)</strong></td><td style="text-align:left;">使用 webpack-dev-server：<br>所有模块打包成 bundle 后再提供服务</td><td style="text-align:left;">使用原生 ESM：<br>直接通过浏览器请求模块，Vite 拦截并按需编译返回</td></tr><tr><td style="text-align:left;"><strong>热更新 (HMR)</strong></td><td style="text-align:left;">修改文件后需重新打包相关 chunk，代价较高</td><td style="text-align:left;">仅重新编译变动的模块源码（原生 ESM 热替换），非常快</td></tr><tr><td style="text-align:left;"><strong>构建阶段 (build)</strong></td><td style="text-align:left;">打包时用 loader + plugin 处理所有文件，输出 bundle</td><td style="text-align:left;">构建阶段由 <strong>Rollup</strong> 完成打包（利用 ESM 静态分析）</td></tr><tr><td style="text-align:left;"><strong>打包粒度</strong></td><td style="text-align:left;">依赖与源码一起打包成 bundle</td><td style="text-align:left;">依赖单独预构建（esbuild），源码按需处理</td></tr><tr><td style="text-align:left;"><strong>依赖处理</strong></td><td style="text-align:left;">JS、CSS、图片等都需 loader 解析</td><td style="text-align:left;">依赖模块（node_modules）由 <strong>esbuild</strong> 预构建，源码按请求动态编译</td></tr><tr><td style="text-align:left;"><strong>性能瓶颈</strong></td><td style="text-align:left;">打包体积大、编译速度慢（依赖 AST 分析）</td><td style="text-align:left;">使用 <strong>esbuild（Go 编写）</strong>，依赖构建快 10-100 倍</td></tr><tr><td style="text-align:left;"><strong>构建结果</strong></td><td style="text-align:left;">输出多个 bundle 文件</td><td style="text-align:left;">输出原生 ESM 模块（经 Rollup 优化）</td></tr><tr><td style="text-align:left;"><strong>适用场景</strong></td><td style="text-align:left;">大型复杂项目，生态成熟（如 React + Webpack5）</td><td style="text-align:left;">快速开发、现代浏览器环境（Vue3、React18）</td></tr><tr><td style="text-align:left;"><strong>插件机制</strong></td><td style="text-align:left;">Tapable 构建的复杂插件系统</td><td style="text-align:left;">Rollup + Vite Hook，轻量、直观</td></tr><tr><td style="text-align:left;"><strong>配置复杂度</strong></td><td style="text-align:left;">配置项繁多（entry、loader、plugin 等）</td><td style="text-align:left;">默认开箱即用，配置极简（vite.config.js）</td></tr><tr><td style="text-align:left;"><strong>首次启动速度</strong></td><td style="text-align:left;">慢：需先打完整包</td><td style="text-align:left;">快：直接启动服务器即可运行</td></tr><tr><td style="text-align:left;"><strong>生产打包速度</strong></td><td style="text-align:left;">中等（依赖 JS 解析打包）</td><td style="text-align:left;">快：esbuild + Rollup 组合优化</td></tr><tr><td style="text-align:left;"><strong>调试体验</strong></td><td style="text-align:left;">源码被打包，调试路径复杂</td><td style="text-align:left;">源码即模块，调试路径清晰</td></tr><tr><td style="text-align:left;"><strong>静态资源处理</strong></td><td style="text-align:left;">需配置 loader（file-loader/url-loader）</td><td style="text-align:left;">内置资源处理机制，直接 import 即可</td></tr><tr><td style="text-align:left;"><strong>依赖缓存</strong></td><td style="text-align:left;">可配置 cache-loader</td><td style="text-align:left;">自动缓存依赖（esbuild 缓存 + HTTP 缓存）</td></tr></tbody></table><ul><li><p>webpack 的打包流程: 读取配置 → 创建 Compiler → 从入口构建依赖图 → Loader 转换模块 → Plugin 优化 → 生成 Chunk → 输出文件。</p></li><li><p>vite 开发时走原生 ESM + 按需编译，而生产环境走 Rollup 打包。vite 打包流程: 配置解析 -&gt; 调用 Rollup 构建 -&gt; 优化处理 -&gt; 产物生成</p></li></ul><h3 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to “其他”">​</a></h3><ul><li>webpack 打包速度分析, speed-measure-webpack-plugin, 打包大小分析: webpack-bundle-analyze</li><li>安装相同的但不同版本的组件库, 取别名 npm i alias@npm:name@^verison</li></ul>',5))])}const k=i(g,[["render",u]]);export{h as __pageData,k as default};
